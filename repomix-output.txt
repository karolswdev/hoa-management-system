This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-10-12T18:13:37.697Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
backend/
  config/
    config.json
  migrations/
    20250531213155-create-users-table.js
    20250531214039-create-users-table.js
    20250531214112-create-config-table.js
    20250531214127-create-verification-tokens-table.js
    20250531214148-create-events-table.js
    20250531214209-create-documents-table.js
    20250531214211-add-original-file-name-to-documents.js
    20250531214231-create-discussions-table.js
    20250531214251-create-announcements-table.js
    20250531214312-create-audit-logs-table.js
    20250531221950-add-expires_at-to-announcements.js
  models/
    announcement.model.js
    auditLog.model.js
    config.model.js
    discussion.model.js
    document.model.js
    event.model.js
    index.js
    user.model.js
    verificationToken.model.js
  seeders/
    20250531214351-initial-admin-user.js
    20250531214406-initial-site-config.js
  src/
    controllers/
      admin.user.controller.js
      announcement.controller.js
      audit.controller.js
      auth.controller.js
      config.controller.js
      discussion.controller.js
      document.controller.js
      event.controller.js
      user.controller.js
    middlewares/
      auth.middleware.js
      upload.middleware.js
      validate.middleware.js
    routes/
      admin.user.routes.js
      announcement.routes.js
      audit.routes.js
      auth.routes.js
      config.routes.js
      discussion.routes.js
      document.routes.js
      event.routes.js
      public.document.routes.js
      user.routes.js
    services/
      announcement.service.js
      audit.service.js
      auth.service.js
      config.service.js
      discussion.service.js
      document.service.js
      event.service.js
      user.service.js
    utils/
      ApiError.js
      catchAsync.js
    validators/
      admin.user.validator.js
      announcement.validator.js
      audit.validator.js
      auth.validator.js
      config.validator.js
      discussion.validator.js
      document.validator.js
      event.validator.js
      user.validator.js
    app.js
  test/
    good/
      announcements.test.js
      audit.test.js
      auth.test.js
      config.test.js
      discussions.test.js
      documents.test.js
      events.test.js
      users.test.js
    integration/
      discussions.test.js
      events.test.js
    seeders/
      test-seed.js
    utils/
      dbHelpers.js
      testSetup.js
  package.json
deploy/
  nginx/
    hoa-management.conf
  deploy.sh
  DEPLOYMENT_GUIDE.md
  docker-compose.prod.yml
  production.env
  setup-server.sh
frontend/
  .vite/
    deps/
      _metadata.json
      package.json
  public/
    vite.svg
  src/
    assets/
      react.svg
    components/
      admin/
        AdminDataTable.tsx
      auth/
        AccountStatusPage.tsx
      common/
        ProtectedRoute.tsx
        PublicRoute.tsx
      layout/
        Layout.tsx
    contexts/
      AuthContext.tsx
      NotificationContext.tsx
    hooks/
      useApiNotifications.ts
    pages/
      admin/
        AdminAnnouncementsPage.tsx
        AdminAuditPage.tsx
        AdminConfigPage.tsx
        AdminDashboardPage.tsx
        AdminDocumentsPage.tsx
        AdminEventsPage.tsx
        AdminUsersPage.tsx
      auth/
        ForgotPasswordPage.tsx
        LoginPage.tsx
        RegisterPage.tsx
        ResetPasswordPage.tsx
      member/
        AnnouncementsPage.tsx
        DashboardPage.tsx
        DiscussionsPage.tsx
        DiscussionThreadPage.tsx
        DocumentsPage.tsx
        EventsPage.tsx
        ProfilePage.tsx
      public/
        PublicHomePage.tsx
      create_pages.sh
    services/
      api.ts
    theme/
      theme.ts
    types/
      api.ts
    App.css
    App.tsx
    index.css
    main.tsx
    vite-env.d.ts
  .dockerignore
  .env.example
  .gitignore
  Dockerfile
  eslint.config.js
  hoa-management.conf
  index.html
  nginx.conf
  package.json
  README.md
  repomix-output.txt
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
.dockerignore
.env.example
.gitignore
API-overview.md
backend-system-analysis.md
DOCKER_GUIDE.md
docker-compose.yml
Dockerfile
Dockerfile.test
phases.md
README.md
USER_GUIDE.md

================================================================
Files
================================================================

================
File: backend/config/config.json
================
{
  "development": {
    "dialect": "sqlite",
    "storage": "database/hoa.db"
  },
  "test": {
    "dialect": "sqlite",
    "storage": "database/test.db"
  },
  "production": {
    "dialect": "sqlite",
    "storage": "database/hoa.db"
  }
}

================
File: backend/migrations/20250531213155-create-users-table.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    /**
     * Add altering commands here.
     *
     * Example:
     * await queryInterface.createTable('users', { id: Sequelize.INTEGER });
     */
  },

  async down (queryInterface, Sequelize) {
    /**
     * Add reverting commands here.
     *
     * Example:
     * await queryInterface.dropTable('users');
     */
  }
};

================
File: backend/migrations/20250531214039-create-users-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('users', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false
      },
      email: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true
      },
      password: {
        type: Sequelize.STRING,
        allowNull: false
      },
      role: {
        type: Sequelize.STRING,
        allowNull: false,
        defaultValue: 'member'
      },
      status: {
        type: Sequelize.STRING,
        allowNull: false,
        defaultValue: 'pending'
      },
      email_verified: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      is_system_user: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('users');
  }
};

================
File: backend/migrations/20250531214112-create-config-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('config', {
      key: {
        type: Sequelize.STRING,
        primaryKey: true,
        allowNull: false
      },
      value: {
        type: Sequelize.TEXT
      }
      // No timestamps for config table
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('config');
  }
};

================
File: backend/migrations/20250531214127-create-verification-tokens-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('verification_tokens', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      user_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'users', // Name of the target table
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },
      token: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true
      },
      type: {
        type: Sequelize.STRING, // e.g., 'email_verification', 'password_reset'
        allowNull: false
      },
      expires_at: {
        type: Sequelize.DATE,
        allowNull: false
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
      // No updated_at for verification tokens
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('verification_tokens');
  }
};

================
File: backend/migrations/20250531214148-create-events-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('events', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: false
      },
      description: {
        type: Sequelize.TEXT
      },
      start_date: {
        type: Sequelize.DATE,
        allowNull: false
      },
      end_date: {
        type: Sequelize.DATE,
        allowNull: false
      },
      location: {
        type: Sequelize.STRING,
        allowNull: false
      },
      created_by: {
        type: Sequelize.INTEGER,
        allowNull: true,
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('events');
  }
};

================
File: backend/migrations/20250531214209-create-documents-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('documents', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: false
      },
      description: {
        type: Sequelize.TEXT
      },
      file_name: { // Stored unique name
        type: Sequelize.STRING,
        allowNull: false
      },
      file_path: { // Server path
        type: Sequelize.STRING,
        allowNull: false
      },
      uploaded_by: {
        type: Sequelize.INTEGER,
        allowNull: true,
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      approved: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      is_public: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      uploaded_at: { // mapped from createdAt
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('documents');
  }
};

================
File: backend/migrations/20250531214211-add-original-file-name-to-documents.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    await queryInterface.addColumn('documents', 'original_file_name', {
      type: Sequelize.STRING,
      allowNull: false,
    });
  },

  async down (queryInterface, Sequelize) {
    await queryInterface.removeColumn('documents', 'original_file_name');
  }
};

================
File: backend/migrations/20250531214231-create-discussions-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('discussions', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: true // Nullable for replies
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: false
      },
      user_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'users', // Table name should be 'Users' if model name is User
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL' // Or 'CASCADE' if discussions should be deleted with user
      },
      parent_id: {
        type: Sequelize.INTEGER,
        allowNull: true, // Null for main threads
        references: {
          model: 'discussions', // Self-reference
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE' // If parent thread is deleted, replies are also deleted
      },
      document_id: {
        type: Sequelize.INTEGER,
        allowNull: true, // Null if not linked to a document
        references: {
          model: 'documents',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('discussions');
  }
};

================
File: backend/migrations/20250531214251-create-announcements-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('announcements', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: false
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: false
      },
      created_by: {
        type: Sequelize.INTEGER,
        allowNull: true,
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('announcements');
  }
};

================
File: backend/migrations/20250531214312-create-audit-logs-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('audit_logs', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      admin_id: {
        type: Sequelize.INTEGER,
        allowNull: true, // As admin user might be deleted
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      action: {
        type: Sequelize.STRING,
        allowNull: false
      },
      details: {
        type: Sequelize.TEXT // Can store JSON string or plain text
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
      // No updated_at for audit logs
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('audit_logs');
  }
};

================
File: backend/migrations/20250531221950-add-expires_at-to-announcements.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.addColumn('announcements', 'expires_at', {
      type: Sequelize.DATE,
      allowNull: true,
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.removeColumn('announcements', 'expires_at');
  }
};

================
File: backend/models/announcement.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Announcement extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Announcement.belongsTo(models.User, {
        foreignKey: 'created_by',
        as: 'creator',
        onDelete: 'SET NULL', // If user is deleted, announcement's creator is set to null
      });
    }
  }
  Announcement.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false
    },
    content: {
      type: DataTypes.TEXT,
      allowNull: false
    },
    created_by: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if creator user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    },
    expires_at: {
      type: DataTypes.DATE,
      allowNull: true
    }
  }, {
    sequelize,
    modelName: 'Announcement',
    tableName: 'announcements',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Announcement;
};

================
File: backend/models/auditLog.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class AuditLog extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      AuditLog.belongsTo(models.User, {
        foreignKey: 'admin_id',
        as: 'adminUser', // Alias for the admin user who performed the action
        onDelete: 'SET NULL', // If admin user is deleted, keep the log but set admin_id to null
      });
    }
  }
  AuditLog.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    admin_id: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if admin user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    },
    action: {
      type: DataTypes.STRING,
      allowNull: false
    },
    details: {
      type: DataTypes.TEXT // Can store JSON string or plain text
    }
  }, {
    sequelize,
    modelName: 'AuditLog',
    tableName: 'audit_logs',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: false // Audit logs are typically immutable after creation
  });
  return AuditLog;
};

================
File: backend/models/config.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Config extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
    }
  }
  Config.init({
    key: {
      type: DataTypes.STRING,
      primaryKey: true,
      allowNull: false
    },
    value: {
      type: DataTypes.TEXT
    }
  }, {
    sequelize,
    modelName: 'Config',
    tableName: 'config',
    timestamps: false // No createdAt/updatedAt for config table as per original schema
  });
  return Config;
};

================
File: backend/models/discussion.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Discussion extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Discussion.belongsTo(models.User, {
        foreignKey: 'user_id',
        as: 'author',
        onDelete: 'SET NULL', // If user is deleted, discussion's author is set to null
      });
      Discussion.belongsTo(models.Discussion, {
        foreignKey: 'parent_id',
        as: 'parentThread',
        onDelete: 'CASCADE', // If parent thread is deleted, replies are also deleted
      });
      Discussion.hasMany(models.Discussion, {
        foreignKey: 'parent_id',
        as: 'replies',
      });
      Discussion.belongsTo(models.Document, {
        foreignKey: 'document_id',
        as: 'relatedDocument',
        onDelete: 'SET NULL', // If document is deleted, link is removed
      });
    }
  }
  Discussion.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: true // Nullable for replies
    },
    content: {
      type: DataTypes.TEXT,
      allowNull: false
    },
    user_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'users',
        key: 'id'
      }
    },
    parent_id: {
      type: DataTypes.INTEGER,
      allowNull: true, // Null for main threads
      references: {
        model: 'discussions', // Self-reference
        key: 'id'
      }
    },
    document_id: {
      type: DataTypes.INTEGER,
      allowNull: true, // Null if not linked to a document
      references: {
        model: 'documents',
        key: 'id'
      }
    }
  }, {
    sequelize,
    modelName: 'Discussion',
    tableName: 'discussions',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Discussion;
};

================
File: backend/models/document.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Document extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Document.belongsTo(models.User, {
        foreignKey: 'uploaded_by',
        as: 'uploader',
        onDelete: 'SET NULL', // If user is deleted, document's uploader is set to null
      });
      // If discussions can be linked to documents
      Document.hasMany(models.Discussion, {
        foreignKey: 'document_id',
        as: 'relatedDiscussions'
      });
    }
  }
  Document.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false
    },
    description: {
      type: DataTypes.TEXT
    },
    file_name: { // Stored unique name
      type: DataTypes.STRING,
      allowNull: false
    },
    file_path: { // Server path
      type: DataTypes.STRING,
      allowNull: false
    },
    original_file_name: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    uploaded_by: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if uploader user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    },
    approved: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    is_public: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    }
  }, {
    sequelize,
    modelName: 'Document',
    tableName: 'documents',
    timestamps: true,
    createdAt: 'uploaded_at', // Map createdAt to uploaded_at
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Document;
};

================
File: backend/models/event.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Event extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Event.belongsTo(models.User, {
        foreignKey: 'created_by',
        as: 'creator',
        onDelete: 'SET NULL', // If user is deleted, event's creator is set to null
      });
    }
  }
  Event.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false
    },
    description: {
      type: DataTypes.TEXT
    },
    start_date: {
      type: DataTypes.DATE,
      allowNull: false
    },
    end_date: {
      type: DataTypes.DATE,
      allowNull: false
    },
    location: {
      type: DataTypes.STRING,
      allowNull: false
    },
    created_by: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if creator user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    }
  }, {
    sequelize,
    modelName: 'Event',
    tableName: 'events',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Event;
};

================
File: backend/models/index.js
================
'use strict';

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../config/config.json')[env];
const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(config.database, config.username, config.password, config);
}

fs
  .readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 &&
      file !== basename &&
      file.slice(-3) === '.js' &&
      file.indexOf('.test.js') === -1
    );
  })
  .forEach(file => {
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;

================
File: backend/models/user.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class User extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      User.hasMany(models.Event, { foreignKey: 'created_by', as: 'events' });
      User.hasMany(models.Document, { foreignKey: 'uploaded_by', as: 'documents' });
      User.hasMany(models.Discussion, { foreignKey: 'user_id', as: 'discussions' });
      User.hasMany(models.Announcement, { foreignKey: 'created_by', as: 'announcements' });
      User.hasMany(models.AuditLog, { foreignKey: 'admin_id', as: 'auditLogs' });
      User.hasMany(models.VerificationToken, { foreignKey: 'user_id', as: 'verificationTokens' });
    }
  }
  User.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false
    },
    role: {
      type: DataTypes.STRING,
      allowNull: false,
      defaultValue: 'member'
    },
    status: {
      type: DataTypes.STRING,
      allowNull: false,
      defaultValue: 'pending'
    },
    email_verified: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    is_system_user: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    }
  }, {
    sequelize,
    modelName: 'User',
    tableName: 'users', // Explicitly define table name
    timestamps: true, // Enables createdAt and updatedAt
    createdAt: 'created_at', // Map createdAt to created_at
    updatedAt: 'updated_at' // Map updatedAt to updated_at (if needed, or set to false)
  });
  return User;
};

================
File: backend/models/verificationToken.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class VerificationToken extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      VerificationToken.belongsTo(models.User, {
        foreignKey: 'user_id',
        as: 'user',
        onDelete: 'CASCADE', // If a user is deleted, their tokens are also deleted
      });
    }
  }
  VerificationToken.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    user_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'users', // Name of the target table
        key: 'id'
      }
    },
    token: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    type: {
      type: DataTypes.STRING, // e.g., 'email_verification', 'password_reset'
      allowNull: false
    },
    expires_at: {
      type: DataTypes.DATE,
      allowNull: false
    }
  }, {
    sequelize,
    modelName: 'VerificationToken',
    tableName: 'verification_tokens',
    timestamps: true, // Enables createdAt and updatedAt
    createdAt: 'created_at', // Map createdAt to created_at
    updatedAt: false // No updatedAt for verification tokens
  });
  return VerificationToken;
};

================
File: backend/seeders/20250531214351-initial-admin-user.js
================
'use strict';
const bcrypt = require('bcrypt');

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    const adminEmail = process.env.ADMIN_EMAIL || 'admin@example.com';
    const adminPassword = process.env.ADMIN_PASSWORD || 'password123'; // Fallback for local dev if not set

    if (!process.env.ADMIN_EMAIL || !process.env.ADMIN_PASSWORD) {
      console.warn('ADMIN_EMAIL or ADMIN_PASSWORD environment variables not set. Using default credentials for seeder.');
    }

    const hashedPassword = await bcrypt.hash(adminPassword, 10);

    const existingAdmin = await queryInterface.rawSelect('users', {
      where: { email: adminEmail },
    }, ['id']);

    if (!existingAdmin) {
      await queryInterface.bulkInsert('users', [{
        name: 'System Administrator',
        email: adminEmail,
        password: hashedPassword,
        role: 'admin',
        status: 'approved',
        email_verified: true, // Admin email is considered verified
        is_system_user: true,
        created_at: new Date(),
        updated_at: new Date()
      }], {});
    } else {
      console.log(`Admin user with email ${adminEmail} already exists. Skipping admin user seed.`);
    }
  },

  async down (queryInterface, Sequelize) {
    const adminEmail = process.env.ADMIN_EMAIL || 'admin@example.com';
    await queryInterface.bulkDelete('users', { email: adminEmail }, {});
  }
};

================
File: backend/seeders/20250531214406-initial-site-config.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    const configs = [
      { key: 'hoa_name', value: process.env.DEFAULT_HOA_NAME || 'Sanderson Creek HOA' },
      { key: 'hoa_description', value: process.env.DEFAULT_HOA_DESCRIPTION || 'Sanderson Creek HOA Community Management System' },
      { key: 'hoa_logo', value: process.env.DEFAULT_HOA_LOGO || '/images/logo.png' }
    ];

    for (const config of configs) {
      const existingConfig = await queryInterface.rawSelect('config', {
        where: { key: config.key },
      }, ['key']);

      if (!existingConfig) {
        await queryInterface.bulkInsert('config', [config], {});
      } else {
        // Optionally update if it exists, or just skip
        console.log(`Config key ${config.key} already exists. Skipping config seed for this key.`);
        // await queryInterface.bulkUpdate('config', { value: config.value }, { key: config.key });
      }
    }
  },

  async down (queryInterface, Sequelize) {
    const configKeys = ['hoa_name', 'hoa_description', 'hoa_logo'];
    await queryInterface.bulkDelete('config', { key: { [Sequelize.Op.in]: configKeys } }, {});
  }
};

================
File: backend/src/controllers/admin.user.controller.js
================
const userService = require('../services/user.service');
const { updateUserStatusSchema, updateUserRoleSchema, changePasswordSchema } = require('../validators/admin.user.validator');

/**
 * Handles listing all non-system users for admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function listUsers(req, res, next) {
  try {
    const { limit, offset } = req.query; // For pagination
    const result = await userService.listNonSystemUsers({ limit, offset });
    // Transform response to match frontend expectations: { users, count }
    return res.status(200).json({
      users: result.rows,
      count: result.count
    });
  } catch (err) {
    next(err);
  }
}

/**
 * Handles retrieving a specific non-system user by ID for admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function getUserById(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const user = await userService.getNonSystemUserById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found or is a system user.' });
    }
    return res.status(200).json(user);
  } catch (err) {
    next(err);
  }
}

/**
 * Handles updating a user's status by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function updateUserStatus(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const { error, value } = updateUserStatusSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    const updatedUser = await userService.updateUserStatus(userId, value.status, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json(updatedUser);

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles updating a user's role by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function updateUserRole(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const { error, value } = updateUserRoleSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    const updatedUser = await userService.updateUserRole(userId, value.role, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json(updatedUser);

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles deleting a user by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function deleteUser(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    await userService.deleteUser(userId, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json({ message: 'User and associated data deleted successfully.' });
    // Or return res.status(204).send(); for No Content response

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles changing a user's password by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function changeUserPasswordByAdmin(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const { error, value } = changePasswordSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    await userService.changeUserPasswordByAdmin(userId, value.newPassword, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json({ message: 'User password changed successfully.' });

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

module.exports = {
  listUsers,
  getUserById,
  updateUserStatus,
  updateUserRole,
  deleteUser,
  changeUserPasswordByAdmin,
};

================
File: backend/src/controllers/announcement.controller.js
================
const announcementService = require('../services/announcement.service.js');

/**
 * Handles the creation of a new announcement.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function createAnnouncement(req, res, next) {
  try {
    const announcementData = req.body; // Contains title, content, expiresAt (optional)
    const userId = req.user.id; // Assuming auth middleware sets req.user

    const newAnnouncement = await announcementService.createAnnouncement(announcementData, userId);

    res.status(201).json(newAnnouncement);
  } catch (error) {
    next(error); // Pass error to centralized error handler
  }
}

/**
 * Handles listing announcements with pagination, filtering, and sorting.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function listAnnouncements(req, res, next) {
  try {
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const status = req.query.status || 'active';
    const sortBy = req.query.sortBy || 'created_at';
    const sortOrder = req.query.sortOrder || 'DESC';

    if (page <= 0) {
      return res.status(400).json({ message: 'Page must be a positive integer.' });
    }
    if (limit <= 0) {
      return res.status(400).json({ message: 'Limit must be a positive integer.' });
    }

    const allowedSortOrders = ['ASC', 'DESC'];
    if (!allowedSortOrders.includes(sortOrder.toUpperCase())) {
      return res.status(400).json({ message: `sortOrder must be one of: ${allowedSortOrders.join(', ')}` });
    }
    // TODO: Add validation for allowed values of status and sortBy if specified in plan
    // Example: const allowedSortByFields = ['createdAt', 'title', 'expires_at'];
    // if (!allowedSortByFields.includes(sortBy)) {
    //   return res.status(400).json({ message: `sortBy must be one of: ${allowedSortByFields.join(', ')}` });
    // }

    const options = { page, limit, status, sortBy, sortOrder };

    const result = await announcementService.listAnnouncements(options);
    // Ensure the controller correctly uses the key returned by the service.
    // If the service now returns data, the controller should reflect that
    // when constructing the response.
    res.status(200).json({
      data: result.data,
      pagination: {
        totalItems: result.totalItems,
        totalPages: result.totalPages,
        currentPage: result.currentPage,
        limit: result.limit,
      }
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Handles updating an existing announcement.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function updateAnnouncement(req, res, next) {
  try {
    const { id: announcementId } = req.params;
    const updateData = req.body; // Contains optional title, content, expires_at
    const adminUserId = req.user.id; // Assuming auth middleware sets req.user

    // Input validation for req.body is handled by Joi middleware via routes
    // Sanitization for content (if HTML) would be here or in service. Assuming plain text.

    const updatedAnnouncement = await announcementService.updateAnnouncement(announcementId, updateData, adminUserId);
    res.status(200).json(updatedAnnouncement);
  } catch (error) {
    if (error.statusCode === 404) {
      return res.status(404).json({ message: error.message });
    }
    // For other errors, including potential validation errors from service if not caught by Joi
    // or other DB errors.
    // The technical spec mentions 400 for validation errors, but Joi middleware handles that before this controller.
    // If service layer throws a validation error (e.g. invalid date format not caught by Joi),
    // it might not have a statusCode.
    // For simplicity, passing to generic error handler which might result in 500.
    // A more robust error handling might map specific error types to 400 here.
    next(error);
  }
}

/**
 * Handles deleting an announcement.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function deleteAnnouncement(req, res, next) {
  try {
    const { id: announcementId } = req.params;
    const adminUserId = req.user.id; // Assuming auth middleware sets req.user

    await announcementService.deleteAnnouncement(announcementId, adminUserId);
    res.status(204).send(); // No content to send back
  } catch (error) {
    if (error.statusCode === 404) {
      return res.status(404).json({ message: error.message });
    }
    next(error); // Pass to generic error handler
  }
}

module.exports = {
  createAnnouncement,
  listAnnouncements,
  updateAnnouncement,
  deleteAnnouncement,
};

================
File: backend/src/controllers/audit.controller.js
================
'use strict';

const auditService = require('../services/audit.service');

async function getAuditLogsController(req, res, next) {
  try {
    // FIX: Provide default values for page and limit using '||'
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    
    const result = await auditService.getAuditLogs({ page, limit });
    res.status(200).json(result);
  } catch (error) {
    next(error);
  }
}

module.exports = {
  getAuditLogsController,
};

================
File: backend/src/controllers/auth.controller.js
================
const authService = require('../services/auth.service');
const { registerSchema, loginSchema, forgotPasswordSchema, resetPasswordSchema } = require('../validators/auth.validator');

/**
 * Handles user registration.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function register(req, res, next) {
  try {
    // Validate request body
    const { error, value } = registerSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    // Call registration service
    const user = await authService.registerUser(value);

    // Send response
    return res.status(201).json({
      message: 'Registration successful. Your account is pending approval.',
      user // Excludes password as handled by service
    });

  } catch (err) {
    // Handle errors from service (e.g., email conflict) or other unexpected errors
    if (err.statusCode) {
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Pass to a generic error handler if one is set up
    next(err); 
  }
}

/**
 * Handles user login.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function login(req, res, next) {
  try {
    // Validate request body
    const { error, value } = loginSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    // Call login service
    const { token, user } = await authService.loginUser(value);

    // Send response
    return res.status(200).json({
      message: 'Login successful.',
      token,
      user // Excludes password as handled by service
    });

  } catch (err) {
    // Handle errors from service (e.g., invalid credentials, account not approved)
    if (err.statusCode) {
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Pass to a generic error handler
    next(err);
  }
}

/**
 * Handles forgot password request.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function forgotPassword(req, res, next) {
  try {
    const { error, value } = forgotPasswordSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        // error: 'Invalid email format.' // More specific as per requirements
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    await authService.requestPasswordReset(value.email);

    return res.status(200).json({
      message: 'Password reset email sent. Please check your inbox.'
    });

  } catch (err) {
    if (err.statusCode) {
      // Specific error messages based on service layer logic
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Default error for invalid email format if not caught by Joi (though Joi should catch it)
    if (err.message.toLowerCase().includes('email')) { // Basic check
        return res.status(400).json({ error: 'Invalid email format.' });
    }
    next(err);
  }
}

/**
 * Handles verification of a password reset token.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function verifyResetToken(req, res, next) {
  try {
    const { token } = req.query;

    if (!token) {
        return res.status(400).json({ error: 'Invalid or expired password reset token.' });
    }

    await authService.verifyPasswordResetToken(token);

    return res.status(200).json({ message: 'Token is valid.' });

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Default error for token issues
    return res.status(400).json({ error: 'Invalid or expired password reset token.' });
    // next(err); // Or pass to generic error handler
  }
}

/**
 * Handles resetting a user's password.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function resetPassword(req, res, next) {
  try {
    const { error, value } = resetPasswordSchema.validate(req.body);
    if (error) {
      // Check for password complexity error specifically
      if (error.details.some(d => d.path.includes('newPassword') && d.type === 'string.pattern.base')) {
        return res.status(400).json({
          error: "Password does not meet complexity requirements. Minimum 8 characters, including uppercase, lowercase, number, and special character."
        });
      }
      // Generic validation error for missing fields or other issues
      return res.status(400).json({
        error: error.details.map(d => d.message).join(', ') || "Token and newPassword are required."
      });
    }

    await authService.resetPassword(value.token, value.newPassword);

    return res.status(200).json({ message: 'Password has been reset successfully.' });

  } catch (err) {
    if (err.statusCode) {
      // Specific error messages from service layer (e.g., invalid token)
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Default error for other issues
    // Log the error for debugging if it's unexpected
    console.error('Unexpected error in resetPassword controller:', err);
    return res.status(500).json({ error: 'An unexpected error occurred.' });
    // next(err); // Or pass to generic error handler
  }
}

module.exports = {
  register,
  login,
  forgotPassword,
  verifyResetToken,
  resetPassword,
};

================
File: backend/src/controllers/config.controller.js
================
const configService = require('../services/config.service');
const ApiError = require('../utils/ApiError'); // Assuming ApiError utility for error handling

const getAllConfigsController = async (req, res, next) => {
  try {
    const configs = await configService.getAllConfigs();
    res.status(200).json(configs);
  } catch (error) {
    // Assuming a centralized error handler or ApiError can be caught by it
    next(error instanceof ApiError ? error : new ApiError(500, 'Failed to retrieve configurations'));
  }
};

const updateConfigController = async (req, res, next) => {
  try {
    const { key } = req.params;
    const { value } = req.body;
    const adminUserId = req.user.id; // Assuming verifyToken and isAdmin middlewares populate req.user

    if (!adminUserId) {
        // This check is more for robustness, as isAdmin should ensure req.user.id exists
        return next(new ApiError(403, 'User ID not found, authorization issue.'));
    }

    const updatedConfig = await configService.upsertConfig(key, value, adminUserId);
    res.status(200).json(updatedConfig);
  } catch (error) {
    next(error instanceof ApiError ? error : new ApiError(500, `Failed to update configuration for key: ${req.params.key}`));
  }
};

module.exports = {
  getAllConfigsController,
  updateConfigController,
};

================
File: backend/src/controllers/discussion.controller.js
================
const httpStatus = require('http-status');
const discussionService = require('../services/discussion.service');
const catchAsync = require('../utils/catchAsync'); // Assuming catchAsync utility for error handling

const createThreadController = catchAsync(async (req, res) => {
  const { title, content } = req.body;
  const userId = req.user.id;
  const thread = await discussionService.createThread({ title, content }, userId);
  res.status(httpStatus.CREATED).send(thread);
});

const createReplyController = catchAsync(async (req, res) => {
  const { threadId } = req.params;
  const { content } = req.body;
  const userId = req.user.id;
  const reply = await discussionService.createReply({ content }, threadId, userId);
  res.status(httpStatus.CREATED).send(reply);
});

const listThreadsController = catchAsync(async (req, res) => {
  const { page, limit } = req.query;
  const threads = await discussionService.listThreads({ page, limit });
  res.send(threads);
});

const viewThreadController = catchAsync(async (req, res) => {
  const { threadId } = req.params;
  const thread = await discussionService.viewThread(threadId);
  if (!thread) {
    return res.status(httpStatus.NOT_FOUND).send({ message: 'Thread not found or is not a main thread' });
  }
  res.send(thread);
});

const deleteThreadController = catchAsync(async (req, res) => {
  const { threadId } = req.params;
  const adminUserId = req.user.id;
  await discussionService.deleteThread(threadId, adminUserId);
  res.status(httpStatus.NO_CONTENT).send();
});

const deleteReplyController = catchAsync(async (req, res) => {
  const { replyId } = req.params;
  const adminUserId = req.user.id;
  await discussionService.deleteReply(replyId, adminUserId);
  res.status(httpStatus.NO_CONTENT).send();
});

module.exports = {
  createThreadController,
  createReplyController,
  listThreadsController,
  viewThreadController,
  deleteThreadController,
  deleteReplyController,
};

================
File: backend/src/controllers/document.controller.js
================
const documentService = require('../services/document.service');
const { uploadDocumentSchema } = require('../validators/document.validator');
const multer = require('multer'); // To handle Multer errors specifically

/**
 * Handles document upload by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function uploadDocument(req, res, next) {
  try {
    // File is already handled by multer middleware if this controller is reached
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded or file type not allowed.' });
    }

    // Validate text fields
    const { error, value } = uploadDocumentSchema.validate(req.body);
    if (error) {
      // If validation fails, and a file was uploaded, it's good practice to remove the orphaned file.
      // However, fs.unlink can be complex here due to async nature and error paths.
      // For simplicity, this example doesn't remove orphaned files on validation error.
      // In a production app, consider a cleanup strategy.
      return res.status(400).json({
        message: 'Validation failed for document metadata.',
        errors: error.details.map(d => d.message)
      });
    }

    const documentData = {
      title: value.title,
      description: value.description,
      originalFileName: req.file.originalname, // Available if needed
      storedFileName: req.file.filename,    // Name generated by Multer
      filePath: req.file.path,              // Full path where Multer stored the file
      uploadedBy: req.user.id,              // Assuming req.user is populated by auth middleware
      isPublic: value.is_public,
    };

    const newDocument = await documentService.createDocument(documentData);

    return res.status(201).json({
      message: 'Document uploaded successfully.',
      document: newDocument
    });

  } catch (err) {
    // Handle Multer-specific errors (like file size limit)
    if (err instanceof multer.MulterError) {
      if (err.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({ message: `File too large. Max size is ${process.env.MAX_FILE_SIZE_MB || 10}MB.` });
      }
      return res.status(400).json({ message: `File upload error: ${err.message}` });
    }
    // Handle other errors
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles listing documents for users/admins.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function listDocuments(req, res, next) {
  try {
    const { limit, offset } = req.query;
    // req.user might be undefined if the route is public and token is not provided
    const result = await documentService.listDocuments(req.user, { limit, offset });
    return res.status(200).json(result);
  } catch (err) {
    next(err);
  }
}

/**
 * Handles retrieving a specific document's metadata.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function getDocumentMetadata(req, res, next) {
  try {
    const documentId = parseInt(req.params.documentId, 10);
    if (isNaN(documentId)) {
      return res.status(400).json({ error: 'Invalid document ID format.' });
    }

    const document = await documentService.getDocumentMetadataById(documentId, req.user);
    // The service now throws specific errors, so a !document check is less likely here
    // unless the service is changed to return null for some cases again.
    // For now, we rely on the catch block.
    return res.status(200).json(document);
  } catch (err) {
    if (err.statusCode) {
      // Use 'error' key as requested
      return res.status(err.statusCode).json({ error: err.message });
    }
    next(err); // For unexpected errors
  }
}

/**
 * Handles downloading a specific document.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function downloadDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.documentId, 10);
    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    const document = await documentService.getDocumentForDownload(documentId, req.user);
    
    // The service throws an error if access is denied or document not found.
    // If we reach here, download is permitted.
    
    // Use res.download to trigger file download.
    // The 'file_name' from the DB should be the user-facing filename.
    // The 'file_path' from the DB is the actual path on the server.
    // Ensure file_path is secure and not subject to path traversal.
    // The documentService should ideally return the original filename if stored,
    // or use title as a fallback. For now, using document.file_name (stored unique name)
    // might not be user-friendly. Let's assume document.title is a good fallback.
    // The plan mentions: "assume file_name in DB is the user-facing filename for download."
    // This implies the original filename should be stored, perhaps in a field like `original_file_name`.
    // For now, using the stored `file_name` as the download name.
    
    // IMPORTANT: Ensure `document.file_path` is an absolute path or correctly resolved
    // to prevent security vulnerabilities. The Multer setup stores absolute paths.
    res.download(document.file_path, document.original_file_name, (err) => {
      if (err) {
        // Handle errors that occur after headers have been sent, like network issues
        // or if the file is missing (though getDocumentForDownload should catch this)
        console.error('Error during file download:', err);
        if (!res.headersSent) {
          return res.status(500).json({ message: 'Could not download the file.' });
        }
      }
    });

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles approving a document by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function adminApproveDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.id, 10);
    const adminUserId = req.user.id; // Assuming verifyToken middleware sets req.user

    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    const updatedDocument = await documentService.approveDocumentById(documentId, adminUserId);
    return res.status(200).json(updatedDocument);
  } catch (err) {
    // Pass errors to the error handling middleware
    // Specific error handling (e.g., for not found or permission issues)
    // should ideally be done in the service layer and result in custom error objects
    // that the global error handler can interpret.
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles deleting a document by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function adminDeleteDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.id, 10);
    const adminUserId = req.user.id; // Assuming verifyToken middleware sets req.user

    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    await documentService.deleteDocumentById(documentId, adminUserId);
    return res.status(204).send();
  } catch (err) {
    // Pass errors to the error handling middleware
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}
module.exports = {
  uploadDocument,
  listDocuments,
  getDocumentMetadata,
  downloadDocument,
  adminApproveDocument,
  adminDeleteDocument,
};

================
File: backend/src/controllers/event.controller.js
================
const eventService = require('../services/event.service');

const listEvents = async (req, res, next) => {
  try {
    // Query parameters are already validated and sanitized by express-validator
    // and will be available in req.query
    const queryParams = req.query;

    const result = await eventService.getAllEvents(queryParams);

    res.status(200).json(result);
  } catch (error) {
    // Log the error for server-side inspection
    console.error('Error in listEvents controller:', error);

    // Check if the error is a known service layer error or a generic one
    if (error.message === 'Error fetching events from database.') {
      // Pass to a generic error handler or return a 500
      // For now, let's assume a generic error handler will catch it
      // or we can send a 500 directly.
      return res.status(500).json({ error: 'Internal Server Error' });
    }
    // For other types of errors, or if you want more specific error handling
    // you can add more checks here.
    
    // Fallback to a generic 500 error if not handled specifically
    // and not already sent by a more specific catch.
    // This next(error) will typically be caught by a global error handler in app.js
    next(error); 
  }
};

const adminUpdateEvent = async (req, res, next) => {
  try {
    const eventId = req.params.id;
    const updateData = req.body;
    const adminUserId = req.user.id; // Assuming JWT middleware adds user to req

    const updatedEvent = await eventService.updateEvent(eventId, updateData, adminUserId);
    res.status(200).json(updatedEvent);
  } catch (error) {
    console.error(`Error in adminUpdateEvent controller for event ${req.params.id}:`, error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({ error: error.message });
    }
    next(error); // Pass to global error handler
  }
};

const adminDeleteEvent = async (req, res, next) => {
  try {
    const eventId = req.params.id;
    const adminUserId = req.user.id; // Assuming JWT middleware adds user to req

    await eventService.deleteEvent(eventId, adminUserId);
    res.status(204).send();
  } catch (error) {
    console.error(`Error in adminDeleteEvent controller for event ${req.params.id}:`, error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({ error: error.message });
    }
    next(error); // Pass to global error handler
  }
};

const createEvent = async (req, res, next) => {
  try {
    const { title, description, event_date, location } = req.body;
    const adminUserId = req.user.id; // Assuming JWT middleware adds user to req

    const eventData = { title, description, event_date, location };
    const newEvent = await eventService.createEvent(eventData, adminUserId);

    res.status(201).json(newEvent);
  } catch (error) {
    console.error('Error in createEvent controller:', error);
    // If the service layer threw an error with a statusCode, use it
    if (error.statusCode) {
      // Construct a more informative error response if service provides details
      const errorResponse = { error: error.message };
      if (error.errors) { // For validation errors from service
        errorResponse.details = error.errors;
      }
      return res.status(error.statusCode).json(errorResponse);
    }
    // Pass to global error handler for unhandled/generic errors
    next(error);
  }
};

module.exports = {
  listEvents,
  adminUpdateEvent,
  adminDeleteEvent,
  createEvent,
};

================
File: backend/src/controllers/user.controller.js
================
const userService = require('../services/user.service');
const { validationResult } = require('express-validator');

/**
 * Controller to get the authenticated user's own profile.
 */
const getOwnProfile = async (req, res, next) => {
    // This function doesn't change, but we add 'next' for consistency
    try {
        const userProfile = await userService.fetchOwnProfile(req.user.id);
        if (!userProfile) {
            return res.status(404).json({ error: 'User profile not found.' });
        }
        res.status(200).json(userProfile);
    } catch (error) {
        next(error);
    }
};

/**
 * Controller to update the authenticated user's own profile.
 */
const updateOwnProfile = async (req, res, next) => {
  try {
    // The validation is already done by the middleware!
    const updatedUserProfile = await userService.modifyOwnProfile(req.user.id, req.body);
    res.status(200).json(updatedUserProfile);
  } catch (error) {
    next(error);
  }
};

/**
 * Controller to change the authenticated user's own password.
 */
const changeOwnPassword = async (req, res, next) => {
  try {
    // The validation is already done! We just call the service.
    const { currentPassword, newPassword } = req.body;
    await userService.updateOwnPassword(req.user.id, currentPassword, newPassword);
    res.status(200).json({ message: 'Password changed successfully.' });
  } catch (error) {
    // The service throws an error with a statusCode, which we pass to the global handler
    next(error);
  }
};

module.exports = {
  getOwnProfile,
  updateOwnProfile,
  changeOwnPassword,
};

================
File: backend/src/middlewares/auth.middleware.js
================
const jwt = require('jsonwebtoken');
const { User } = require('../../models'); // Adjust path if models are not in root/models

/**
 * Middleware to verify JWT token from Authorization header.
 * Attaches user information to req.user if token is valid.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function verifyToken(req, res, next) {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Access token is required.' });
  }

  const token = authHeader.split(' ')[1];

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Optionally, fetch user from DB to ensure they still exist and are active
    // This adds a DB hit but increases security. For this example, we'll trust the token payload.
    // const user = await User.findByPk(decoded.userId);
    // if (!user || user.status !== 'approved') {
    //   return res.status(401).json({ message: 'Invalid token or user not active.' });
    // }

    req.user = {
      id: decoded.userId, // Ensure this matches the payload key (userId or id)
      role: decoded.role,
      // Add other non-sensitive user details from token if needed
    };
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'Token expired.' });
    }
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ error: 'Invalid token.' });
    }
    // For other errors, pass to generic error handler
    console.error('JWT verification error:', error);
    return res.status(403).json({ message: 'Forbidden: Token verification failed.' });
  }
}

/**
 * Middleware factory to authorize users based on roles.
 * @param  {...string} allowedRoles - List of roles allowed to access the route.
 * @returns {function} Express middleware function.
 */
function authorizeRoles(...allowedRoles) {
  return (req, res, next) => {
    if (!req.user || !req.user.role) {
      // This should ideally not happen if verifyToken runs first and sets req.user
      return res.status(403).json({ message: 'Forbidden: User role not available.' });
    }

    const rolesArray = [...allowedRoles];
    if (!rolesArray.includes(req.user.role)) {
      return res.status(403).json({ message: 'Forbidden: You do not have permission to access this resource.' });
    }
    next();
  };
}

/**
 * Middleware to optionally verify JWT token.
 * If a token is provided and valid, req.user is populated.
 * If no token or an invalid token is provided, it proceeds without error, and req.user remains undefined.
 * This is useful for routes that behave differently for guests vs. authenticated users.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function optionalAuth(req, res, next) {
  const authHeader = req.headers.authorization;

  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.split(' ')[1];
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = {
        id: decoded.userId,
        role: decoded.role,
      };
    } catch (error) {
      // Invalid token, but we don't block the request, just don't set req.user
      console.warn('Optional auth: Invalid token received, proceeding as guest.', error.name);
    }
  }
  next();
}

module.exports = {
  verifyToken,
  authorizeRoles,
  optionalAuth,
};

================
File: backend/src/middlewares/upload.middleware.js
================
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Define allowed MIME types and a max file size
const ALLOWED_MIME_TYPES = [
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // .docx
  'image/jpeg',
  'image/png',
  'image/gif',
];
const MAX_FILE_SIZE_MB = 10;
const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;

// Ensure the upload directory exists
const uploadDir = path.join(__dirname, '../../uploads/documents'); // Relative to this file, goes up to backend/ then uploads/documents
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

// Multer disk storage configuration
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const extension = path.extname(file.originalname);
    cb(null, file.fieldname + '-' + uniqueSuffix + extension);
  }
});

// Multer file filter
const fileFilter = (req, file, cb) => {
  if (ALLOWED_MIME_TYPES.includes(file.mimetype)) {
    cb(null, true); // Accept file
  } else {
    // Create a proper error for file type rejection
    const error = new Error(`File type not allowed. Allowed types: ${ALLOWED_MIME_TYPES.join(', ')}. Received: ${file.mimetype}`);
    error.code = 'INVALID_FILE_TYPE';
    cb(error, false); // Reject file
  }
};

const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: MAX_FILE_SIZE_BYTES // 10 MB limit
  }
});

module.exports = upload;

================
File: backend/src/middlewares/validate.middleware.js
================
const Joi = require('joi');
const ApiError = require('../utils/ApiError'); // Assuming ApiError utility

const validate = (schema) => (req, res, next) => {
  const validSchema = Joi.compile(schema);
  const object = {};
  if (req.method === 'GET' || req.method === 'DELETE') {
    Object.assign(object, req.params, req.query);
  } else { // POST, PUT, PATCH
    Object.assign(object, req.params, req.query, req.body);
  }

  const { value, error } = validSchema.validate(object, {
    abortEarly: false, // return all errors
    allowUnknown: true, // allow properties not defined in schema
    stripUnknown: true, // remove properties not defined in schema
  });

  if (error) {
    const errorMessage = error.details.map((details) => details.message).join(', ');
    return next(new ApiError(400, errorMessage));
  }
  Object.assign(req, value); // Assign validated (and potentially transformed) data back to req
  return next();
};

module.exports = validate;

================
File: backend/src/routes/admin.user.routes.js
================
const express = require('express');
const adminUserController = require('../controllers/admin.user.controller');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware');

const router = express.Router();

// All routes in this file are protected and require admin role
router.use(verifyToken);
router.use(authorizeRoles('admin'));

/**
 * @swagger
 * /api/admin/users:
 *   get:
 *     summary: List all non-system users (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of users to return
 *       - in: query
 *         name: offset
 *         schema:
 *           type: integer
 *           default: 0
 *         description: Number of users to skip for pagination
 *     responses:
 *       200:
 *         description: A list of non-system users.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 count:
 *                   type: integer
 *                   example: 1
 *                 users:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/UserResponse' # Defined in auth.routes.js or a common place
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.get('/', adminUserController.listUsers);

/**
 * @swagger
 * /api/admin/users/{userId}:
 *   get:
 *     summary: Get a specific non-system user by ID (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user to retrieve
 *     responses:
 *       200:
 *         description: Details of the non-system user.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid user ID format
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Invalid user ID format.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       404:
 *         description: User not found or is a system user
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User not found or is a system user.
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.get('/:userId', adminUserController.getUserById);

/**
 * @swagger
 * /api/admin/users/{userId}/status:
 *   put:
 *     summary: Update a user's status (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user whose status is to be updated
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - status
 *             properties:
 *               status:
 *                 type: string
 *                 enum: [approved, pending, rejected]
 *                 example: approved
 *     responses:
 *       200:
 *         description: User status updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid user ID format or validation failed for status
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to update a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot modify system user status.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put('/:userId/status', adminUserController.updateUserStatus);

/**
 * @swagger
 * /api/admin/users/{userId}/role:
 *   put:
 *     summary: Update a user's role (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user whose role is to be updated
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - role
 *             properties:
 *               role:
 *                 type: string
 *                 enum: [admin, member]
 *                 example: admin
 *     responses:
 *       200:
 *         description: User role updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid user ID format or validation failed for role
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to update a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot modify system user role.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put('/:userId/role', adminUserController.updateUserRole);

/**
 * @swagger
 * /api/admin/users/{userId}:
 *   delete:
 *     summary: Delete a non-system user and their associated data (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user to delete
 *     responses:
 *       200:
 *         description: User and associated data deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User and associated data deleted successfully.
 *       204:
 *         description: User and associated data deleted successfully (No Content).
 *       400:
 *         description: Invalid user ID format
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to delete a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot delete system user.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.delete('/:userId', adminUserController.deleteUser);

/**
 * @swagger
 * /api/admin/users/{userId}/password:
 *   put:
 *     summary: Change a user's password (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user whose password is to be changed
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - newPassword
 *             properties:
 *               newPassword:
 *                 type: string
 *                 format: password
 *                 minLength: 8
 *                 example: newSecurePassword123
 *     responses:
 *       200:
 *         description: User password changed successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User password changed successfully.
 *       400:
 *         description: Invalid user ID format or validation failed for newPassword
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to change password for a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot change password for a system user.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put('/:userId/password', adminUserController.changeUserPasswordByAdmin);

module.exports = router;

================
File: backend/src/routes/announcement.routes.js
================
const express = require('express');
const router = express.Router();
const { verifyToken: authenticateToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin'); // Create isAdmin middleware
const { createAnnouncementSchema, updateAnnouncementSchema } = require('../validators/announcement.validator');
const announcementController = require('../controllers/announcement.controller'); // Or import specific function
const validate = require('../middlewares/validate.middleware'); // Import validate middleware

// POST / (will be /api/admin/announcements/ when mounted) - Create a new announcement
router.post(
  '/',
  authenticateToken,
  isAdmin,
  validate(createAnnouncementSchema), // Wrap schema with validate middleware
  announcementController.createAnnouncement // Ensure this matches your controller export
);

// GET / (will be /api/announcements/ when mounted) - List announcements for users
router.get(
  '/',
  authenticateToken, // Assuming authenticated users can list
  announcementController.listAnnouncements
);

module.exports = router;

// PUT /:id - Update an announcement (Admin only)
router.put(
  '/:id',
  authenticateToken,
  isAdmin,
  validate(updateAnnouncementSchema), // Wrap schema with validate middleware
  announcementController.updateAnnouncement
);

// DELETE /:id - Delete an announcement (Admin only)
router.delete(
  '/:id',
  authenticateToken,
  isAdmin,
  announcementController.deleteAnnouncement
);

================
File: backend/src/routes/audit.routes.js
================
'use strict';

const express = require('express');
const auditController = require('../controllers/audit.controller');
const validate = require('../middlewares/validate.middleware');
const { getAuditLogsSchema } = require('../validators/audit.validator');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin');

const router = express.Router();

router.get(
  '/',
  verifyToken,
  isAdmin,
  validate(getAuditLogsSchema),
  auditController.getAuditLogsController
);

module.exports = router;

================
File: backend/src/routes/auth.routes.js
================
const express = require('express');
const authController = require('../controllers/auth.controller');
const { registerSchema, loginSchema, forgotPasswordSchema, resetPasswordSchema } = require('../validators/auth.validator.js');
const validate = require('../middlewares/validate.middleware');

const router = express.Router();

/**
 * @swagger
 * /api/auth/register:
 *   post:
 *     summary: Register a new user
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - email
 *               - password
 *             properties:
 *               name:
 *                 type: string
 *                 example: John Doe
 *               email:
 *                 type: string
 *                 format: email
 *                 example: john.doe@example.com
 *               password:
 *                 type: string
 *                 format: password
 *                 minLength: 8
 *                 example: password123
 *     responses:
 *       201:
 *         description: Registration successful. Account pending approval.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Registration successful. Your account is pending approval.
 *                 user:
 *                   $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Validation failed
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorValidation'
 *       409:
 *         description: Email already registered
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorConflict'
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorServer'
 */
router.post('/register', validate(registerSchema), authController.register);

/**
 * @swagger
 * /api/auth/login:
 *   post:
 *     summary: Log in an existing user
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 example: john.doe@example.com
 *               password:
 *                 type: string
 *                 format: password
 *                 example: password123
 *     responses:
 *       200:
 *         description: Login successful
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Login successful.
 *                 token:
 *                   type: string
 *                   example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 *                 user:
 *                   $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Validation failed
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorValidation'
 *       401:
 *         description: Invalid email or password
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorUnauthorized'
 *       403:
 *         description: Account not approved or access denied
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorForbidden'
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorServer'
 */
router.post('/login', validate(loginSchema), authController.login);

/**
 * @swagger
 * /api/auth/forgot-password:
 *   post:
 *     summary: Request a password reset token
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 example: user@example.com
 *     responses:
 *       200:
 *         description: Password reset email sent.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Password reset email sent. Please check your inbox.
 *       400:
 *         description: Invalid email format or user account not active/eligible.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Invalid email format.
 *       404:
 *         description: Email not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Email not found.
 *       500:
 *         description: Internal server error
 */
router.post('/forgot-password', validate(forgotPasswordSchema), authController.forgotPassword);

/**
 * @swagger
 * /api/auth/verify-reset-token:
 *   get:
 *     summary: Verify a password reset token
 *     tags: [Auth]
 *     parameters:
 *       - in: query
 *         name: token
 *         schema:
 *           type: string
 *         required: true
 *         description: The password reset token.
 *         example: abc123xyz789
 *     responses:
 *       200:
 *         description: Token is valid.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Token is valid.
 *       400:
 *         description: Invalid or expired password reset token.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Invalid or expired password reset token.
 *       500:
 *         description: Internal server error
 */
router.get('/verify-reset-token', authController.verifyResetToken);

/**
 * @swagger
 * /api/auth/reset-password:
 *   post:
 *     summary: Reset user password with a token
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - token
 *               - newPassword
 *             properties:
 *               token:
 *                 type: string
 *                 example: "THE_GENERATED_TOKEN_FROM_EMAIL"
 *                 description: The password reset token received by the user.
 *               newPassword:
 *                 type: string
 *                 format: password
 *                 minLength: 8
 *                 example: "NewSecurePassword123!"
 *                 description: The new password for the user account. Must meet complexity requirements.
 *     responses:
 *       200:
 *         description: Password has been reset successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Password has been reset successfully.
 *       400:
 *         description: Bad Request - Invalid/expired token, password complexity not met, or missing fields.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   examples:
 *                     invalidToken: "Invalid or expired password reset token."
 *                     passwordComplexity: "Password does not meet complexity requirements. Minimum 8 characters, including uppercase, lowercase, number, and special character."
 *                     missingFields: "Token and newPassword are required."
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorServer'
 */
router.post('/reset-password', validate(resetPasswordSchema), authController.resetPassword);


// Placeholder for UserResponse schema (to be defined in Swagger setup)
// components:
//   schemas:
//     UserResponse:
//       type: object
//       properties:
//         id:
//           type: integer
//         name:
//           type: string
//         email:
//           type: string
//         role:
//           type: string
//         status:
//           type: string
//         email_verified:
//           type: boolean
//         is_system_user:
//           type: boolean
//         created_at:
//           type: string
//           format: date-time
//         updated_at:
//           type: string
//           format: date-time
//     ErrorValidation:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Validation failed.
//         errors:
//           type: array
//           items:
//             type: string
//           example: ["Name is required."]
//     ErrorConflict:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Email already registered.
//     ErrorUnauthorized:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Invalid email or password.
//     ErrorForbidden:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Account pending approval.
//     ErrorServer:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Internal server error

module.exports = router;

================
File: backend/src/routes/config.routes.js
================
const express = require('express');
const configController = require('../controllers/config.controller');
const validate = require('../middlewares/validate.middleware');
const { updateConfigSchema } = require('../validators/config.validator');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware'); // Assuming auth middlewares
const isAdmin = authorizeRoles('admin');

const router = express.Router();

// GET /api/admin/config - Get all configurations
router.get(
  '/',
  verifyToken,
  isAdmin,
  configController.getAllConfigsController
);

// PUT /api/admin/config/:key - Upsert a configuration key-value
router.put(
  '/:key',
  verifyToken,
  isAdmin,
  validate(updateConfigSchema),
  configController.updateConfigController
);

module.exports = router;

================
File: backend/src/routes/discussion.routes.js
================
const express = require('express');
const discussionController = require('../controllers/discussion.controller');
const validate = require('../middlewares/validate.middleware');
const { createThreadSchema, createReplySchema, listThreadsSchema } = require('../validators/discussion.validator');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin');

const router = express.Router();

router.post(
  '/',
  verifyToken,
  validate(createThreadSchema),
  discussionController.createThreadController
);

router.post(
  '/:threadId/replies',
  verifyToken,
  validate(createReplySchema),
  discussionController.createReplyController
);

// GET /api/discussions - List all main discussion threads
router.get(
  '/',
  verifyToken,
  validate(listThreadsSchema, 'query'), // Validate query parameters
  discussionController.listThreadsController
);

// GET /api/discussions/:threadId - View a specific thread with its replies
router.get(
  '/:threadId',
  verifyToken,
  discussionController.viewThreadController
);

// DELETE a discussion thread (Admin only)
router.delete(
  '/:threadId',
  verifyToken,
  isAdmin,
  discussionController.deleteThreadController
);

// DELETE a specific reply (Admin only)
router.delete(
  '/replies/:replyId',
  verifyToken,
  isAdmin,
  discussionController.deleteReplyController
);

module.exports = router;

================
File: backend/src/routes/document.routes.js
================
const express = require('express');
const documentController = require('../controllers/document.controller');
const { verifyToken, authorizeRoles, optionalAuth } = require('../middlewares/auth.middleware');
const upload = require('../middlewares/upload.middleware'); // Multer upload middleware
const multer = require('multer'); // Ensure multer is imported for error handling

const router = express.Router();

// --- Admin Document Routes ---

/**
 * @swagger
 * /api/admin/documents: // This path is for admin actions, distinct from public /api/documents
 *   post:
 *     summary: Upload a new document (Admin only)
 *     tags: [Documents Admin]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - documentFile
 *               - title
 *               - is_public
 *             properties:
 *               documentFile:
 *                 type: string
 *                 format: binary
 *                 description: The document file to upload.
 *               title:
 *                 type: string
 *                 example: Meeting Minutes Q1
 *               description:
 *                 type: string
 *                 example: Detailed minutes from the first quarter HOA meeting.
 *               is_public:
 *                 type: boolean
 *                 example: true
 *     responses:
 *       201:
 *         description: Document uploaded successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 document:
 *                   $ref: '#/components/schemas/DocumentResponse' # To be defined
 *       400:
 *         description: Validation failed, no file uploaded, file type not allowed, or file too large.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.post(
  '/',
  verifyToken,
  authorizeRoles('admin'),
  upload.single('documentFile'), // 'documentFile' is the field name in the form-data
  documentController.uploadDocument
);

// Other admin document routes (approve, delete) will be added here later.

/**
 * @swagger
 * /api/documents/{id}/approve:
 *   put:
 *     summary: Approve a document (Admin only)
 *     tags: [Documents Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the document to approve
 *     responses:
 *       200:
 *         description: Document approved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DocumentResponse'
 *       400:
 *         description: Invalid document ID format.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       404:
 *         description: Document not found.
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put(
  '/:id/approve',
  verifyToken,
  authorizeRoles('admin'),
  documentController.adminApproveDocument
);

/**
 * @swagger
 * /api/documents/{id}:
 *   delete:
 *     summary: Delete a document (Admin only)
 *     tags: [Documents Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the document to delete
 *     responses:
 *       204:
 *         description: Document deleted successfully.
 *       400:
 *         description: Invalid document ID format.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       404:
 *         description: Document not found.
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.delete(
  '/:id',
  verifyToken,
  authorizeRoles('admin'),
  documentController.adminDeleteDocument
);

router.use((err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_UNEXPECTED_FILE') {
      return res.status(400).json({ message: 'Unexpected field name in file upload.' });
    }
    // You can handle other multer errors here as well, e.g., file size limit
    if (err.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({ message: 'File is too large.' });
    }
    // For any other multer error.
    return res.status(400).json({ message: err.message });
  }
  
  // Handle custom file type validation errors
  if (err.code === 'INVALID_FILE_TYPE') {
    return res.status(400).json({ message: err.message });
  }
  
  // If the error is not a Multer error, pass it to the next (global) error handler.
  next(err);
});

module.exports = router;

================
File: backend/src/routes/event.routes.js
================
const express = require('express');
const router = express.Router();
const { verifyToken: authenticateToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin');
const { createEventSchema, listEventsSchema, adminUpdateEventSchema } = require('../validators/event.validator');
const validate = require('../middlewares/validate.middleware'); // Correct import for validate
const eventController = require('../controllers/event.controller');

// GET / (will be /api/events/ when mounted) - List events
router.get(
  '/',
  authenticateToken,
  validate(listEventsSchema), // Correctly wrap schema
  eventController.listEvents
);

// POST / (will be /api/events/ when mounted) - Create a new event (Admin only)
router.post(
  '/',
  authenticateToken,
  isAdmin,
  validate(createEventSchema), // Correctly wrap schema
  eventController.createEvent
);

// PUT /api/events/:id - Update an existing event (Admin only)
router.put(
  '/:id',
  authenticateToken,
  isAdmin,
  validate(adminUpdateEventSchema), // Correctly wrap schema
  eventController.adminUpdateEvent
);

// DELETE /api/events/:id - Delete an event (Admin only)
router.delete(
  '/:id',
  authenticateToken,
  isAdmin,
  eventController.adminDeleteEvent
);

module.exports = router;

================
File: backend/src/routes/public.document.routes.js
================
const express = require('express');
const documentController = require('../controllers/document.controller');
const { optionalAuth } = require('../middlewares/auth.middleware');

const router = express.Router();

// Middleware to make authentication optional for these routes
router.use(optionalAuth);

// GET /api/documents
router.get('/', documentController.listDocuments);

// GET /api/documents/:documentId
router.get('/:documentId', documentController.getDocumentMetadata);

// GET /api/documents/:documentId/download
router.get('/:documentId/download', documentController.downloadDocument);

module.exports = router;

================
File: backend/src/routes/user.routes.js
================
const express = require('express');
const router = express.Router();
const userController = require('../controllers/user.controller');
const authMiddleware = require('../middlewares/auth.middleware');
const validate = require('../middlewares/validate.middleware'); // Custom validation middleware
const { updateProfileSchema, changePasswordSchema } = require('../validators/user.validator');

// Route to get the authenticated user's own profile
// GET /api/users/me
router.get(
  '/me',
  authMiddleware.verifyToken, // Protects the route, ensures req.user is populated
  userController.getOwnProfile
);

// Route to update the authenticated user's own profile
// PUT /api/users/me
router.put(
  '/me',
  authMiddleware.verifyToken, // Protects the route
  validate(updateProfileSchema),        // Apply validation rules
  userController.updateOwnProfile
);

// Route to change the authenticated user's own password
// PUT /api/users/me/password
router.put(
  '/me/password',
  authMiddleware.verifyToken,    // Protects the route
  validate(changePasswordSchema),
  userController.changeOwnPassword
);

module.exports = router;

================
File: backend/src/services/announcement.service.js
================
const { Announcement, User, Sequelize } = require('../../models'); // Adjust path if models are not in root/models
const Op = Sequelize.Op; // Get Op from the Sequelize class/constructor
const createDOMPurify = require('dompurify');
const { JSDOM } = require('jsdom');
const auditService = require('./audit.service');

const window = new JSDOM('').window;
const DOMPurify = createDOMPurify(window);

/**
 * Creates a new announcement record in the database.
 * @param {object} announcementData - Data for the new announcement.
 * @param {string} announcementData.title - Title of the announcement.
 * @param {string} announcementData.content - Content of the announcement.
 * @param {string} [announcementData.expiresAt] - Optional expiration date in ISO format.
 * @param {number|string} userId - The ID of the admin user creating the announcement.
 * @returns {Promise<object>} The created announcement object.
 * @throws {Error} If there's an error during database interaction.
 */
async function createAnnouncement(announcementData, userId) {
  try {
    const { title, content, expiresAt } = announcementData;

    const sanitizedContent = DOMPurify.sanitize(content);

    const dataToCreate = {
      title,
      content: sanitizedContent,
      created_by: userId,
    };

    if (expiresAt) {
      dataToCreate.expires_at = expiresAt; // Assuming model field is expires_at
    }
    // Note: The announcement.model.js provided does not have an 'expires_at' field.
    // If it's intended to be stored, the model and migration need to be updated.
    // For now, this code includes it conditionally based on the task description.
    // If 'expiresAt' is not a field in the DB, Sequelize will ignore it or error depending on strictness.

    const newAnnouncement = await Announcement.create(dataToCreate);

    try {
      await auditService.logAdminAction(userId, 'announcement_create', { announcementId: newAnnouncement.id, title: newAnnouncement.title });
    } catch (auditError) {
      console.error('Failed to log admin action for announcement_create:', auditError);
    }

    return newAnnouncement.toJSON(); // Return plain JSON object
  } catch (error) {
    // Log the error for server-side debugging if necessary
    // console.error('Error creating announcement:', error);
    throw error; // Re-throw the error to be handled by the controller
  }
}

/**
 * Lists announcements with pagination, filtering, and sorting.
 * @param {object} options - Options for listing announcements.
 * @param {number} [options.page=1] - The current page number.
 * @param {number} [options.limit=10] - The number of items per page.
 * @param {string} [options.status] - Filter by status (e.g., 'active').
 * @param {string} [options.sortBy='createdAt'] - Field to sort by.
 * @param {string} [options.sortOrder='DESC'] - Sort order ('ASC' or 'DESC').
 * @returns {Promise<object>} An object containing the list of announcements and pagination details.
 * @throws {Error} If there's an error during database interaction.
 */
async function listAnnouncements(options) {
  try {
    const {
      page = 1,
      limit = 10,
      status,
      sortBy = 'createdAt', // Default sort field
      sortOrder = 'DESC', // Default sort order
    } = options;

    // Ensure page and limit are positive integers
    const numPage = parseInt(page, 10);
    const numLimit = parseInt(limit, 10);

    if (isNaN(numPage) || numPage < 1) {
      // Consider throwing a specific error type or handling as per project conventions
      throw new Error('Page number must be a positive integer.');
    }
    if (isNaN(numLimit) || numLimit < 1) {
      throw new Error('Limit must be a positive integer.');
    }

    const offset = (numPage - 1) * numLimit;
    const whereClause = {};

    if (status === 'active') {
      whereClause[Op.or] = [
        { expires_at: { [Op.is]: null } },
        { expires_at: { [Op.gt]: new Date() } },
      ];
    }

    // Validate sortOrder
    const validSortOrder = ['ASC', 'DESC'].includes(sortOrder.toUpperCase()) ? sortOrder.toUpperCase() : 'DESC';
    const orderClause = [[sortBy, validSortOrder]];

    const { count, rows } = await Announcement.findAndCountAll({
      where: whereClause,
      limit: numLimit,
      offset,
      order: orderClause,
      include: [{
        model: User,
        as: 'creator', // This alias must match the association in Announcement model
        attributes: ['id', 'name'], // Specify desired user fields
      }],
      distinct: true, // Important for correct count with include and limit
    });

    return {
      data: rows.map(row => row.toJSON()), // Return plain JSON objects
      totalItems: count,
      totalPages: Math.ceil(count / numLimit),
      currentPage: numPage,
      limit: numLimit,
    };
  } catch (error) {
    // Optional: Log error for server-side debugging
    // console.error('Error listing announcements:', error);
    throw error; // Re-throw the error to be handled by the controller/error middleware
  }
}

/**
 * Updates an existing announcement.
 * @param {number|string} announcementId - The ID of the announcement to update.
 * @param {object} updateData - Data to update the announcement with.
 * @param {string} [updateData.title] - New title for the announcement.
 * @param {string} [updateData.content] - New content for the announcement.
 * @param {string|null} [updateData.expires_at] - New expiration date (ISO format) or null to clear.
 * @param {number|string} adminUserId - The ID of the admin user performing the update.
 * @returns {Promise<object>} The updated announcement object.
 * @throws {Error} If announcement not found (statusCode 404) or other database error.
 */
async function updateAnnouncement(announcementId, updateData, adminUserId) {
  try {
    const announcement = await Announcement.findByPk(announcementId);

    if (!announcement) {
      const error = new Error('Announcement not found');
      error.statusCode = 404;
      throw error;
    }

    const updatedFields = [];
    if (updateData.hasOwnProperty('title') && updateData.title !== announcement.title) {
      announcement.title = updateData.title;
      updatedFields.push('title');
    }
    if (updateData.hasOwnProperty('content')) {
      const sanitizedNewContent = DOMPurify.sanitize(updateData.content);
      if (sanitizedNewContent !== announcement.content) {
        announcement.content = sanitizedNewContent;
        updatedFields.push('content');
      }
    }
    // For expires_at, handle explicit null to clear the date
    if (updateData.hasOwnProperty('expires_at') && updateData.expires_at !== announcement.expires_at) {
      // Ensure null is correctly handled if the current value is a date string or vice-versa
      if (updateData.expires_at === null && announcement.expires_at !== null) {
        announcement.expires_at = null;
        updatedFields.push('expires_at');
      } else if (updateData.expires_at !== null && new Date(updateData.expires_at).toISOString() !== (announcement.expires_at ? new Date(announcement.expires_at).toISOString() : null)) {
        announcement.expires_at = updateData.expires_at; // This can be null or a date string
        updatedFields.push('expires_at');
      }
    }

    if (updatedFields.length > 0) {
      await announcement.save();
      // Audit Log
      try {
        await auditService.logAdminAction(adminUserId, 'announcement_update', { announcementId, updatedFields: updatedFields });
      } catch (auditError) {
        console.error('Failed to log admin action for announcement_update:', auditError);
      }
    }

    return announcement.toJSON();
  } catch (error) {
    // console.error('Error updating announcement:', error);
    throw error;
  }
}

/**
 * Deletes an announcement by its ID.
 * @param {number|string} announcementId - The ID of the announcement to delete.
 * @param {number|string} adminUserId - The ID of the admin user performing the deletion.
 * @returns {Promise<boolean>} True if deletion was successful.
 * @throws {Error} If announcement not found (statusCode 404) or other database error.
 */
async function deleteAnnouncement(announcementId, adminUserId) {
  try {
    const announcement = await Announcement.findByPk(announcementId);

    if (!announcement) {
      const error = new Error('Announcement not found');
      error.statusCode = 404;
      throw error;
    }

    await announcement.destroy();
    // Audit Log
    try {
      await auditService.logAdminAction(adminUserId, 'announcement_delete', { announcementId });
    } catch (auditError) {
      console.error('Failed to log admin action for announcement_delete:', auditError);
    }
    return true; // Or return nothing for a 204 No Content response handling in controller
  } catch (error) {
    // console.error('Error deleting announcement:', error);
    throw error;
  }
}

module.exports = {
  createAnnouncement,
  listAnnouncements,
  updateAnnouncement,
  deleteAnnouncement,
};

================
File: backend/src/services/audit.service.js
================
'use strict';

const { AuditLog, User } = require('../../models'); // Adjust path as necessary if models/index.js is elsewhere
const { Op } = require('sequelize');

/**
 * Logs an administrative action to the audit_logs table.
 * @param {number} adminId - The ID of the admin user performing the action.
 * @param {string} action - A string describing the action (e.g., 'user_update', 'document_delete').
 * @param {object|string} [details] - Optional details about the action, can be an object or a pre-formatted string.
 */
async function logAdminAction(adminId, action, details) {
  try {
    let detailsToStore = details;
    if (details && typeof details === 'object') {
      // Assuming the 'details' column in the database is TEXT, we need to stringify.
      // If it's a JSON/JSONB type, stringification might not be needed or handled by Sequelize.
      detailsToStore = JSON.stringify(details);
    }

    await AuditLog.create({
      admin_id: adminId,
      action: action,
      details: detailsToStore,
      // created_at is handled by defaultValue in the model/database
    });
  } catch (error) {
    console.error('Failed to log admin action:', {
      adminId,
      action,
      details,
      error: error.message,
    });
    // Do not let audit logging failure block the main operation.
    // Depending on requirements, you might want to notify an admin or use a more robust logging system here.
  }
}

async function getAuditLogs(options) {
  const offset = (options.page - 1) * options.limit;

  const { count, rows } = await AuditLog.findAndCountAll({
    include: [{
      model: User,
      as: 'adminUser', // Ensure this alias matches the association in AuditLog model
      attributes: ['id', 'name'], // Select only needed user fields
    }],
    order: [['created_at', 'DESC']],
    limit: options.limit,
    offset: offset,
  });

  const formattedLogs = rows.map(log => {
    let parsedDetails = log.details;
    if (typeof log.details === 'string') {
      try {
        parsedDetails = JSON.parse(log.details);
      } catch (e) {
        // Keep as string if not valid JSON, or handle error
        // console.error('Failed to parse audit log details:', e);
      }
    }
    return {
      id: log.id,
      admin_name: log.adminUser ? log.adminUser.name : 'N/A',
      action: log.action,
      details: parsedDetails,
      created_at: log.created_at,
    };
  });

  const totalPages = Math.ceil(count / options.limit);

  return {
    data: formattedLogs,
    pagination: {
      totalItems: count,
      totalPages,
      currentPage: options.page,
      limit: options.limit,
    },
  };
}

module.exports = {
  logAdminAction,
  getAuditLogs,
};

================
File: backend/src/services/auth.service.js
================
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { User, VerificationToken } = require('../../models'); // Adjust path as necessary if models are not in root/models
const { v4: uuidv4 } = require('uuid');
const crypto = require('crypto'); // For a more secure plain token, though UUIDv4 is generally good.

/**
 * Registers a new user.
 * @param {object} userData - User data including name, email, and password.
 * @returns {Promise<object>} The created user object or throws an error.
 */
async function registerUser(userData) {
  const { name, email, password } = userData;

  // Check if email already exists
  const existingUser = await User.findOne({ where: { email } });
  if (existingUser) {
    const error = new Error('Email already registered.');
    error.statusCode = 409; // Conflict
    throw error;
  }

  // Hash password
  const hashedPassword = await bcrypt.hash(password, 10); // Salt rounds: 10

  // Create user
  // role defaults to 'member' and status to 'pending' as per model definition
  const newUser = await User.create({
    name,
    email,
    password: hashedPassword,
    // email_verified and is_system_user will use their default values from the model
  });

  // Exclude password from the returned user object
  const userJson = newUser.toJSON();
  delete userJson.password;
  return userJson;
}

/**
 * Logs in an existing user.
 * @param {object} loginData - User login data including email and password.
 * @returns {Promise<object>} An object containing the JWT and user details (excluding password).
 * @throws {Error} If authentication fails or account is not approved.
 */
async function loginUser(loginData) {
  const { email, password } = loginData;

  const user = await User.findOne({ where: { email } });
  if (!user) {
    const error = new Error('Invalid email or password.');
    error.statusCode = 401; // Unauthorized
    throw error;
  }

  const isPasswordValid = await bcrypt.compare(password, user.password);
  if (!isPasswordValid) {
    const error = new Error('Invalid email or password.');
    error.statusCode = 401; // Unauthorized
    throw error;
  }

  if (user.status !== 'approved') {
    let message = 'Account access denied.';
    if (user.status === 'pending') {
      message = 'Account pending approval.';
    } else if (user.status === 'rejected') {
      message = 'Your account has been rejected.';
    }
    const error = new Error(message);
    error.statusCode = 403; // Forbidden
    throw error;
  }

  // Generate JWT
  const tokenPayload = {
    userId: user.id,
    role: user.role,
  };

  const token = jwt.sign(tokenPayload, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || '1h', // Default to 1 hour
  });

  // Exclude password from the returned user object
  const userJson = user.toJSON();
  delete userJson.password;

  return {
    token,
    user: userJson,
  };
}

/**
 * Requests a password reset token for a user.
 * @param {string} email - The user's email address.
 * @returns {Promise<void>}
 * @throws {Error} If email is not found, user is not active, or other issues occur.
 */
async function requestPasswordReset(email) {
  const user = await User.findOne({ where: { email } });

  if (!user) {
    const error = new Error('Email not found.');
    error.statusCode = 404;
    throw error;
  }

  if (user.status !== 'approved') {
    const error = new Error('User account is not active or eligible for password reset.');
    error.statusCode = 400;
    throw error;
  }

  // Generate a unique token
  const plainToken = uuidv4(); // Or crypto.randomBytes(32).toString('hex');
  const hashedToken = await bcrypt.hash(plainToken, 10);

  // Set token expiry (e.g., 1 hour from now)
  const expiresAt = new Date();
  expiresAt.setHours(expiresAt.getHours() + 1);

  // Store the verification token
  await VerificationToken.create({
    userId: user.id,
    token: hashedToken,
    type: 'password_reset',
    expiresAt,
  });

  // Prepare email content (log instead of sending)
  const resetLink = `https://your-frontend-domain.com/reset-password?token=${plainToken}`;
  const emailContent = {
    to: user.email,
    subject: 'Password Reset Request',
    body: `
      <p>Hello ${user.name},</p>
      <p>You requested a password reset. Please click the link below to reset your password:</p>
      <p><a href="${resetLink}">${resetLink}</a></p>
      <p>This link will expire in 1 hour.</p>
      <p>If you did not request a password reset, please ignore this email.</p>
    `,
  };

  console.log('--- Password Reset Email ---');
  console.log(`Recipient: ${emailContent.to}`);
  console.log(`Subject: ${emailContent.subject}`);
  console.log(`Body: ${emailContent.body}`);
  console.log('-----------------------------');
}

/**
 * Verifies a password reset token.
 * @param {string} token - The password reset token from the query parameter.
 * @returns {Promise<boolean>} True if the token is valid.
 * @throws {Error} If the token is invalid, expired, or not found.
 */
async function verifyPasswordResetToken(token) {
  if (!token) {
    const error = new Error('Invalid or expired password reset token.');
    error.statusCode = 400; // Bad Request
    throw error;
  }

  // Find all non-expired password_reset tokens
  const potentialTokens = await VerificationToken.findAll({
    where: {
      type: 'password_reset',
      expiresAt: {
        [require('sequelize').Op.gt]: new Date(), // Check if expiresAt is greater than current time
      },
    },
    include: [{ model: User, attributes: ['id', 'email'] }], // Optional: include user for context
  });

  let isValidToken = false;
  let matchedUser = null;

  for (const vt of potentialTokens) {
    const isMatch = await bcrypt.compare(token, vt.token);
    if (isMatch) {
      isValidToken = true;
      matchedUser = vt.User; // Store user if needed for further steps (e.g. actual reset)
      // Optionally, delete the token after successful verification to prevent reuse
      // await vt.destroy();
      break;
    }
  }

  if (!isValidToken) {
    const error = new Error('Invalid or expired password reset token.');
    // Determine if 404 (not found) or 400 (bad request, e.g. expired)
    // For simplicity, using 400 for all invalid/expired cases here.
    error.statusCode = 400;
    throw error;
  }

  // If you need to return user details or a specific message:
  // return { message: "Token is valid.", userId: matchedUser.id };
  return true; // Or simply return true/false
}

/**
 * Resets a user's password using a valid token.
 * @param {string} token - The password reset token.
 * @param {string} newPassword - The new password.
 * @returns {Promise<void>}
 * @throws {Error} If token is invalid, password complexity fails, or other issues.
 */
async function resetPassword(token, newPassword) {
  if (!token || !newPassword) {
    const error = new Error('Token and newPassword are required.');
    error.statusCode = 400;
    throw error;
  }

  // Password complexity is handled by Joi validator, but can be double-checked here if desired.
  // For this implementation, we assume Joi validation has passed if this function is reached.

  // Find all non-expired password_reset tokens
  const potentialTokens = await VerificationToken.findAll({
    where: {
      type: 'password_reset',
      expiresAt: {
        [require('sequelize').Op.gt]: new Date(),
      },
    },
  });

  let validVerificationToken = null;
  for (const vt of potentialTokens) {
    const isMatch = await bcrypt.compare(token, vt.token);
    if (isMatch) {
      validVerificationToken = vt;
      break;
    }
  }

  if (!validVerificationToken) {
    const error = new Error('Invalid or expired password reset token.');
    error.statusCode = 400;
    throw error;
  }

  const user = await User.findByPk(validVerificationToken.userId);
  if (!user) {
    // This case should ideally not happen if token integrity is maintained
    const error = new Error('User associated with token not found.');
    error.statusCode = 500; // Internal server error, as this indicates data inconsistency
    throw error;
  }

  // Hash the new password
  const hashedPassword = await bcrypt.hash(newPassword, 10);

  // Update user's password
  user.password = hashedPassword;
  await user.save();

  // Invalidate/delete the token
  await validVerificationToken.destroy();

  // Log the event (basic console log for now)
  console.log(`Password reset successfully for user ID: ${user.id}`);

  // Optional: Invalidate other active sessions (future enhancement)
}


module.exports = {
  registerUser,
  loginUser,
  requestPasswordReset,
  verifyPasswordResetToken,
  resetPassword,
};

================
File: backend/src/services/config.service.js
================
const { Config } = require('../../models'); // Assuming index.js in models exports Config
const auditService = require('./audit.service');
// const ApiError = require('../utils/ApiError'); // Not strictly needed for this service based on current plan

const getAllConfigs = async () => {
  const configs = await Config.findAll();
  const configObject = {};
  configs.forEach(item => {
    configObject[item.key] = item.value;
  });
  return configObject;
};

const upsertConfig = async (key, value, adminUserId) => {
  const [configItem, created] = await Config.upsert({ key, value });
  // In Sequelize, 'upsert' might not return the instance directly in all dialects or versions.
  // It often returns [instance, created] or just a boolean indicating creation.
  // For simplicity and consistency, we'll return the input key/value.
  // If the actual instance data (like timestamps) is needed, a findOrCreate or separate find would be better.

  try {
    await auditService.logAdminAction(adminUserId, 'config_update', { configKey: key, newValue: value });
  } catch (auditError) {
    console.error('Failed to log admin action for config_update:', auditError);
  }
  
  // Return the data that was upserted, as the direct return from upsert can vary.
  return { key, value };
};

module.exports = {
  getAllConfigs,
  upsertConfig,
};

================
File: backend/src/services/discussion.service.js
================
const { Discussion, User, sequelize } = require('../../models'); // Assuming User model is in the same directory
const { Op, fn, col } = require('sequelize');
const createDOMPurify = require('dompurify');
const { JSDOM } = require('jsdom');
const ApiError = require('../utils/ApiError'); // Assuming ApiError utility
const auditService = require('./audit.service');

const window = new JSDOM('').window;
const DOMPurify = createDOMPurify(window);

/**
 * Create a discussion thread
 * @param {Object} threadData
 * @param {ObjectId} userId
 * @returns {Promise<Discussion>}
 */
const createThread = async (threadData, userId) => {
  const sanitizedContent = DOMPurify.sanitize(threadData.content);
  const thread = await Discussion.create({
    title: threadData.title,
    content: sanitizedContent,
    user_id: userId,
    parent_id: null,
  });
  return thread;
};

/**
 * Create a reply to a discussion thread
 * @param {Object} replyData
 * @param {ObjectId} threadId
 * @param {ObjectId} userId
 * @returns {Promise<Discussion>}
 */
const createReply = async (replyData, threadId, userId) => {
  const sanitizedContent = DOMPurify.sanitize(replyData.content);

  const parentThread = await Discussion.findOne({ where: { id: threadId, parent_id: null } });
  if (!parentThread) {
    throw new ApiError(404, 'Parent thread not found or is not a main thread');
  }

  const reply = await Discussion.create({
    content: sanitizedContent,
    user_id: userId,
    parent_id: threadId,
    title: null, // Replies don't have titles
  });
  return reply;
};

/**
 * List all main discussion threads with author and reply count
 * @param {Object} options - Query options
 * @param {number} [options.page=1] - Current page
 * @param {number} [options.limit=10] - Maximum number of results per page
 * @returns {Promise<Object>} - Paginated list of thread objects
 */
const listThreads = async (options) => {
  const page = parseInt(options.page, 10) || 1;
  const limit = parseInt(options.limit, 10) || 10;
  const offset = (page - 1) * limit;

  const { count, rows } = await Discussion.findAndCountAll({
    where: { parent_id: null },
    order: [['created_at', 'DESC']],
    limit,
    offset,
    include: [
      {
        model: User,
        as: 'author',
        attributes: ['id', 'name'],
      },
    ],
    attributes: {
      include: [
        [
          sequelize.literal(`(
            SELECT COUNT(*)
            FROM discussions AS reply
            WHERE
              reply.parent_id = Discussion.id
          )`),
          'reply_count'
        ]
      ]
    },
    distinct: true, // Important for correct count with includes
  });

  const threads = rows.map(thread => ({
    id: thread.id,
    title: thread.title,
    content: thread.content, // Consider snippet vs full content based on requirements
    created_at: thread.created_at,
    author: thread.author ? { id: thread.author.id, name: thread.author.name } : null,
    reply_count: parseInt(thread.get('reply_count'), 10) || 0,
  }));

  return {
    totalItems: count,
    totalPages: Math.ceil(count / limit),
    currentPage: page,
    threads,
  };
};

/**
 * View a specific thread along with all its replies
 * @param {ObjectId} threadId
 * @returns {Promise<Object|null>} - Thread object with replies, or null if not found
 */
const viewThread = async (threadId) => {
  const mainThread = await Discussion.findOne({
    where: { id: threadId, parent_id: null },
    include: [
      {
        model: User,
        as: 'author',
        attributes: ['id', 'name'],
      },
    ],
  });

  if (!mainThread) {
    return null; // Or throw ApiError(httpStatus.NOT_FOUND, 'Thread not found or is not a main thread');
  }

  const replies = await Discussion.findAll({
    where: { parent_id: threadId },
    order: [['created_at', 'ASC']],
    include: [
      {
        model: User,
        as: 'author',
        attributes: ['id', 'name'],
      },
    ],
  });

  return {
    mainThread: {
      id: mainThread.id,
      title: mainThread.title,
      content: mainThread.content,
      created_at: mainThread.created_at,
      author: mainThread.author ? { id: mainThread.author.id, name: mainThread.author.name } : null,
    },
    replies: replies.map(reply => ({
      id: reply.id,
      content: reply.content,
      created_at: reply.created_at,
      author: reply.author ? { id: reply.author.id, name: reply.author.name } : null,
    })),
  };
};


/**
 * Delete a discussion thread
 * @param {ObjectId} threadId
 * @param {ObjectId} adminUserId
 * @returns {Promise<void>}
 */
const deleteThread = async (threadId, adminUserId) => {
  const thread = await Discussion.findOne({ where: { id: threadId, parent_id: null } });
  if (!thread) {
    throw new ApiError(404, 'Discussion thread not found or is not a main thread');
  }
  const threadTitle = thread.title; // Store title before destroying
  await thread.destroy();
  // eslint-disable-next-line no-console
  // console.log(`Audit: Admin User ID ${adminUserId} deleted discussion thread ID ${threadId} titled '${thread.title}'`);
  try {
    await auditService.logAdminAction(adminUserId, 'discussion_thread_delete', { threadId, title: threadTitle });
  } catch (auditError) {
    console.error('Failed to log admin action for discussion_thread_delete:', auditError);
  }
};

/**
 * Delete a discussion reply
 * @param {ObjectId} replyId
 * @param {ObjectId} adminUserId
 * @returns {Promise<void>}
 */
const deleteReply = async (replyId, adminUserId) => {
  const reply = await Discussion.findOne({ where: { id: replyId, parent_id: { [Op.ne]: null } } });
  if (!reply) {
    throw new ApiError(404, 'Discussion reply not found or is not a reply');
  }
  await reply.destroy();
  // eslint-disable-next-line no-console
  // console.log(`Audit: Admin User ID ${adminUserId} deleted discussion reply ID ${replyId}`);
  try {
    await auditService.logAdminAction(adminUserId, 'discussion_reply_delete', { replyId });
  } catch (auditError) {
    console.error('Failed to log admin action for discussion_reply_delete:', auditError);
  }
};

module.exports = {
  createThread,
  createReply,
  listThreads,
  viewThread,
  deleteThread,
  deleteReply,
};

================
File: backend/src/services/document.service.js
================
const { Document, User, sequelize } = require('../../models'); // Adjust path if models are not in root/models
const { Op } = require('sequelize');
const fs = require('fs').promises;
const path = require('path');
const ApiError = require('../utils/ApiError');
const auditService = require('./audit.service');

/**
 * Creates a new document record in the database.
 * @param {object} documentData - Data for the new document.
 * @param {string} documentData.title - Title of the document.
 * @param {string} [documentData.description] - Optional description.
 * @param {string} documentData.originalFileName - The original name of the uploaded file (from Multer's `req.file.originalname`).
 * @param {string} documentData.storedFileName - The unique name of the file as stored on the server (from Multer's `req.file.filename`).
 * @param {string} documentData.filePath - The path to the file on the server.
 * @param {number} documentData.uploadedBy - The ID of the user who uploaded the document.
 * @param {boolean} documentData.isPublic - Whether the document is public.
 * @returns {Promise<object>} The created document object.
 */
async function createDocument(documentData) {
  const {
    title,
    description,
    originalFileName,
    storedFileName, // This is req.file.filename from Multer
    filePath,       // This is req.file.path from Multer
    uploadedBy,
    isPublic,
  } = documentData;

  // Determine 'approved' status based on 'is_public' as per plan
  const approved = !!isPublic; // Converts boolean isPublic to 0 or 1 if DB expects integer, or true/false

  const newDocument = await Document.create({
    title,
    description: description || null, // Ensure null if empty, or handle in model
    file_name: storedFileName, // This is the unique name for storage
    original_file_name: originalFileName, // Added to store the original filename
    file_path: filePath,       // Full path to the file on server
    uploaded_by: uploadedBy,
    is_public: isPublic,
    approved: approved,
    // uploaded_at will be set by Sequelize's `createdAt`
  });

  try {
    await auditService.logAdminAction(uploadedBy, 'document_upload', { documentId: newDocument.id, originalName: newDocument.original_file_name, uploaderUserId: uploadedBy });
  } catch (auditError) {
    console.error('Failed to log admin action for document_upload:', auditError);
  }

  return newDocument.toJSON(); // Return plain JSON object
}

/**
 * Lists documents based on user authentication and role.
 * @param {object} [user] - Optional user object (from req.user).
 * @param {object} options - Pagination options { limit, offset }.
 * @returns {Promise<object>} An object containing the list of documents and count.
 */
async function listDocuments(user, { limit = 10, offset = 0 }) {
  const whereClause = {};
  const includeClause = [{
    model: User,
    as: 'uploader',
    attributes: ['id', 'name'] // Only include uploader's ID and name
  }];

  if (!user) { // Guest user
    whereClause.is_public = true;
    whereClause.approved = true;
  } else if (user.role === 'admin') {
    // Admin sees all documents
  } else { // Authenticated member
    whereClause.approved = true;
    // Members see all approved documents (public and non-public)
  }

  const { count, rows } = await Document.findAndCountAll({
    where: whereClause,
    include: includeClause,
    limit: parseInt(limit, 10),
    offset: parseInt(offset, 10),
    order: [['uploaded_at', 'DESC']],
    attributes: { exclude: ['uploaded_by'] } // Exclude direct foreign key, use include for uploader info
  });

  return { count, documents: rows };
}

/**
 * Retrieves a specific document's metadata by ID, respecting access permissions.
 * @param {number} documentId - The ID of the document.
 * @param {object} [user] - Optional user object (from req.user).
 * @returns {Promise<object|null>} The document metadata or null if not found/not allowed.
 */
async function getDocumentMetadataById(documentId, user) {
  const document = await Document.findByPk(documentId, {
    include: [{
      model: User,
      as: 'uploader',
      attributes: ['id', 'name']
    }],
    attributes: { exclude: ['uploaded_by'] }
  });

  if (!document) {
    const error = new Error('Document not found.');
    error.statusCode = 404;
    throw error;
  }

  // Access Control
  if (!user) { // Guest
    if (!document.is_public || !document.approved) {
      const error = new Error('Access denied to this document.');
      error.statusCode = 403;
      throw error;
    }
  } else if (user.role !== 'admin') { // Member
    if (!document.approved) {
      const error = new Error('Access denied to this document.');
      error.statusCode = 403;
      throw error;
    }
    // Members can see all approved documents (public or not)
    // If a document is approved, a member can see it.
    // If it's also public, a guest can see it.
    // If it's not public but approved, only members and admins can see it.
    // This logic seems correct.
  }
  // Admin can see everything, no explicit check needed here if previous conditions handle others.

  return document.toJSON();
}

/**
 * Retrieves a document for download, checking permissions.
 * @param {number} documentId - The ID of the document.
 * @param {object} [user] - Optional user object (from req.user).
 * @returns {Promise<object|null>} The document object if download is permitted, otherwise null or throws error.
 * @throws {Error} If access is denied with a specific status code.
 */
async function getDocumentForDownload(documentId, user) {
  const document = await Document.findByPk(documentId);

  if (!document) {
    const error = new Error('Document not found.');
    error.statusCode = 404;
    throw error;
  }

  // Access Control based on download_document.php logic (User Story 9)
  // 1. If document approved != 1 AND user is not 'admin': Deny access (403).
  // 2. If document is_public != 1 AND user is not authenticated: Deny access (401/403).
  // 3. Otherwise, allow download.

  if (!document.approved && (!user || user.role !== 'admin')) {
    const error = new Error('Access Denied: Document not approved for download.');
    error.statusCode = 403;
    throw error;
  }

  if (!document.is_public && !user) {
    const error = new Error('Access Denied: Authentication required to download this document.');
    error.statusCode = 401; // Or 403, 401 is more specific for "auth required"
    throw error;
  }

  // If all checks pass, return the document object (contains file_path, file_name)
  return document.toJSON();
}


/**
 * Approves a document by its ID.
 * @param {number} documentId - The ID of the document to approve.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<object>} The updated document object.
 * @throws {ApiError} If the document is not found.
 */
async function approveDocumentById(documentId, adminUserId) {
  const document = await Document.findByPk(documentId);

  if (!document) {
    throw new ApiError(404, 'Document not found');
  }

  document.approved = true;
  await document.save();

  try {
    await auditService.logAdminAction(adminUserId, 'document_approve', { documentId });
  } catch (auditError) {
    console.error('Failed to log admin action for document_approve:', auditError);
  }

  return document.toJSON();
}

/**
 * Deletes a document by its ID.
 * This includes deleting the physical file if it exists.
 * @param {number} documentId - The ID of the document to delete.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<boolean>} True if deletion was successful.
 * @throws {ApiError} If the document is not found.
 */
async function deleteDocumentById(documentId, adminUserId) {
  const document = await Document.findByPk(documentId);

  if (!document) {
    throw new ApiError(404, 'Document not found');
  }

  if (document.file_path) {
    // document.file_path is expected to be an absolute path from Multer (req.file.path).
    try {
      await fs.unlink(document.file_path);
      console.log(`Successfully deleted physical file: ${document.file_path}`);
    } catch (err) {
      console.error(`Error deleting physical file ${document.file_path}: `, err);
      // Log error but proceed with DB deletion as per requirements.
    }
  }

  await document.destroy();
  try {
    await auditService.logAdminAction(adminUserId, 'document_delete', { documentId });
  } catch (auditError) {
    console.error('Failed to log admin action for document_delete:', auditError);
  }

  return true;
}


module.exports = {
  createDocument,
  listDocuments,
  getDocumentMetadataById,
  getDocumentForDownload,
  approveDocumentById,
  deleteDocumentById,
};

================
File: backend/src/services/event.service.js
================
const { Event, User, sequelize } = require('../../models');
const { Op } = require('sequelize');
const auditService = require('./audit.service');

const getAllEvents = async (queryParams) => {
  const {
    status = 'upcoming', // Default status
    page = 1,
    limit = 10,
    sortBy = 'event_date', // Default sort by event_date (which is start_date in model)
    sortOrder: initialSortOrder, // Will be determined based on sortBy and status
  } = queryParams;

  // Determine default sortOrder based on sortBy and status
  let sortOrder = initialSortOrder;
  if (!sortOrder) {
    if (sortBy === 'event_date') {
      sortOrder = status === 'past' ? 'DESC' : 'ASC';
    } else if (sortBy === 'created_at') {
      sortOrder = 'DESC';
    } else { // title
      sortOrder = 'ASC';
    }
  }

  const offset = (page - 1) * limit;

  const whereClause = {};
  const now = new Date();

  if (status === 'upcoming') {
    whereClause.start_date = { [Op.gt]: now };
  } else if (status === 'past') {
    whereClause.start_date = { [Op.lte]: now };
  }
  
  // Adjust sortBy to match model field name if 'event_date' is used
  const actualSortBy = sortBy === 'event_date' ? 'start_date' : sortBy;

  try {
    const { count, rows } = await Event.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
      ],
      order: [[actualSortBy, sortOrder.toUpperCase()]],
      limit,
      offset,
      distinct: true, // Important for correct count with includes
    });

    const totalItems = count;
    const totalPages = Math.ceil(totalItems / limit);
    const hasNextPage = page < totalPages;
    const hasPrevPage = page > 1;

    // Map to desired response structure, especially event_date
    const formattedEvents = rows.map(event => ({
      id: event.id,
      title: event.title,
      description: event.description,
      event_date: event.start_date, // Map start_date to event_date
      end_date: event.end_date, // Add end_date to the response
      location: event.location,
      created_by: event.creator ? { id: event.creator.id, name: event.creator.name } : null,
      created_at: event.created_at,
      updated_at: event.updated_at,
    }));


    return {
      data: formattedEvents,
      pagination: {
        totalItems,
        totalPages,
        currentPage: parseInt(page, 10),
        limit: parseInt(limit, 10),
        hasNextPage,
        hasPrevPage,
      },
    };
  } catch (error) {
    console.error('Error fetching events:', error);
    throw new Error('Error fetching events from database.');
  }
};

const updateEvent = async (eventId, updateData, adminUserId) => {
  try {
    const event = await Event.findByPk(eventId);
    if (!event) {
      const error = new Error('Event not found');
      error.statusCode = 404;
      throw error;
    }

    // Validate start_date and end_date
    const { start_date, end_date } = updateData;

    if(start_date !== undefined && end_date !== undefined) {
      const validatedStartDate = start_date ? new Date(start_date) : event.start_date;
      const validatedEndDate = end_date ? new Date(end_date) : event.end_date;
      // If both dates are present (either from input or existing event data), validate them
      if (validatedStartDate && validatedEndDate && validatedEndDate <= validatedStartDate) {
        const error = new Error('End date must be after start date.');
        error.statusCode = 400; // Bad Request
        throw error;
      }
    }
    
    // Prepare fields for update, only including those provided in updateData
    const fieldsToUpdate = {};
    if (updateData.title !== undefined) fieldsToUpdate.title = updateData.title;
    if (updateData.description !== undefined) fieldsToUpdate.description = updateData.description;
    if (start_date !== undefined) fieldsToUpdate.start_date = validatedStartDate;
    if (end_date !== undefined) fieldsToUpdate.end_date = validatedEndDate;
    if (updateData.location !== undefined) fieldsToUpdate.location = updateData.location;


    // Only update if there are fields to update
    if (Object.keys(fieldsToUpdate).length > 0) {
        await event.update(fieldsToUpdate);
    }
    
    // Audit Logging
    try {
      await auditService.logAdminAction(adminUserId, 'event_update', { eventId, updatedFields: Object.keys(fieldsToUpdate) });
    } catch (auditError) {
      console.error('Failed to log admin action for event_update:', auditError);
    }

    // Fetch the updated event with creator info to match getAllEvents structure
    const updatedEventWithCreator = await Event.findByPk(eventId, {
      include: [
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
      ],
    });
    
    return {
        id: updatedEventWithCreator.id,
        title: updatedEventWithCreator.title,
        description: updatedEventWithCreator.description,
        event_date: updatedEventWithCreator.start_date, // Map start_date to event_date
        end_date: updatedEventWithCreator.end_date,
        location: updatedEventWithCreator.location,
        created_by: updatedEventWithCreator.creator ? { id: updatedEventWithCreator.creator.id, name: updatedEventWithCreator.creator.name } : null,
        created_at: updatedEventWithCreator.created_at,
        updated_at: updatedEventWithCreator.updated_at,
      };

  } catch (error) {
    console.error(`Error updating event ${eventId}:`, error);
    if (!error.statusCode) { // Default to 500 if no specific status code is set
        error.statusCode = 500;
        error.message = 'Error updating event in database.';
    }
    throw error;
  }
};

const deleteEvent = async (eventId, adminUserId) => {
  try {
    const event = await Event.findByPk(eventId);
    if (!event) {
      const error = new Error('Event not found');
      error.statusCode = 404;
      throw error;
    }

    await event.destroy();

    // Audit Logging
    try {
      await auditService.logAdminAction(adminUserId, 'event_delete', { eventId });
    } catch (auditError) {
      console.error('Failed to log admin action for event_delete:', auditError);
    }

  } catch (error) {
    console.error(`Error deleting event ${eventId}:`, error);
    if (!error.statusCode) { // Default to 500 if no specific status code is set
        error.statusCode = 500;
        error.message = 'Error deleting event from database.';
    }
    throw error;
  }
};


const createEvent = async (eventData, adminUserId) => {
  const { title, description, event_date, location } = eventData;

  try {
    // Assumption: event_date from request maps to start_date.
    // Assumption: end_date is set to start_date as it's NOT NULL in DB but not in US14 request.
    const newEventRecord = await Event.create({
      title,
      description,
      start_date: event_date,
      end_date: event_date, // Setting end_date same as start_date
      location,
      created_by: adminUserId,
    });

    // Audit Logging
    try {
      await auditService.logAdminAction(adminUserId, 'event_create', { eventId: newEventRecord.id, title: newEventRecord.title });
    } catch (auditError) {
      console.error('Failed to log admin action for event_create:', auditError);
    }

    // Fetch the event again to include creator details for a consistent response structure
    const populatedEvent = await Event.findByPk(newEventRecord.id, {
      include: [
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
      ],
    });

    // Format the response to match the User Story and other event service responses
    return {
      id: populatedEvent.id,
      title: populatedEvent.title,
      description: populatedEvent.description,
      event_date: populatedEvent.start_date, // Map start_date back to event_date for response
      end_date: populatedEvent.end_date, // Add end_date to the response
      location: populatedEvent.location,
      created_by: populatedEvent.creator ? { id: populatedEvent.creator.id, name: populatedEvent.creator.name } : null,
      createdAt: populatedEvent.created_at,
      updatedAt: populatedEvent.updated_at,
    };

  } catch (error) {
    console.error(`Error creating event:`, error);
    // Allowing Sequelize validation errors to propagate with their structure,
    // or re-throwing a generic error for other DB issues.
    if (error.name === 'SequelizeValidationError' || error.name === 'SequelizeUniqueConstraintError') {
        const simplifiedErrors = error.errors.map(e => ({ message: e.message, path: e.path }));
        const err = new Error('Validation failed or constraint violation.');
        err.statusCode = 400; // Bad Request
        err.errors = simplifiedErrors;
        throw err;
    }
    
    const serviceError = new Error('Error creating event in database.');
    serviceError.statusCode = error.statusCode || 500;
    throw serviceError;
  }
};

module.exports = {
  getAllEvents,
  updateEvent,
  deleteEvent,
  createEvent,
};

================
File: backend/src/services/user.service.js
================
const fs = require('fs');
const path = require('path');
const { User, Document, sequelize } = require('../../models'); // Adjust path as necessary
const { Op } = require('sequelize');
const bcrypt = require('bcrypt');
const ApiError = require('../utils/ApiError'); // Added for custom error handling
const auditService = require('./audit.service');

/**
 * Selects and returns publicly safe user profile fields.
 * @param {Object} user - The Sequelize user object.
 * @returns {Object} - An object containing safe user profile fields.
 */
const selectUserProfileFields = (user) => {
  if (!user) {
    return null;
  }
  return {
    id: user.id,
    name: user.name,
    email: user.email,
    role: user.role,
    status: user.status,
    email_verified: user.email_verified,
    is_system_user: user.is_system_user,
    created_at: user.created_at,
    updated_at: user.updated_at,
  };
};

/**
 * Fetches the profile of the currently authenticated user.
 * @param {number} userId - The ID of the user.
 * @returns {Promise<Object|null>} - The user profile or null if not found.
 */
const fetchOwnProfile = async (userId) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      return null; // Or throw an error to be caught by the controller
    }
    return selectUserProfileFields(user);
  } catch (error) {
    console.error('Error fetching own profile:', error);
    throw error;
  }
};

/**
 * Modifies the profile of the currently authenticated user.
 * @param {number} userId - The ID of the user.
 * @param {Object} updateData - The data to update (e.g., { name: "New Name" }).
 * @returns {Promise<Object|null>} - The updated user profile or null if user not found.
 */
const modifyOwnProfile = async (userId, updateData) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      return null; // Or throw an error
    }

    // Only allow 'name' to be updated for now
    if (updateData.name !== undefined) {
      // Basic validation: ensure name is not empty if provided
      if (typeof updateData.name !== 'string' || updateData.name.trim() === '') {
        const error = new Error('Name cannot be empty.');
        error.isValidationError = true; // Custom flag for validation errors
        error.field = 'name';
        throw error;
      }
      user.name = updateData.name.trim();
    }

    // Potentially add more updatable fields here in the future,
    // ensuring proper validation for each.
    // For example:
    // if (updateData.bio !== undefined) {
    //   user.bio = updateData.bio;
    // }

    await user.save();
    return selectUserProfileFields(user);
  } catch (error) {
    console.error('Error modifying own profile:', error);
    throw error;
  }
};

/**
 * Updates the password for the currently authenticated user.
 * @param {number} userId - The ID of the user.
 * @param {string} currentPassword - The user's current password.
 * @param {string} newPassword - The new password to set.
 * @returns {Promise<void>}
 * @throws {Error} - Throws error if user not found, current password incorrect, or new password invalid.
 */
const updateOwnPassword = async (userId, currentPassword, newPassword) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      const error = new Error('User not found.');
      error.statusCode = 404; // Or handle as per your app's error strategy
      throw error;
    }

    const isMatch = await bcrypt.compare(currentPassword, user.password);
    if (!isMatch) {
      const error = new Error('Incorrect current password.');
      error.statusCode = 403; // Forbidden
      throw error;
    }

    // Password complexity validation is handled by express-validator,
    // but a service-level check could be added here if desired for extra safety
    // or if the service is used outside of a validated controller context.

    const salt = await bcrypt.genSalt(10);
    user.password = await bcrypt.hash(newPassword, salt);
    await user.save();

  } catch (error) {
    console.error('Error updating own password:', error);
    // Re-throw with a more generic message or specific status code if needed
    if (!error.statusCode) {
        // Default to a server error if not already set
        const serviceError = new Error('Could not update password.');
        serviceError.statusCode = error.isValidationError ? 400 : 500; // Keep 400 for validation
        throw serviceError;
    }
    throw error;
  }
};


/**
 * Lists non-system users with pagination.
 * @param {Object} options - Pagination options.
 * @param {number} [options.limit=10] - Number of users to fetch.
 * @param {number} [options.offset=0] - Number of users to skip.
 * @returns {Promise<Object>} - An object containing 'rows' (users) and 'count' (total non-system users).
 */
const listNonSystemUsers = async ({ limit = 10, offset = 0 }) => {
  try {
    const { count, rows } = await User.findAndCountAll({
      where: {
        is_system_user: false,
      },
      attributes: {
        exclude: ['password'],
        include: ['id', 'name', 'email', 'role', 'status', 'email_verified', 'is_system_user', 'created_at', 'updated_at'],
      },
      limit: parseInt(limit, 10),
      offset: parseInt(offset, 10),
      order: [['created_at', 'DESC']],
    });
    return { rows: rows.map(selectUserProfileFields), count };
  } catch (error) {
    console.error('Error listing non-system users:', error);
    throw error;
  }
};

/**
 * Retrieves a single non-system user by their ID.
 * @param {number} userId - The ID of the user to retrieve.
 * @returns {Promise<Object|null>} - The user object or null if not found or is a system user.
 */
const getNonSystemUserById = async (userId) => {
  try {
    const user = await User.findOne({
      where: {
        id: userId,
        is_system_user: false,
      },
      attributes: {
        exclude: ['password'],
        include: ['id', 'name', 'email', 'role', 'status', 'email_verified', 'is_system_user', 'created_at', 'updated_at'],
      },
    });

    if (!user) {
      return null; // User not found or is a system user
    }

    return selectUserProfileFields(user);
  } catch (error) {
    console.error('Error retrieving non-system user by ID:', error);
    throw error;
  }
};


/**
 * Updates the status of a target user. (Admin operation)
 * @param {number} targetUserId - The ID of the user whose status is to be updated.
 * @param {string} newStatus - The new status to set.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<Object>} - The updated user profile (excluding password).
 * @throws {ApiError} - Throws error if user not found or is a system user.
 */
const updateUserStatus = async (targetUserId, newStatus, adminUserId) => {
  const targetUser = await User.findByPk(targetUserId);
  if (!targetUser) {
    throw new ApiError(404, 'User not found');
  }
  if (targetUser.is_system_user === true) {
    throw new ApiError(403, 'System users cannot be modified.');
  }

  targetUser.status = newStatus;
  await targetUser.save();

  try {
    await auditService.logAdminAction(adminUserId, 'user_status_update', { targetUserId: targetUserId, newStatus: newStatus });
  } catch (auditError) {
    console.error('Failed to log admin action for user_status_update:', auditError);
  }

  return selectUserProfileFields(targetUser.toJSON());
};

/**
 * Updates the role of a target user. (Admin operation)
 * @param {number} targetUserId - The ID of the user whose role is to be updated.
 * @param {string} newRole - The new role to set.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<Object>} - The updated user profile (excluding password).
 * @throws {ApiError} - Throws error if user not found or is a system user.
 */
const updateUserRole = async (targetUserId, newRole, adminUserId) => {
  const targetUser = await User.findByPk(targetUserId);
  if (!targetUser) {
    throw new ApiError(404, 'User not found');
  }
  if (targetUser.is_system_user === true) {
    throw new ApiError(403, 'System users cannot be modified.');
  }

  targetUser.role = newRole;
  await targetUser.save();

  try {
    await auditService.logAdminAction(adminUserId, 'user_role_update', { targetUserId: targetUserId, newRole: newRole });
  } catch (auditError) {
    console.error('Failed to log admin action for user_role_update:', auditError);
  }

  return selectUserProfileFields(targetUser.toJSON());
};

/**
 * Deletes a user and their associated documents. (Admin operation)
 * @param {number} targetUserId - The ID of the user to delete.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<Object>} - Success object.
 * @throws {ApiError} - Throws error if user not found, is a system user, or deletion fails.
 */
const deleteUser = async (targetUserId, adminUserId) => {
  const t = await sequelize.transaction();

  try {
    const targetUser = await User.findByPk(targetUserId, { transaction: t });

    if (!targetUser) {
      throw new ApiError(404, 'User not found');
    }

    if (targetUser.is_system_user === true) {
      throw new ApiError(403, 'System users cannot be deleted.');
    }

    // Handle Associated Documents
    const userDocuments = await Document.findAll({
      where: { uploaded_by: targetUserId },
      transaction: t,
    });

    for (const doc of userDocuments) {
      if (doc.file_path) {
        // Assuming 'uploads/' is at the project root.
        // backend/src/services -> backend/src -> backend -> project_root
        const filePath = path.join(__dirname, '../../../uploads', doc.file_path);
        try {
          await fs.promises.unlink(filePath);
          console.log(`Successfully deleted physical file: ${filePath}`);
        } catch (fileError) {
          console.error(`Failed to delete physical file ${filePath}:`, fileError.message);
          // IMPORTANT: Re-throw to trigger transaction rollback
          throw new ApiError(500, `Failed to delete associated file ${doc.file_path}. User deletion rolled back.`);
        }
      }
      await doc.destroy({ transaction: t });
    }

    // Delete the User
    await targetUser.destroy({ transaction: t });

    // Commit the transaction
    await t.commit();

    // Audit Log
    try {
      await auditService.logAdminAction(adminUserId, 'user_delete', { targetUserId: targetUserId });
    } catch (auditError) {
      console.error('Failed to log admin action for user_delete:', auditError);
    }

    return { success: true, message: 'User and associated documents deleted successfully.' };
  } catch (error) {
    // Rollback transaction
    await t.rollback();

    // Log the original error for debugging
    console.error(`Failed to delete user [${targetUserId}]:`, error);

    // Re-throw the original ApiError or a new one for other errors
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(500, `Failed to delete user. ${error.message}`);
  }
};

/**
 * Changes a user's password by an admin.
 * @param {number} targetUserId - The ID of the user whose password is to be changed.
 * @param {string} newPassword - The new password.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise&lt;Object&gt;} - Success object.
 * @throws {ApiError} - Throws error if user not found, is a system user, or update fails.
 */
const changeUserPasswordByAdmin = async (targetUserId, newPassword, adminUserId) => {
  const targetUser = await User.findByPk(targetUserId);
  if (!targetUser) {
    throw new ApiError(404, 'User not found');
  }

  if (targetUser.is_system_user === true) {
    throw new ApiError(403, 'System users cannot have their password changed by an admin.');
  }

  const hashedPassword = await bcrypt.hash(newPassword, 10);
  targetUser.password = hashedPassword;
  await targetUser.save();

  try {
    await auditService.logAdminAction(adminUserId, 'admin_change_user_password', { targetUserId: targetUserId });
  } catch (auditError) {
    console.error('Failed to log admin action for admin_change_user_password:', auditError);
  }

  return { success: true, message: 'Password changed successfully by admin.' };
};

module.exports = {
  fetchOwnProfile,
  modifyOwnProfile,
  updateOwnPassword,
  selectUserProfileFields, // Exporting for potential use in other services/controllers if needed
  listNonSystemUsers,
  getNonSystemUserById,
  updateUserStatus,
  updateUserRole,
  deleteUser,
  changeUserPasswordByAdmin,
};

================
File: backend/src/utils/ApiError.js
================
class ApiError extends Error {
  constructor(statusCode, message, isOperational = true, stack = '') {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

module.exports = ApiError;

================
File: backend/src/utils/catchAsync.js
================
const catchAsync = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch((err) => next(err));
};

module.exports = catchAsync;

================
File: backend/src/validators/admin.user.validator.js
================
const Joi = require('joi');

const updateUserStatusSchema = Joi.object({
  status: Joi.string().trim().valid('approved', 'pending', 'rejected').required().messages({
    'string.base': 'Status must be a string.',
    'string.empty': 'Status is required.',
    'any.only': 'Status must be one of [approved, pending, rejected].',
    'any.required': 'Status is required.'
  })
});

const updateUserRoleSchema = Joi.object({
  role: Joi.string().trim().valid('admin', 'member').required().messages({
    'string.base': 'Role must be a string.',
    'string.empty': 'Role is required.',
    'any.only': 'Role must be one of [admin, member].',
    'any.required': 'Role is required.'
  })
});

const changePasswordSchema = Joi.object({
  newPassword: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?]).{8,}$'))
    .required()
    .messages({
      'string.base': 'New password must be a string.',
      'string.empty': 'New password is required.',
      'string.min': 'New password must be at least 8 characters long.',
      'string.pattern.base': 'New password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one number, and one special character.',
      'any.required': 'New password is required.'
    })
});

module.exports = {
  updateUserStatusSchema,
  updateUserRoleSchema,
  changePasswordSchema, // Added for User Story 7, will be used later
};

================
File: backend/src/validators/announcement.validator.js
================
const Joi = require('joi');

const createAnnouncementSchema = Joi.object({
  title: Joi.string().trim().max(255).required().messages({
    'string.base': 'Title must be a string.',
    'string.empty': 'Title is required.',
    'string.max': 'Title cannot exceed 255 characters.',
    'any.required': 'Title is required.'
  }),
  content: Joi.string().trim().required().messages({
    'string.base': 'Content must be a string.',
    'string.empty': 'Content is required.',
    'any.required': 'Content is required.'
  }),
  expiresAt: Joi.date().iso().greater('now').optional().messages({
    'date.base': 'Expiration date must be a valid date.',
    'date.format': 'Expiration date must be in ISO 8601 format.',
    'date.greater': 'Expiration date must be in the future.'
  })
});

const updateAnnouncementSchema = Joi.object({
  title: Joi.string().trim().min(1).max(255).optional().messages({
    'string.base': 'Title must be a string.',
    'string.min': 'Title must not be empty if provided.',
    'string.max': 'Title cannot exceed 255 characters.'
  }),
  content: Joi.string().trim().min(1).optional().messages({
    'string.base': 'Content must be a string.',
    'string.min': 'Content must not be empty if provided.'
  }),
  expires_at: Joi.date().iso().allow(null).optional().messages({
    'date.base': 'expires_at must be a valid date or null.',
    'date.format': 'expires_at must be a valid ISO 8601 date or null.'
  })
}).or('title', 'content', 'expires_at').messages({
  'object.missing': 'At least one field (title, content, or expires_at) must be provided for update.'
});

const listAnnouncementsSchema = Joi.object({
  page: Joi.number().integer().min(1).optional().messages({
    'number.base': 'Page must be a number.',
    'number.integer': 'Page must be an integer.',
    'number.min': 'Page must be at least 1.'
  }),
  limit: Joi.number().integer().min(1).max(100).optional().messages({
    'number.base': 'Limit must be a number.',
    'number.integer': 'Limit must be an integer.',
    'number.min': 'Limit must be at least 1.',
    'number.max': 'Limit must be between 1 and 100.'
  }),
  sortOrder: Joi.string().valid('asc', 'desc').optional().messages({
    'string.base': 'Sort order must be a string.',
    'any.only': 'Sort order must be one of "asc" or "desc".'
  }),
  status: Joi.string().valid('active').optional().messages({
    'string.base': 'Status must be a string.',
    'any.only': 'Status must be "active" if provided.'
  }),
  sortBy: Joi.string().valid('created_at').optional().messages({
    'string.base': 'Sort by must be a string.',
    'any.only': 'Sort by must be "created_at" if provided.'
  })
});

module.exports = {
  createAnnouncementSchema,
  updateAnnouncementSchema,
  listAnnouncementsSchema,
};

================
File: backend/src/validators/audit.validator.js
================
const Joi = require('joi');

const getAuditLogsSchema = Joi.object({
  page: Joi.number().integer().min(1).optional().default(1),
  limit: Joi.number().integer().min(1).max(100).optional().default(10),
});

module.exports = {
  getAuditLogsSchema,
};

================
File: backend/src/validators/auth.validator.js
================
const Joi = require('joi');

const registerSchema = Joi.object({
  name: Joi.string().trim().min(1).required().messages({
    'string.base': 'Name must be a string.',
    'string.empty': 'Name is required.',
    'string.min': 'Name is required.',
    'any.required': 'Name is required.'
  }),
  email: Joi.string().trim().email().required().messages({
    'string.base': 'Email must be a string.',
    'string.empty': 'Email is required.',
    'string.email': 'Email must be a valid email address.',
    'any.required': 'Email is required.'
  }),
  password: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?]).*$'))
    .required()
    .messages({
      'string.base': 'Password must be a string.',
      'string.empty': 'Password is required.',
      'string.min': 'Password must be at least 8 characters long.',
      'string.pattern.base': 'Password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one number, and one special character.',
      'any.required': 'Password is required.'
    })
  // passwordConfirmation: Joi.string().valid(Joi.ref('password')).required().messages({
  //   'any.only': 'Password confirmation must match password.',
  //   'any.required': 'Password confirmation is required.'
  // })
});

const loginSchema = Joi.object({
  email: Joi.string().trim().email().required().messages({
    'string.base': 'Email must be a string.',
    'string.empty': 'Email is required.',
    'string.email': 'Email must be a valid email address.',
    'any.required': 'Email is required.'
  }),
  password: Joi.string().required().messages({
    'string.base': 'Password must be a string.',
    'string.empty': 'Password is required.',
    'any.required': 'Password is required.'
  })
});

const forgotPasswordSchema = Joi.object({
  email: Joi.string().trim().email().required().messages({
    'string.base': 'Email must be a string.',
    'string.empty': 'Email is required.',
    'string.email': 'Email must be a valid email address.',
    'any.required': 'Email is required.'
  })
});

const resetPasswordSchema = Joi.object({
  token: Joi.string().allow('').messages({
    'string.base': 'Token must be a string.'
  }),
  newPassword: Joi.string().allow('')
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?]).*$'))
    .messages({
      'string.base': 'New password must be a string.',
      'string.min': 'New password must be at least 8 characters long.',
      'string.pattern.base': 'Password must include uppercase, lowercase, number, and special character.'
    })
})
.custom((value, helpers) => {
  const { token, newPassword } = value;
  const tokenIsEffectivelyMissing = token === undefined || token === '';
  const newPasswordIsEffectivelyMissing = newPassword === undefined || newPassword === '';

  if (tokenIsEffectivelyMissing && newPasswordIsEffectivelyMissing) {
    return helpers.error('custom.bothMissing');
  }
  if (tokenIsEffectivelyMissing) {
    return helpers.error('custom.tokenMissing');
  }
  if (newPasswordIsEffectivelyMissing) {
    return helpers.error('custom.newPasswordMissing');
  }
  return value;
})
.messages({
  'custom.bothMissing': 'Token and newPassword are required.',
  'custom.tokenMissing': 'Token is required.',
  'custom.newPasswordMissing': 'New password is required.'
});

module.exports = {
  registerSchema,
  loginSchema,
  forgotPasswordSchema,
  resetPasswordSchema,
};

================
File: backend/src/validators/config.validator.js
================
const Joi = require('joi');

const updateConfigSchema = Joi.object({
  // From req.body
  value: Joi.string().trim().min(1).required().messages({
    'string.base': 'Value must be a string.',
    'string.empty': 'Value cannot be empty.',
    'string.min': 'Value cannot be empty.',
    'any.required': 'Value is required.',
  }),
  // From req.params
  key: Joi.string().required(),
});

module.exports = {
  updateConfigSchema,
};

================
File: backend/src/validators/discussion.validator.js
================
const Joi = require('joi');

const createThreadSchema = Joi.object({
  title: Joi.string().min(3).max(255).required(),
  content: Joi.string().min(1).required(),
});

const createReplySchema = Joi.object({
  content: Joi.string().min(1).required(),
});

const listThreadsSchema = Joi.object({
  page: Joi.number().integer().min(1).default(1),
  limit: Joi.number().integer().min(1).max(50).default(10),
});

module.exports = {
  createThreadSchema,
  createReplySchema,
  listThreadsSchema,
};

================
File: backend/src/validators/document.validator.js
================
const Joi = require('joi');

const uploadDocumentSchema = Joi.object({
  title: Joi.string().trim().min(1).required().messages({
    'string.base': 'Title must be a string.',
    'string.empty': 'Title is required.',
    'string.min': 'Title is required.',
    'any.required': 'Title is required.'
  }),
  description: Joi.string().trim().allow('').optional().messages({ // Allow empty string for optional description
    'string.base': 'Description must be a string.'
  }),
  is_public: Joi.boolean().required().messages({
    'boolean.base': 'Is Public flag must be a boolean.',
    'any.required': 'Is Public flag is required.'
  })
});

// Schema for when a document is being updated (if needed later)
// const updateDocumentSchema = Joi.object({
//   title: Joi.string().trim().min(1).optional(),
//   description: Joi.string().trim().allow('').optional(),
//   is_public: Joi.boolean().optional(),
//   approved: Joi.boolean().optional() // Admins might also update approval status directly
// });

module.exports = {
  uploadDocumentSchema,
  // updateDocumentSchema,
};

================
File: backend/src/validators/event.validator.js
================
// backend/src/validators/event.validator.js

const Joi = require('joi');

const listEventsSchema = Joi.object({
  status: Joi.string().valid('upcoming', 'past').optional(),
  page: Joi.number().integer().min(1).optional(),
  limit: Joi.number().integer().min(1).max(50).optional(),
  sortBy: Joi.string().valid('event_date', 'title', 'created_at').optional(),
  sortOrder: Joi.string().valid('asc', 'desc').optional(),
});

const createEventSchema = Joi.object({
  title: Joi.string().min(3).max(255).required(),
  description: Joi.string().min(10).required(),
  event_date: Joi.date().iso().greater('now').required().messages({
    'date.greater': 'Event date must be in the future.'
  }),
  location: Joi.string().max(255).required(),
});

const adminUpdateEventSchema = Joi.object({
  // From path
  id: Joi.number().integer().required(),
  // From body
  title: Joi.string().optional(),
  description: Joi.string().optional(),
  start_date: Joi.date().iso().optional(),
  end_date: Joi.date().iso().optional(),
  location: Joi.string().optional(),
}).with('start_date', 'end_date') // If one is present, the other should be too for validation
  .and('start_date', 'end_date') // if you want to enforce both if one is provided
  .custom((value, helpers) => {
    if (value.start_date && value.end_date && value.end_date <= value.start_date) {
      return helpers.message('End date must be after start date.');
    }
    return value;
  });

module.exports = {
  listEventsSchema,
  createEventSchema,
  adminUpdateEventSchema,
};

================
File: backend/src/validators/user.validator.js
================
const Joi = require('joi');

const updateProfileSchema = Joi.object({
  name: Joi.string().trim().min(1).required().messages({
    'string.empty': 'Name cannot be empty.',
    'any.required': 'Name is required.',
  }),
});

const changePasswordSchema = Joi.object({
  currentPassword: Joi.string().required(),
  newPassword: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?]).*$'))
    .required()
    .messages({
      'string.min': 'New password must be at least 8 characters long.',
      'string.pattern.base': 'New password must include uppercase, lowercase, number, and special character.',
      'any.required': 'New password is required.',
    }),
});

module.exports = {
  updateProfileSchema,
  changePasswordSchema,
};

================
File: backend/src/app.js
================
require('dotenv').config(); // Load environment variables from .env file
const express = require('express');
const cors = require('cors');
const path = require('path'); // Required for serving static files if needed later
const db = require('../models'); // Sequelize instance and models

// Permissive CORS configuration for development
const corsOptions = {
  origin: '*', // Allow all origins
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'], // Allowed methods
  allowedHeaders: ['Content-Type', 'Authorization'], // Allowed headers
  optionsSuccessStatus: 200
};

// Import routes
const authRoutes = require('./routes/auth.routes');
const adminUserRoutes = require('./routes/admin.user.routes');
const adminDocumentRoutes = require('./routes/document.routes'); // For admin document operations
const announcementRoutes = require('./routes/announcement.routes.js');
const eventRoutes = require('./routes/event.routes.js');
const userRoutes = require('./routes/user.routes'); // Routes for user self-management
const discussionRoutes = require('./routes/discussion.routes');
const configRoutes = require('./routes/config.routes'); // Routes for admin config management
const auditRoutes = require('./routes/audit.routes'); // Routes for admin audit log management
const publicDocumentRoutes = require('./routes/public.document.routes'); // For public document access
// Public document routes will be separate, e.g., publicDocumentRoutes

const app = express();

// Middleware
app.use(cors(corsOptions));
app.use(express.json()); // for parsing application/json
app.use(express.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded

// Basic Route for testing
app.get('/', (req, res) => {
  res.json({ message: 'Welcome to the HOA Management API!' });
});

// API Routes
app.use('/api/auth', authRoutes);
app.use('/api/admin/users', adminUserRoutes);
app.use('/api/admin/documents', adminDocumentRoutes); // Admin-specific document routes
app.use('/api/announcements', announcementRoutes);
app.use('/api/events', eventRoutes);
app.use('/api/users', userRoutes); // Mount user self-management routes
app.use('/api/discussions', discussionRoutes);
app.use('/api/admin/config', configRoutes); // Mount admin config routes
app.use('/api/admin/audit-logs', auditRoutes); // Mount admin audit log routes
app.use('/api/documents', publicDocumentRoutes); // For public listing/downloading

// Global error handler (optional, can be more sophisticated)
app.use((err, req, res, next) => {
  console.error(err.stack);
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';
  res.status(statusCode).json({ message });
});

const PORT = process.env.PORT || 3001; // Default to 3001 if PORT not in .env

async function startServer() {
  try {
    await db.sequelize.authenticate();
    console.log('Database connection has been established successfully.');
    // await db.sequelize.sync(); // { alter: true } or { force: true } during dev if needed
    // console.log('All models were synchronized successfully.'); // Uncomment if using sync

    app.listen(PORT, () => {
      console.log(`Server is running on port ${PORT}.`);
      console.log(`Access it at http://localhost:${PORT}`);
    });
  } catch (error) {
    console.error('Unable to connect to the database or start server:', error);
    process.exit(1); // Exit if cannot connect to DB
  }
}

// Only start server if this file is run directly (not when imported as a module)
if (require.main === module) {
  startServer();
}

module.exports = app; // Export for testing or other purposes

================
File: backend/test/good/announcements.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');

describe('Announcement API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let testAnnouncementId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;

    memberToken = await createAndApproveUser(
      { name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!' },
      adminToken
    );
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('GET /announcements', () => {
    beforeAll(async () => {
      // Create a test announcement
      const res = await request(app)
        .post('/api/announcements')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          title: 'Test Announcement',
          content: 'This is a test announcement',
          expiresAt: '2025-12-31T23:59:59Z'
        });
      testAnnouncementId = res.body.id;
    });

    it('should list announcements for member', async () => {
      const res = await request(app)
        .get('/api/announcements')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should list announcements for admin', async () => {
      const res = await request(app)
        .get('/api/announcements')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });
  });

  describe('Admin Announcement Management', () => {
    describe('POST /announcements', () => {
      it('should create announcement as admin', async () => {
        const res = await request(app)
          .post('/api/announcements')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'New Announcement',
            content: 'Important update',
            expiresAt: '2025-12-31T23:59:59Z'
          });
        
        expect(res.statusCode).toEqual(201);
        expect(res.body.title).toEqual('New Announcement');
      });

      it('should fail with missing required fields', async () => {
        const res = await request(app)
          .post('/api/announcements')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            content: 'Missing title'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .post('/api/announcements')
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized',
            content: 'Should fail'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('PUT /announcements/{id}', () => {
      it('should update announcement as admin', async () => {
        const res = await request(app)
          .put(`/api/announcements/${testAnnouncementId}`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'Updated Announcement',
            content: 'Updated content'
          });
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.title).toEqual('Updated Announcement');
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .put(`/api/announcements/${testAnnouncementId}`)
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized Update'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('DELETE /announcements/{id}', () => {
      it('should delete announcement as admin', async () => {
        const res = await request(app)
          .delete(`/api/announcements/${testAnnouncementId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        // First create a new announcement to delete
        const createRes = await request(app)
          .post('/api/announcements')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'To Delete',
            content: 'Will try to delete'
          });
        
        const res = await request(app)
          .delete(`/api/announcements/${createRes.body.id}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });
});

================
File: backend/test/good/audit.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');

describe('Audit Log API Integration Tests', () => {
  let adminToken;
  let memberToken;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;

    // Register and login a member user
    memberToken = await createAndApproveUser(
      { name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!' },
      adminToken
    );
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('GET /admin/audit-logs', () => {
    it('should retrieve audit logs as admin', async () => {
      const res = await request(app)
        .get('/api/admin/audit-logs')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body).toHaveProperty('data');
      expect(res.body).toHaveProperty('pagination');
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should fail for non-admin user', async () => {
      const res = await request(app)
        .get('/api/admin/audit-logs')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(403);
    });

    it('should fail without token', async () => {
      const res = await request(app)
        .get('/api/admin/audit-logs');
      
      expect(res.statusCode).toEqual(401);
    });

    it('should support pagination', async () => {
      const res = await request(app)
        .get('/api/admin/audit-logs?page=1&limit=5')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body.pagination.limit).toEqual(5);
      expect(res.body.pagination.currentPage).toEqual(1);
    });

    it('should validate pagination params', async () => {
      const res = await request(app)
        .get('/api/admin/audit-logs?page=0&limit=101')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(400);
    });
  });

  describe('Audit Log Creation', () => {
    it('should create audit log for admin actions', async () => {
      // Perform an admin action that should trigger audit logging
      const createRes = await request(app)
        .post('/api/announcements')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          title: 'Test Audit Log',
          content: 'This should create an audit entry'
        });
      
      expect(createRes.statusCode).toEqual(201);

      // Verify audit log was created
      const auditRes = await request(app)
        .get('/api/admin/audit-logs')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(auditRes.statusCode).toEqual(200);
      const announcementAction = auditRes.body.data.find(
        log => log.action.includes('announcement_create')
      );
      expect(announcementAction).toBeDefined();
    });
  });
});

================
File: backend/test/good/auth.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB } = require('../utils/dbHelpers');

describe('Auth API Integration Tests', () => {
  beforeAll(async () => {
    await setupTestDB();
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('POST /api/auth/login', () => {
    it('should login with valid admin credentials', async () => {
      const res = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'testadmin@example.com',
          password: 'testadmin123'
        });
      
      expect(res.statusCode).toEqual(200);
      expect(res.body).toHaveProperty('token');
    });

    it('should fail with invalid password', async () => {
      const res = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'testadmin@example.com',
          password: 'wrongpassword'
        });
      
      expect(res.statusCode).toEqual(401);
    });
  });
});

================
File: backend/test/good/config.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB } = require('../utils/dbHelpers');

describe('Configuration API Integration Tests', () => {
  let adminToken;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin to get token
    const loginRes = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = loginRes.body.token;
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('GET /admin/config', () => {
    it('should retrieve all configurations (admin)', async () => {
      const res = await request(app)
        .get('/api/admin/config')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body).toHaveProperty('hoa_name');
      expect(res.body).toHaveProperty('hoa_description');
    });

    it('should fail without admin token', async () => {
      const res = await request(app)
        .get('/api/admin/config');
      
      expect(res.statusCode).toEqual(401);
    });
  });

  describe('PUT /admin/config/{key}', () => {
    it('should update configuration value (admin)', async () => {
      const res = await request(app)
        .put('/api/admin/config/hoa_name')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          value: 'New HOA Name'
        });
      
      expect(res.statusCode).toEqual(200);
      expect(res.body).toHaveProperty('key', 'hoa_name');
      expect(res.body).toHaveProperty('value', 'New HOA Name');
    });

    it('should fail with empty value', async () => {
      const res = await request(app)
        .put('/api/admin/config/hoa_name')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          value: ''
        });
      
      expect(res.statusCode).toEqual(400);
    });

    it('should fail without admin token', async () => {
      const res = await request(app)
        .put('/api/admin/config/hoa_name')
        .send({
          value: 'Should Fail'
        });
      
      expect(res.statusCode).toEqual(401);
    });
  });
});

================
File: backend/test/good/discussions.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');

describe('Discussion API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let member2Token;
  let testThreadId;
  let testReplyId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;
    expect(adminToken).toBeDefined();

    console.log(adminToken);

       // 2. Create and get tokens for member users using the helper
    memberToken = await createAndApproveUser(
      { name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!' },
      adminToken
    );
    
    member2Token = await createAndApproveUser(
      { name: 'Test Member 2', email: 'testmember2@example.com', password: 'Testmember123!' },
      adminToken
    );

    // Assert that the tokens were actually created
    expect(memberToken).toBeDefined();
    expect(member2Token).toBeDefined();
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('POST api/discussions', () => {
    it('should create discussion thread as member', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          title: 'Test Discussion',
          content: 'This is a test discussion thread'
        });
      
      expect(res.statusCode).toEqual(201);
      expect(res.body).toHaveProperty('id');
      expect(res.body.title).toEqual('Test Discussion');
      testThreadId = res.body.id;
    });

    it('should fail with missing required fields', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: 'Missing title'
        });
      
      expect(res.statusCode).toEqual(400);
    });

    it('should fail without authentication', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .send({
          title: 'Unauthorized',
          content: 'Should fail'
        });
      
      expect(res.statusCode).toEqual(401);
    });
  });

  describe('POST /api/discussions/{threadId}/replies', () => {
    it('should post reply to thread', async () => {
      const res = await request(app)
        .post(`/api/discussions/${testThreadId}/replies`)
        .set('Authorization', `Bearer ${member2Token}`)
        .send({
          content: 'This is a test reply'
        });
      
      expect(res.statusCode).toEqual(201);
      expect(res.body).toHaveProperty('id');
      testReplyId = res.body.id;
    });

    it('should fail with empty content', async () => {
      const res = await request(app)
        .post(`/api/discussions/${testThreadId}/replies`)
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: ''
        });
      
      expect(res.statusCode).toEqual(400);
    });

    it('should fail for non-existent thread', async () => {
      const res = await request(app)
        .post('/api/discussions/9999/replies')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: 'Test reply'
        });
      
      expect(res.statusCode).toEqual(404);
    });
  });

  describe('GET /api/discussions', () => {
    it('should list discussion threads', async () => {
      const res = await request(app)
        .get('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.threads)).toBeTruthy();
      expect(res.body.threads.some(t => t.id === testThreadId)).toBeTruthy();
    });

    it('should include reply counts', async () => {
      const res = await request(app)
        .get('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`);
      
      const thread = res.body.threads.find(t => t.id === testThreadId);
      expect(thread.reply_count).toBeGreaterThanOrEqual(1);
    });
  });

  describe('GET /api/discussions/{threadId}', () => {
    it('should get thread with replies', async () => {
      const res = await request(app)
        .get(`/api/discussions/${testThreadId}`)
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body.mainThread.id).toEqual(testThreadId);
      expect(Array.isArray(res.body.replies)).toBeTruthy();
      expect(res.body.replies.some(r => r.id === testReplyId)).toBeTruthy();
    });

    it('should fail for non-existent thread', async () => {
      const res = await request(app)
        .get('/api/discussions/9999')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(404);
    });
  });

  describe('Admin Discussion Management', () => {
    describe('DELETE /api/discussions/{threadId}', () => {
      it('should delete thread as admin', async () => {
        // Create a new thread to delete
        const createRes = await request(app)
          .post('/api/discussions')
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Thread to delete',
            content: 'Content'
          });
        
        const res = await request(app)
          .delete(`/api/discussions/${createRes.body.id}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .delete(`/api/discussions/${testThreadId}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('DELETE /api/discussions/replies/{replyId}', () => {
      it('should delete reply as admin', async () => {
        const res = await request(app)
          .delete(`/api/discussions/replies/${testReplyId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        // Create a new reply to try deleting
        const createRes = await request(app)
          .post(`/api/discussions/${testThreadId}/replies`)
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            content: 'Test reply to delete'
          });
        
        const res = await request(app)
          .delete(`/api/discussions/replies/${createRes.body.id}`)
          .set('Authorization', `Bearer ${member2Token}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });
});

================
File: backend/test/good/documents.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');
const path = require('path');

describe('Document API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let testDocumentId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;

    // Register and login a member user
    memberToken = await createAndApproveUser(
      { name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!' },
      adminToken
    );
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('Public/User Document Access', () => {
    beforeAll(async () => {
      // Upload a test document
      const res = await request(app)
        .post('/api/admin/documents')
        .set('Authorization', `Bearer ${adminToken}`)
        .field('title', 'Test Document')
        .field('is_public', true)
        .attach('documentFile', path.join(__dirname, '../fixtures/test.pdf'));
      testDocumentId = res.body.document.id;
    });

    describe('GET /documents', () => {
      it('should list public documents for guest', async () => {
        const res = await request(app)
          .get('/api/documents');
        
        expect(res.statusCode).toEqual(200);
        expect(Array.isArray(res.body.documents)).toBeTruthy();
      });

      it('should list all approved documents for member', async () => {
        const res = await request(app)
          .get('/api/documents')
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(200);
        expect(Array.isArray(res.body.documents)).toBeTruthy();
      });
    });

    describe('GET /documents/{documentId}', () => {
      it('should get document metadata for member', async () => {
        const res = await request(app)
          .get(`/api/documents/${testDocumentId}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.title).toEqual('Test Document');
      });

      it('should fail for non-existent document', async () => {
        const res = await request(app)
          .get('/api/documents/9999')
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(404);
      });
    });

    describe('GET /documents/{documentId}/download', () => {
      it('should download document file', async () => {
        const res = await request(app)
          .get(`/api/documents/${testDocumentId}/download`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(200);
        expect(res.headers['content-type']).toEqual('application/pdf');
      });
    });
  });

  describe('Admin Document Management', () => {
    describe('POST /admin/documents', () => {
      it('should upload a new document', async () => {
        const res = await request(app)
          .post('/api/admin/documents')
          .set('Authorization', `Bearer ${adminToken}`)
          .field('title', 'Admin Upload Test')
          .field('is_public', false)
          .attach('documentFile', path.join(__dirname, '../fixtures/test.pdf'));
        
        expect(res.statusCode).toEqual(201);
        expect(res.body.document.title).toEqual('Admin Upload Test');
      });

      it('should fail with invalid file type', async () => {
        const res = await request(app)
          .post('/api/admin/documents')
          .set('Authorization', `Bearer ${adminToken}`)
          .field('title', 'Invalid File')
          .field('is_public', true)
          .attach('documentFile', path.join(__dirname, '../fixtures/invalid.exe'));
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail without required fields', async () => {
        const res = await request(app)
          .post('/api/admin/documents')
          .set('Authorization', `Bearer ${adminToken}`)
          .attach('documentFile', path.join(__dirname, '../fixtures/test.pdf'));
        
        expect(res.statusCode).toEqual(400);
      });
    });

    describe('PUT /admin/documents/{id}/approve', () => {
      it('should approve a document', async () => {
        // First upload an unapproved document
        const uploadRes = await request(app)
          .post('/api/admin/documents')
          .set('Authorization', `Bearer ${adminToken}`)
          .field('title', 'Pending Approval')
          .field('is_public', false)
          .attach('documentFile', path.join(__dirname, '../fixtures/test.pdf'));
        
        const docId = uploadRes.body.document.id;
        
        const res = await request(app)
          .put(`/api/admin/documents/${docId}/approve`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.approved).toBeTruthy();
      });
    });

    describe('DELETE /admin/documents/{id}', () => {
      it('should delete a document', async () => {
        // First upload a test document
        const uploadRes = await request(app)
          .post('/api/admin/documents')
          .set('Authorization', `Bearer ${adminToken}`)
          .field('title', 'To Be Deleted')
          .field('is_public', true)
          .attach('documentFile', path.join(__dirname, '../fixtures/test.pdf'));
        
        const docId = uploadRes.body.document.id;
        
        const res = await request(app)
          .delete(`/api/admin/documents/${docId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });
    });
  });
});

================
File: backend/test/good/events.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');
const { sequelize } = require('../../models');

describe('Event API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let testEventId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;

    memberToken = await createAndApproveUser( {name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!'}, adminToken);
    expect(memberToken).toBeDefined();
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('GET /events', () => {
    beforeAll(async () => {
      // Create a test event
      const res = await request(app)
        .post('/api/events')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          title: 'Test Event',
          description: 'This is a test event',
          event_date: '2025-12-31T18:00:00Z',
          location: 'Test Location'
        });
      testEventId = res.body.id;
    });

    it('should list upcoming events for member', async () => {
      const res = await request(app)
        .get('/api/events?status=upcoming')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should list events for admin', async () => {
      const res = await request(app)
        .get('/api/events')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should filter past events', async () => {
      const queryInterface = sequelize.getQueryInterface();
      await queryInterface.bulkInsert('events', [{
        title: 'Past Event',
        description: 'This is a past event',
        start_date: new Date('2020-01-01T18:00:00Z'), // Use start_date for the column name
        end_date: new Date('2020-01-01T19:00:00Z'),   // Use end_date
        location: 'Past Location',
        created_by: 1, // Assuming admin user ID is 1
        created_at: new Date(),
        updated_at: new Date(),
      }]);

      const res = await request(app)
        .get('/api/events?status=past')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body.data.some(e => e.title === 'Past Event')).toBeTruthy();
    });
  });

  describe('Admin Event Management', () => {
    describe('POST /events', () => {
      it('should create event as admin', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'New Event',
            description: 'Important event',
            event_date: '2025-12-31T18:00:00Z',
            location: 'Event Location'
          });
        
        expect(res.statusCode).toEqual(201);
        expect(res.body.title).toEqual('New Event');
      });

      it('should fail with missing required fields', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            description: 'Missing title'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail with past event date', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'Past Event',
            description: 'Should fail',
            event_date: '2020-01-01T00:00:00Z',
            location: 'Past'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized',
            description: 'Should fail'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('PUT /events/{id}', () => {
      it('should update event as admin', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'Updated Event',
            description: 'Updated content'
          });
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.title).toEqual('Updated Event');
      });

      it('should fail with end_date before start_date', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            start_date: '2025-12-31T18:00:00Z',
            end_date: '2025-12-30T18:00:00Z'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized Update'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('DELETE /events/{id}', () => {
      it('should delete event as admin', async () => {
        const res = await request(app)
          .delete(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        // First create a new event to delete
        const createRes = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'To Delete',
            description: 'Will try to delete',
            event_date: '2025-12-31T18:00:00Z',
            location: 'Test'
          });
        
        const res = await request(app)
          .delete(`/api/events/${createRes.body.id}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });
});

================
File: backend/test/good/users.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { setupTestDB, teardownTestDB, createAndApproveUser, createAndApproveUserForUserManagement } = require('../utils/dbHelpers');

describe('User API Integration Tests', () => {
  let adminToken;
  let userToken;
  let testUserId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin to get token for admin tests
    const loginRes = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = loginRes.body.token;

    // Create, approve, and login a test user using our new helper
    const { token, user } = await createAndApproveUserForUserManagement(
      {
        name: 'Test User',
        email: 'testuser@example.com',
        // FIX: Use a password that meets complexity requirements
        password: 'Testuser123!' 
      },
      adminToken
    );
    userToken = token;
    testUserId = user.id;
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('User Self-Management', () => {
    // REMOVED: The inner beforeAll is no longer needed!

    describe('GET /api/users/me', () => {
      it('should get current user profile', async () => {
        const res = await request(app)
          .get('/api/users/me')
          .set('Authorization', `Bearer ${userToken}`);
        
        expect(res.statusCode).toEqual(200);
        expect(res.body).toHaveProperty('id', testUserId);
        expect(res.body.email).toEqual('testuser@example.com');
      });

      it('should fail without token', async () => {
        const res = await request(app)
          .get('/api/users/me');
        
        expect(res.statusCode).toEqual(401);
      });
    });

    describe('PUT /api/users/me', () => {
      it('should update user profile', async () => {
        const res = await request(app)
          .put('/api/users/me')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            name: 'Updated Test User'
          });
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.name).toEqual('Updated Test User');
      });

      it('should fail with empty name', async () => {
        const res = await request(app)
          .put('/api/users/me')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            name: ''
          });
        
        expect(res.statusCode).toEqual(400);
      });
    });

    describe('PUT /api/users/me/password', () => {
      it('should change password', async () => {
        const res = await request(app)
          .put('/api/users/me/password')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            currentPassword: 'Testuser123!',
            newPassword: 'Newpassword123!'
          });
        
        expect(res.statusCode).toEqual(200);
      });

      it('should fail with incorrect current password', async () => {
        const res = await request(app)
          .put('/api/users/me/password')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            currentPassword: 'wrongpassword',
            newPassword: 'Newpassword123!'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });

  describe('Admin User Management', () => {
    describe('GET /api/admin/users', () => {
      it('should list all users', async () => {
        const res = await request(app)
          .get('/api/admin/users')
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(200);
        // FIX: The response from the service uses `rows`, not `users`.
        expect(Array.isArray(res.body.rows)).toBeTruthy();
      });

      it('should fail without admin token', async () => {
        const res = await request(app)
          .get('/api/admin/users');
        
        expect(res.statusCode).toEqual(401);
      });
    });

    describe('PUT /api/admin/users/{userId}/status', () => {
      // Note: User is already approved in beforeAll, so we'll test another status change
      it('should update user status to rejected', async () => {
        const res = await request(app)
          .put(`/api/admin/users/${testUserId}/status`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            status: 'rejected'
          });
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.status).toEqual('rejected');
      });

      it('should fail with invalid status', async () => {
        const res = await request(app)
          .put(`/api/admin/users/${testUserId}/status`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            status: 'invalid'
          });
        
        expect(res.statusCode).toEqual(400);
      });
    });

    describe('DELETE /api/admin/users/{userId}', () => {
      it('should delete user', async () => {
        // We need a NEW user to delete, because if we delete testUser, other tests might fail
        // if they run after this one.
        const response = await createAndApproveUserForUserManagement(
            { name: 'Delete Me', email: 'deleteme@example.com', password: 'Password123!' },
            adminToken
        );

        const res = await request(app)
          .delete(`/api/admin/users/${response.user.id}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(200);
      });

      it('should fail with invalid user id', async () => {
        const res = await request(app)
          .delete('/api/admin/users/9999')
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(404);
      });
    });
  });
});

================
File: backend/test/integration/discussions.test.js
================
const request = require('supertest');
const app = require('../../../backend/src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');

describe('Discussion API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let member2Token;
  let testThreadId;
  let testReplyId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;
    expect(adminToken).toBeDefined();

    console.log(adminToken);

       // 2. Create and get tokens for member users using the helper
    memberToken = await createAndApproveUser(
      { name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!' },
      adminToken
    );
    
    member2Token = await createAndApproveUser(
      { name: 'Test Member 2', email: 'testmember2@example.com', password: 'Testmember123!' },
      adminToken
    );

    // Assert that the tokens were actually created
    expect(memberToken).toBeDefined();
    expect(member2Token).toBeDefined();
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('POST api/discussions', () => {
    it('should create discussion thread as member', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          title: 'Test Discussion',
          content: 'This is a test discussion thread'
        });
      
      expect(res.statusCode).toEqual(201);
      expect(res.body).toHaveProperty('id');
      expect(res.body.title).toEqual('Test Discussion');
      testThreadId = res.body.id;
    });

    it('should fail with missing required fields', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: 'Missing title'
        });
      
      expect(res.statusCode).toEqual(400);
    });

    it('should fail without authentication', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .send({
          title: 'Unauthorized',
          content: 'Should fail'
        });
      
      expect(res.statusCode).toEqual(401);
    });
  });

  describe('POST /api/discussions/{threadId}/replies', () => {
    it('should post reply to thread', async () => {
      const res = await request(app)
        .post(`/api/discussions/${testThreadId}/replies`)
        .set('Authorization', `Bearer ${member2Token}`)
        .send({
          content: 'This is a test reply'
        });
      
      expect(res.statusCode).toEqual(201);
      expect(res.body).toHaveProperty('id');
      testReplyId = res.body.id;
    });

    it('should fail with empty content', async () => {
      const res = await request(app)
        .post(`/api/discussions/${testThreadId}/replies`)
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: ''
        });
      
      expect(res.statusCode).toEqual(400);
    });

    it('should fail for non-existent thread', async () => {
      const res = await request(app)
        .post('/api/discussions/9999/replies')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: 'Test reply'
        });
      
      expect(res.statusCode).toEqual(404);
    });
  });

  describe('GET /api/discussions', () => {
    it('should list discussion threads', async () => {
      const res = await request(app)
        .get('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.threads)).toBeTruthy();
      expect(res.body.threads.some(t => t.id === testThreadId)).toBeTruthy();
    });

    it('should include reply counts', async () => {
      const res = await request(app)
        .get('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`);
      
      const thread = res.body.threads.find(t => t.id === testThreadId);
      expect(thread.reply_count).toBeGreaterThanOrEqual(1);
    });
  });

  describe('GET /api/discussions/{threadId}', () => {
    it('should get thread with replies', async () => {
      const res = await request(app)
        .get(`/api/discussions/${testThreadId}`)
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body.mainThread.id).toEqual(testThreadId);
      expect(Array.isArray(res.body.replies)).toBeTruthy();
      expect(res.body.replies.some(r => r.id === testReplyId)).toBeTruthy();
    });

    it('should fail for non-existent thread', async () => {
      const res = await request(app)
        .get('/api/discussions/9999')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(404);
    });
  });

  describe('Admin Discussion Management', () => {
    describe('DELETE /api/discussions/{threadId}', () => {
      it('should delete thread as admin', async () => {
        // Create a new thread to delete
        const createRes = await request(app)
          .post('/api/discussions')
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Thread to delete',
            content: 'Content'
          });
        
        const res = await request(app)
          .delete(`/api/discussions/${createRes.body.id}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .delete(`/api/discussions/${testThreadId}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('DELETE /api/discussions/replies/{replyId}', () => {
      it('should delete reply as admin', async () => {
        const res = await request(app)
          .delete(`/api/discussions/replies/${testReplyId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        // Create a new reply to try deleting
        const createRes = await request(app)
          .post(`/api/discussions/${testThreadId}/replies`)
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            content: 'Test reply to delete'
          });
        
        const res = await request(app)
          .delete(`/api/discussions/replies/${createRes.body.id}`)
          .set('Authorization', `Bearer ${member2Token}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });
});

================
File: backend/test/integration/events.test.js
================
const request = require('supertest');
const app = require('../../../backend/src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');
const { sequelize } = require('../../../backend/models');

describe('Event API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let testEventId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;

    memberToken = await createAndApproveUser( {name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!'}, adminToken);
    expect(memberToken).toBeDefined();
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('GET /events', () => {
    beforeAll(async () => {
      // Create a test event
      const res = await request(app)
        .post('/api/events')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          title: 'Test Event',
          description: 'This is a test event',
          event_date: '2025-12-31T18:00:00Z',
          location: 'Test Location'
        });
      testEventId = res.body.id;
    });

    it('should list upcoming events for member', async () => {
      const res = await request(app)
        .get('/api/events?status=upcoming')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should list events for admin', async () => {
      const res = await request(app)
        .get('/api/events')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should filter past events', async () => {
      const queryInterface = sequelize.getQueryInterface();
      await queryInterface.bulkInsert('events', [{
        title: 'Past Event',
        description: 'This is a past event',
        start_date: new Date('2020-01-01T18:00:00Z'), // Use start_date for the column name
        end_date: new Date('2020-01-01T19:00:00Z'),   // Use end_date
        location: 'Past Location',
        created_by: 1, // Assuming admin user ID is 1
        created_at: new Date(),
        updated_at: new Date(),
      }]);

      const res = await request(app)
        .get('/api/events?status=past')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body.data.some(e => e.title === 'Past Event')).toBeTruthy();
    });
  });

  describe('Admin Event Management', () => {
    describe('POST /events', () => {
      it('should create event as admin', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'New Event',
            description: 'Important event',
            event_date: '2025-12-31T18:00:00Z',
            location: 'Event Location'
          });
        
        expect(res.statusCode).toEqual(201);
        expect(res.body.title).toEqual('New Event');
      });

      it('should fail with missing required fields', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            description: 'Missing title'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail with past event date', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'Past Event',
            description: 'Should fail',
            event_date: '2020-01-01T00:00:00Z',
            location: 'Past'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized',
            description: 'Should fail'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('PUT /events/{id}', () => {
      it('should update event as admin', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'Updated Event',
            description: 'Updated content'
          });
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.title).toEqual('Updated Event');
      });

      it('should fail with end_date before start_date', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            start_date: '2025-12-31T18:00:00Z',
            end_date: '2025-12-30T18:00:00Z'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized Update'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('DELETE /events/{id}', () => {
      it('should delete event as admin', async () => {
        const res = await request(app)
          .delete(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        // First create a new event to delete
        const createRes = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'To Delete',
            description: 'Will try to delete',
            event_date: '2025-12-31T18:00:00Z',
            location: 'Test'
          });
        
        const res = await request(app)
          .delete(`/api/events/${createRes.body.id}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });
});

================
File: backend/test/seeders/test-seed.js
================
'use strict';
const bcrypt = require('bcrypt');

module.exports = {
  async up(queryInterface, Sequelize) {
    // Test admin user
    await queryInterface.bulkInsert('users', [{
      name: 'Test Admin',
      email: 'testadmin@example.com',
      password: await bcrypt.hash('testadmin123', 10),
      role: 'admin',
      status: 'approved',
      email_verified: true,
      created_at: new Date(),
      updated_at: new Date()
    }], {});

    // Test member users with different statuses
    await queryInterface.bulkInsert('users', [
      {
        name: 'Active Member',
        email: 'active@example.com',
        password: await bcrypt.hash('member123', 10),
        role: 'member',
        status: 'approved',
        email_verified: true,
        created_at: new Date(),
        updated_at: new Date()
      },
      {
        name: 'Pending Member',
        email: 'pending@example.com',
        password: await bcrypt.hash('member123', 10),
        role: 'member',
        status: 'pending',
        email_verified: false,
        created_at: new Date(),
        updated_at: new Date()
      },
      {
        name: 'Rejected Member',
        email: 'rejected@example.com',
        password: await bcrypt.hash('member123', 10),
        role: 'member',
        status: 'rejected',
        email_verified: false,
        created_at: new Date(),
        updated_at: new Date()
      }
    ], {});

    // Basic site configuration
    await queryInterface.bulkInsert('config', [
      {
        key: 'hoa_name',
        value: 'Test HOA'
      },
      {
        key: 'hoa_description',
        value: 'Test HOA Description'
      }
      // You could add hoa_logo here too if needed for other tests
    ], {});
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.bulkDelete('users', {
      email: [
        'testadmin@example.com',
        'active@example.com',
        'pending@example.com',
        'rejected@example.com'
      ]
    }, {});

    await queryInterface.bulkDelete('config', {
      key: ['hoa_name', 'hoa_description']
    }, {});
  }
};

================
File: backend/test/utils/dbHelpers.js
================
const request = require('supertest');
const app = require('../../src/app');
const { execSync } = require('child_process');
const path = require('path');

const run = (command) => {
  try {
    execSync(command, {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit',
    });
  } catch (error) {
    console.error(`Failed to execute command: ${command}`, error);
    throw error;
  }
};

const setupTestDB = () => {
  console.log('--- Setting up test database ---');
  // Run migrations to create the tables
  run('NODE_ENV=test npx sequelize-cli db:migrate');
  // Run seeders to populate the tables
  run('NODE_ENV=test npx sequelize-cli db:seed:all --seeders-path test/seeders');
  console.log('--- Test database setup complete ---');
};

const teardownTestDB = () => {
  console.log('--- Tearing down test database ---');
  // Undo all migrations to leave a clean state
  run('NODE_ENV=test npx sequelize-cli db:migrate:undo:all');
  console.log('--- Test database teardown complete ---');
};

const seedTestDB = () => {
  try {
    execSync('NODE_ENV=test npm run db:seed:test', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
  } catch (error) {
    console.error('Failed to seed test database:', error);
    throw error;
  }
};

const cleanTestDB = () => {
  try {
    execSync('NODE_ENV=test npm run db:seed:undo:test:all', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
  } catch (error) {
    console.error('Failed to clean test database:', error);
    throw error;
  }
};

const resetTestDB = async () => {
  try {
    execSync('NODE_ENV=test npm run db:migrate:undo:all', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
    execSync('NODE_ENV=test npm run db:migrate', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
    execSync('NODE_ENV=test npm run db:seed:undotest:all', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
  } catch (error) {
    console.error('Failed to reset test database:', error);
    throw error;
  }
};

/**
 * Creates a new user, approves them with an admin token, and returns the new user's token.
 * @param {object} userDetails - The user's details { name, email, password }.
 * @param {string} adminToken - A valid admin JWT for approving the user.
 * @returns {Promise<string>} The JWT for the newly created and approved user.
 */
const createAndApproveUser = async (userDetails, adminToken) => {
  // 1. Register the user
  const registerRes = await request(app)
    .post('/api/auth/register')
    .send(userDetails);
  
  // A simple check to ensure registration worked before proceeding
  if (registerRes.statusCode !== 201) {
    console.error('Failed to register user in helper:', registerRes.body);
    throw new Error(`User registration failed for ${userDetails.email}`);
  }
  const newUserId = registerRes.body.user.id;

  // 2. Approve the user
  const approvalRes = await request(app)
    .put(`/api/admin/users/${newUserId}/status`)
    .set('Authorization', `Bearer ${adminToken}`)
    .send({ status: 'approved' });

  if (approvalRes.statusCode !== 200) {
    console.error('Failed to approve user in helper:', approvalRes.body);
    throw new Error(`User approval failed for ${userDetails.email}`);
  }

  // 3. Log the user in
  const loginRes = await request(app)
    .post('/api/auth/login')
    .send({
      email: userDetails.email,
      password: userDetails.password,
    });
  
  if (loginRes.statusCode !== 200) {
    console.error('Failed to log in new user in helper:', loginRes.body);
    throw new Error(`User login failed for ${userDetails.email}`);
  }

  // 4. Return the token
  return loginRes.body.token;
};

const createAndApproveUserForUserManagement = async (userDetails, adminToken) => {
  // 1. Register the user
  const registerRes = await request(app)
    .post('/api/auth/register')
    .send(userDetails);
  
  if (registerRes.statusCode !== 201) {
    console.error('Failed to register user in helper:', registerRes.body);
    throw new Error(`User registration failed for ${userDetails.email}`);
  }
  const newUserId = registerRes.body.user.id;

  // 2. Approve the user
  const approvalRes = await request(app)
    .put(`/api/admin/users/${newUserId}/status`)
    .set('Authorization', `Bearer ${adminToken}`)
    .send({ status: 'approved' });

  if (approvalRes.statusCode !== 200) {
    console.error('Failed to approve user in helper:', approvalRes.body);
    throw new Error(`User approval failed for ${userDetails.email}`);
  }

  // 3. Log the user in
  const loginRes = await request(app)
    .post('/api/auth/login')
    .send({
      email: userDetails.email,
      password: userDetails.password,
    });
  
  if (loginRes.statusCode !== 200) {
    console.error('Failed to log in new user in helper:', loginRes.body);
    throw new Error(`User login failed for ${userDetails.email}`);
  }

  // 4. Return both the token and the user object
  return { token: loginRes.body.token, user: loginRes.body.user };
};

module.exports = {
  seedTestDB,
  cleanTestDB, 
  resetTestDB,
  setupTestDB,
  teardownTestDB,
  createAndApproveUser,
  createAndApproveUserForUserManagement,
};

================
File: backend/test/utils/testSetup.js
================
const { execSync } = require('child_process');
const path = require('path');

module.exports = async () => {
  // Setup test database
  try {
    execSync('npm run db:migrate:undo:all', { 
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
    execSync('npm run db:migrate', {
      cwd: path.join(__dirname, '../../'), 
      stdio: 'inherit'
    });
    execSync('npm run db:seed:undo:test:all', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'  
    });
    execSync('npm run db:seed:test', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
  } catch (error) {
    console.error('Test setup failed:', error);
    process.exit(1);
  }
};

================
File: backend/package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "test:integration": "jest --runInBand --bail --testPathPattern=integration/",
    "test:debugging": "jest --runInBand --bail --testPathPattern=good/",
    "test:watch": "jest --watch",
    "start": "node src/app.js",
    "db:migrate": "npx sequelize-cli db:migrate",
    "db:migrate:undo:all": "npx sequelize-cli db:migrate:undo:all",
    "db:seed": "npx sequelize-cli db:seed:all",
    "db:seed:undo:all": "npx sequelize-cli db:seed:undo:all",
    "db:seed:test": "npx sequelize-cli db:seed:all --seeders-path test/seeders",
    "db:seed:undo:test:all": "npx sequelize-cli db:seed:undo:all --seeders-path test/seeders"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^6.0.0",
    "cors": "^2.8.5",
    "dompurify": "^3.2.6",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "express-validator": "^7.0.1",
    "http-status": "^1.5.0",
    "joi": "^17.13.3",
    "jsdom": "^26.1.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.0",
    "sequelize": "^6.37.7",
    "sqlite3": "^5.1.7"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "nodemon": "^3.1.10",
    "sequelize-cli": "^6.6.3",
    "supertest": "^7.1.1"
  }
}

================
File: deploy/nginx/hoa-management.conf
================
# HOA Management System - Production Nginx Configuration
# Place this file in /etc/nginx/sites-available/ and create symlink in sites-enabled/

# Rate limiting zones
limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
limit_req_zone $binary_remote_addr zone=login:10m rate=5r/m;
limit_req_zone $binary_remote_addr zone=upload:10m rate=2r/m;

# Upstream backend servers
upstream backend_api {
    server 127.0.0.1:3001;
    keepalive 32;
}

upstream frontend_app {
    server 127.0.0.1:3000;
    keepalive 32;
}

# HTTP to HTTPS redirect
server {
    listen 80;
    listen [::]:80;
    server_name your-domain.com www.your-domain.com;
    
    # Let's Encrypt challenge
    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }
    
    # Redirect all HTTP traffic to HTTPS
    location / {
        return 301 https://$server_name$request_uri;
    }
}

# Main HTTPS server
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name your-domain.com www.your-domain.com;
    
    # SSL Configuration (managed by Certbot)
    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self'; frame-ancestors 'self';" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;
    
    # Remove server signature
    server_tokens off;
    
    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;
    
    # Client settings
    client_max_body_size 10M;
    client_body_timeout 60s;
    client_header_timeout 60s;
    
    # Logging
    access_log /var/log/nginx/hoa-management-access.log;
    error_log /var/log/nginx/hoa-management-error.log;
    
    # API routes with rate limiting
    location /api/ {
        # Rate limiting
        limit_req zone=api burst=20 nodelay;
        
        # CORS headers
        add_header Access-Control-Allow-Origin "https://your-domain.com" always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept" always;
        add_header Access-Control-Allow-Credentials "true" always;
        
        # Handle preflight requests
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin "https://your-domain.com";
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept";
            add_header Access-Control-Allow-Credentials "true";
            add_header Access-Control-Max-Age 1728000;
            add_header Content-Type "text/plain charset=UTF-8";
            add_header Content-Length 0;
            return 204;
        }
        
        # Proxy to backend
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    
    # Login endpoint with stricter rate limiting
    location /api/auth/login {
        limit_req zone=login burst=3 nodelay;
        
        # CORS headers
        add_header Access-Control-Allow-Origin "https://your-domain.com" always;
        add_header Access-Control-Allow-Methods "POST, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept" always;
        add_header Access-Control-Allow-Credentials "true" always;
        
        # Handle preflight requests
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin "https://your-domain.com";
            add_header Access-Control-Allow-Methods "POST, OPTIONS";
            add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept";
            add_header Access-Control-Allow-Credentials "true";
            add_header Access-Control-Max-Age 1728000;
            add_header Content-Type "text/plain charset=UTF-8";
            add_header Content-Length 0;
            return 204;
        }
        
        # Proxy to backend
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # File upload endpoints with rate limiting
    location ~ ^/api/(admin/documents|documents)/upload {
        limit_req zone=upload burst=1 nodelay;
        
        # Increase body size for file uploads
        client_max_body_size 10M;
        client_body_timeout 300s;
        
        # CORS headers
        add_header Access-Control-Allow-Origin "https://your-domain.com" always;
        add_header Access-Control-Allow-Methods "POST, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept" always;
        add_header Access-Control-Allow-Credentials "true" always;
        
        # Handle preflight requests
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin "https://your-domain.com";
            add_header Access-Control-Allow-Methods "POST, OPTIONS";
            add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept";
            add_header Access-Control-Allow-Credentials "true";
            add_header Access-Control-Max-Age 1728000;
            add_header Content-Type "text/plain charset=UTF-8";
            add_header Content-Length 0;
            return 204;
        }
        
        # Proxy to backend
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Extended timeouts for file uploads
        proxy_connect_timeout 300s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
    }
    
    # Static file downloads with caching
    location /api/documents/download/ {
        # CORS headers
        add_header Access-Control-Allow-Origin "https://your-domain.com" always;
        add_header Access-Control-Allow-Methods "GET, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept" always;
        add_header Access-Control-Allow-Credentials "true" always;
        
        # Caching for downloaded files
        expires 1h;
        add_header Cache-Control "public, immutable";
        
        # Proxy to backend
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # Health check endpoint (no rate limiting)
    location /api/health {
        access_log off;
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # Frontend application
    location / {
        # Try files first, then fallback to index.html for SPA routing
        try_files $uri $uri/ @frontend;
        
        # Static file caching
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            add_header Vary "Accept-Encoding";
            
            # Proxy to frontend
            proxy_pass http://frontend_app;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
    
    # Frontend fallback for SPA routing
    location @frontend {
        proxy_pass http://frontend_app;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # No caching for HTML files
        add_header Cache-Control "no-cache, no-store, must-revalidate";
        add_header Pragma "no-cache";
        add_header Expires "0";
    }
    
    # Security: Block access to sensitive files
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    location ~ ~$ {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    # Block common exploit attempts
    location ~* (wp-admin|wp-login|xmlrpc|phpmyadmin) {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    # Robots.txt
    location = /robots.txt {
        add_header Content-Type text/plain;
        return 200 "User-agent: *\nDisallow: /api/\nDisallow: /admin/\n";
    }
    
    # Favicon
    location = /favicon.ico {
        proxy_pass http://frontend_app;
        expires 1y;
        add_header Cache-Control "public, immutable";
        access_log off;
    }
}

# Additional security server block to handle non-matching hosts
server {
    listen 443 ssl http2 default_server;
    listen [::]:443 ssl http2 default_server;
    server_name _;
    
    # Use a self-signed certificate for default server
    ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
    ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
    
    # Return 444 (connection closed without response)
    return 444;
}

================
File: deploy/deploy.sh
================
#!/bin/bash

# HOA Management System - Production Deployment Script
# Usage: ./deploy.sh domain.com email@example.com

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}"
    exit 1
}

info() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] INFO: $1${NC}"
}

# Check arguments
if [ $# -ne 2 ]; then
    error "Usage: $0 <domain> <email>"
    echo "Example: $0 hoa.example.com admin@example.com"
    exit 1
fi

DOMAIN=$1
EMAIL=$2
APP_DIR="/opt/hoa-management"

# Validate domain format
if [[ ! $DOMAIN =~ ^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]\.[a-zA-Z]{2,}$ ]]; then
    error "Invalid domain format: $DOMAIN"
fi

# Validate email format
if [[ ! $EMAIL =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$ ]]; then
    error "Invalid email format: $EMAIL"
fi

log "Starting deployment for domain: $DOMAIN"

# Check if running from correct directory
if [ ! -f "deploy.sh" ]; then
    error "This script must be run from the /opt/hoa-management directory"
fi

# Check if required files exist
REQUIRED_FILES=(
    "docker-compose.prod.yml"
    ".env"
    "deploy/nginx/hoa-management.conf"
    "backend/Dockerfile"
    "frontend/Dockerfile"
)

for file in "${REQUIRED_FILES[@]}"; do
    if [ ! -f "$file" ]; then
        error "Required file not found: $file"
    fi
done

# Check if Docker is running
if ! docker info >/dev/null 2>&1; then
    error "Docker is not running. Please start Docker first."
fi

# Check if ports are available
if netstat -tuln | grep -q ":80 "; then
    warn "Port 80 is already in use. This might interfere with nginx."
fi

if netstat -tuln | grep -q ":443 "; then
    warn "Port 443 is already in use. This might interfere with nginx."
fi

# Backup existing configuration if it exists
if [ -f "/etc/nginx/sites-enabled/hoa-management.conf" ]; then
    log "Backing up existing nginx configuration..."
    sudo cp /etc/nginx/sites-enabled/hoa-management.conf /etc/nginx/sites-enabled/hoa-management.conf.backup.$(date +%Y%m%d_%H%M%S)
fi

# Update nginx configuration with domain
log "Configuring nginx for domain: $DOMAIN"
sudo cp deploy/nginx/hoa-management.conf /etc/nginx/sites-available/hoa-management.conf
sudo sed -i "s/your-domain.com/$DOMAIN/g" /etc/nginx/sites-available/hoa-management.conf

# Create symlink if it doesn't exist
if [ ! -L "/etc/nginx/sites-enabled/hoa-management.conf" ]; then
    sudo ln -s /etc/nginx/sites-available/hoa-management.conf /etc/nginx/sites-enabled/hoa-management.conf
fi

# Remove default nginx site if it exists
if [ -L "/etc/nginx/sites-enabled/default" ]; then
    sudo rm /etc/nginx/sites-enabled/default
fi

# Test nginx configuration
log "Testing nginx configuration..."
if ! sudo nginx -t; then
    error "Nginx configuration test failed. Please check the configuration."
fi

# Update environment file with domain
log "Updating environment configuration..."
sed -i "s/DOMAIN=.*/DOMAIN=$DOMAIN/" .env

# Generate strong JWT secret if not already set
if grep -q "your-super-secret-jwt-key-change-this-in-production" .env; then
    log "Generating secure JWT secret..."
    JWT_SECRET=$(openssl rand -base64 32)
    sed -i "s/JWT_SECRET=.*/JWT_SECRET=$JWT_SECRET/" .env
fi

# Generate session secret if not already set
if grep -q "your-session-secret-change-this-in-production" .env; then
    log "Generating secure session secret..."
    SESSION_SECRET=$(openssl rand -base64 32)
    sed -i "s/SESSION_SECRET=.*/SESSION_SECRET=$SESSION_SECRET/" .env
fi

# Create necessary directories
log "Creating necessary directories..."
sudo mkdir -p /var/log/nginx
sudo mkdir -p /var/log/hoa-management
sudo chown $USER:$USER /var/log/hoa-management

# Create self-signed certificate for default server block
if [ ! -f "/etc/ssl/certs/nginx-selfsigned.crt" ]; then
    log "Creating self-signed certificate for default server..."
    sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
        -keyout /etc/ssl/private/nginx-selfsigned.key \
        -out /etc/ssl/certs/nginx-selfsigned.crt \
        -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost"
fi

# Start nginx
log "Starting nginx..."
sudo systemctl enable nginx
sudo systemctl start nginx

# Wait for nginx to start
sleep 5

# Build and start application containers
log "Building and starting application containers..."
docker-compose -f docker-compose.prod.yml down --remove-orphans
docker-compose -f docker-compose.prod.yml build --no-cache
docker-compose -f docker-compose.prod.yml up -d

# Wait for containers to start
log "Waiting for containers to start..."
sleep 30

# Check if containers are running
if ! docker-compose -f docker-compose.prod.yml ps | grep -q "Up"; then
    error "Containers failed to start. Check logs with: docker-compose -f docker-compose.prod.yml logs"
fi

# Test backend health
log "Testing backend health..."
for i in {1..10}; do
    if curl -f -s http://localhost:3001/api/health >/dev/null; then
        log "Backend is healthy"
        break
    fi
    if [ $i -eq 10 ]; then
        error "Backend health check failed after 10 attempts"
    fi
    sleep 5
done

# Test frontend
log "Testing frontend..."
for i in {1..10}; do
    if curl -f -s http://localhost:3000 >/dev/null; then
        log "Frontend is responding"
        break
    fi
    if [ $i -eq 10 ]; then
        error "Frontend health check failed after 10 attempts"
    fi
    sleep 5
done

# Reload nginx to pick up the application
sudo systemctl reload nginx

# Test HTTP access
log "Testing HTTP access..."
if curl -f -s http://$DOMAIN >/dev/null; then
    log "HTTP access successful"
else
    warn "HTTP access test failed. This might be normal if DNS is not yet propagated."
fi

# Obtain SSL certificate
log "Obtaining SSL certificate from Let's Encrypt..."
if sudo certbot --nginx -d $DOMAIN --email $EMAIL --agree-tos --non-interactive --redirect; then
    log "SSL certificate obtained successfully"
else
    warn "SSL certificate generation failed. You may need to:"
    echo "  1. Ensure DNS is properly configured"
    echo "  2. Check firewall settings"
    echo "  3. Run certbot manually: sudo certbot --nginx -d $DOMAIN"
fi

# Test HTTPS access
log "Testing HTTPS access..."
sleep 10
if curl -f -s https://$DOMAIN >/dev/null; then
    log "HTTPS access successful"
else
    warn "HTTPS access test failed. SSL certificate might still be propagating."
fi

# Enable and start systemd service
log "Configuring systemd service..."
sudo systemctl daemon-reload
sudo systemctl enable hoa-management
sudo systemctl start hoa-management

# Setup log rotation
log "Configuring log rotation..."
sudo tee /etc/logrotate.d/hoa-management > /dev/null <<EOF
/var/log/hoa-management/*.log {
    daily
    missingok
    rotate 30
    compress
    delaycompress
    notifempty
    create 644 $USER $USER
    postrotate
        docker-compose -f $APP_DIR/docker-compose.prod.yml restart >/dev/null 2>&1 || true
    endscript
}

/var/log/nginx/hoa-management-*.log {
    daily
    missingok
    rotate 30
    compress
    delaycompress
    notifempty
    create 644 www-data www-data
    postrotate
        systemctl reload nginx >/dev/null 2>&1 || true
    endscript
}
EOF

# Create monitoring script
log "Setting up monitoring..."
tee /opt/hoa-management/monitor.sh > /dev/null <<'EOF'
#!/bin/bash

# HOA Management System Monitoring Script

LOG_FILE="/var/log/hoa-management/monitor.log"
APP_DIR="/opt/hoa-management"

echo "$(date): Starting system monitoring..." >> $LOG_FILE

# Check container health
if ! docker-compose -f $APP_DIR/docker-compose.prod.yml ps | grep -q "Up"; then
    echo "$(date): ERROR - Containers are not running" >> $LOG_FILE
    # Restart containers
    docker-compose -f $APP_DIR/docker-compose.prod.yml restart >> $LOG_FILE 2>&1
fi

# Check backend API
if ! curl -f -s http://localhost:3001/api/health > /dev/null; then
    echo "$(date): ERROR - Backend API not responding" >> $LOG_FILE
    # Restart backend container
    docker-compose -f $APP_DIR/docker-compose.prod.yml restart backend >> $LOG_FILE 2>&1
fi

# Check frontend
if ! curl -f -s http://localhost:3000 > /dev/null; then
    echo "$(date): ERROR - Frontend not responding" >> $LOG_FILE
    # Restart frontend container
    docker-compose -f $APP_DIR/docker-compose.prod.yml restart frontend >> $LOG_FILE 2>&1
fi

# Check nginx
if ! systemctl is-active --quiet nginx; then
    echo "$(date): ERROR - Nginx is not running" >> $LOG_FILE
    sudo systemctl restart nginx >> $LOG_FILE 2>&1
fi

# Check disk space
DISK_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
if [ $DISK_USAGE -gt 85 ]; then
    echo "$(date): WARNING - Disk usage is at ${DISK_USAGE}%" >> $LOG_FILE
fi

# Check memory usage
MEMORY_USAGE=$(free | awk 'NR==2{printf "%.0f", $3*100/$2}')
if [ $MEMORY_USAGE -gt 85 ]; then
    echo "$(date): WARNING - Memory usage is at ${MEMORY_USAGE}%" >> $LOG_FILE
fi

echo "$(date): Monitoring check completed" >> $LOG_FILE
EOF

chmod +x /opt/hoa-management/monitor.sh

# Setup cron job for monitoring
(crontab -l 2>/dev/null | grep -v "monitor.sh"; echo "*/5 * * * * /opt/hoa-management/monitor.sh") | crontab -

# Final health check
log "Performing final health check..."
sleep 10

# Check all services
SERVICES_OK=true

if ! systemctl is-active --quiet nginx; then
    error "Nginx is not running"
    SERVICES_OK=false
fi

if ! docker-compose -f docker-compose.prod.yml ps | grep -q "Up"; then
    error "Application containers are not running"
    SERVICES_OK=false
fi

if ! curl -f -s http://localhost:3001/api/health >/dev/null; then
    error "Backend API is not responding"
    SERVICES_OK=false
fi

if ! curl -f -s http://localhost:3000 >/dev/null; then
    error "Frontend is not responding"
    SERVICES_OK=false
fi

if [ "$SERVICES_OK" = true ]; then
    log "All services are running successfully!"
else
    error "Some services are not running properly. Check the logs for details."
fi

# Display deployment summary
echo ""
echo -e "${BLUE}=== Deployment Summary ===${NC}"
echo "Domain: $DOMAIN"
echo "Email: $EMAIL"
echo "Application Directory: $APP_DIR"
echo ""
echo -e "${BLUE}=== Service Status ===${NC}"
echo "Nginx: $(systemctl is-active nginx)"
echo "Docker Containers: $(docker-compose -f docker-compose.prod.yml ps --services | wc -l) running"
echo ""
echo -e "${BLUE}=== Access URLs ===${NC}"
echo "Frontend: https://$DOMAIN"
echo "API: https://$DOMAIN/api"
echo "Public Documents: https://$DOMAIN/public"
echo ""
echo -e "${BLUE}=== Log Locations ===${NC}"
echo "Application Logs: docker-compose -f docker-compose.prod.yml logs"
echo "Nginx Access Log: /var/log/nginx/hoa-management-access.log"
echo "Nginx Error Log: /var/log/nginx/hoa-management-error.log"
echo "System Log: /var/log/hoa-management/"
echo ""
echo -e "${BLUE}=== Management Commands ===${NC}"
echo "Restart Application: sudo systemctl restart hoa-management"
echo "View Logs: docker-compose -f docker-compose.prod.yml logs -f"
echo "Update SSL: sudo certbot renew"
echo "Backup: ./backup.sh"
echo ""
echo -e "${GREEN}Deployment completed successfully!${NC}"
echo -e "${GREEN}Your HOA Management System is now available at: https://$DOMAIN${NC}"

================
File: deploy/DEPLOYMENT_GUIDE.md
================
# Linode Ubuntu 24.04 Deployment Guide - HOA Management System

This guide provides step-by-step instructions for deploying the HOA Management System on a Linode Ubuntu 24.04 server using Docker.

##  **Deployment Overview**

**Architecture:**
- **Reverse Proxy**: Nginx (handles SSL, routing, static files)
- **Application**: Docker Compose (frontend + backend containers)
- **Database**: SQLite (persistent volume)
- **SSL**: Let's Encrypt via Certbot
- **Process Management**: systemd services

**Server Requirements:**
- Ubuntu 24.04 LTS
- Minimum 2GB RAM, 2 CPU cores
- 20GB+ storage
- Domain name pointing to server IP
- Ports 80, 443, 22 open

##  **Pre-Deployment Checklist**

- [ ] Linode server created with Ubuntu 24.04
- [ ] Domain name configured (A record pointing to server IP)
- [ ] SSH access configured
- [ ] Server firewall configured
- [ ] SSL certificate requirements understood

##  **Deployment Steps**

### **Step 1: Initial Server Setup**

```bash
# Connect to your server
ssh root@your-server-ip

# Run the server setup script
curl -fsSL https://raw.githubusercontent.com/your-repo/hoa-management/main/deploy/setup-server.sh | bash
```

### **Step 2: Deploy Application**

```bash
# Run the deployment script
./deploy/deploy.sh your-domain.com your-email@example.com
```

### **Step 3: Configure SSL**

```bash
# SSL will be automatically configured during deployment
# Verify SSL is working
curl -I https://your-domain.com
```

### **Step 4: Verify Deployment**

```bash
# Check all services are running
sudo systemctl status hoa-management
sudo docker-compose ps

# Test application endpoints
curl https://your-domain.com/api/health
curl https://your-domain.com/
```

##  **Manual Deployment (Alternative)**

If you prefer manual deployment, follow these steps:

### **1. Server Preparation**
```bash
# Update system
sudo apt update && sudo apt upgrade -y

# Install required packages
sudo apt install -y curl wget git ufw nginx certbot python3-certbot-nginx

# Install Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker $USER

# Install Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
```

### **2. Firewall Configuration**
```bash
# Configure UFW
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow ssh
sudo ufw allow 'Nginx Full'
sudo ufw --force enable
```

### **3. Application Deployment**
```bash
# Create application directory
sudo mkdir -p /opt/hoa-management
sudo chown $USER:$USER /opt/hoa-management
cd /opt/hoa-management

# Clone repository (or upload files via SFTP)
git clone https://github.com/your-repo/hoa-management.git .

# Create production environment file
cp deploy/production.env .env
# Edit .env with your production values

# Build and start containers
docker-compose -f docker-compose.prod.yml up -d --build
```

### **4. Nginx Configuration**
```bash
# Copy nginx configuration
sudo cp deploy/nginx/hoa-management.conf /etc/nginx/sites-available/
sudo ln -s /etc/nginx/sites-available/hoa-management.conf /etc/nginx/sites-enabled/

# Update domain in nginx config
sudo sed -i 's/your-domain.com/actual-domain.com/g' /etc/nginx/sites-enabled/hoa-management.conf

# Test and reload nginx
sudo nginx -t
sudo systemctl reload nginx
```

### **5. SSL Certificate**
```bash
# Obtain SSL certificate
sudo certbot --nginx -d your-domain.com

# Verify auto-renewal
sudo certbot renew --dry-run
```

##  **File Structure on Server**

```
/opt/hoa-management/
 backend/
 frontend/
 deploy/
 docker-compose.prod.yml
 .env
 nginx.conf
 logs/
     nginx/
     backend/
     frontend/
```

##  **Monitoring and Maintenance**

### **Service Management**
```bash
# Check application status
sudo systemctl status hoa-management
docker-compose ps

# View logs
docker-compose logs -f
sudo tail -f /var/log/nginx/access.log
sudo tail -f /var/log/nginx/error.log

# Restart services
sudo systemctl restart hoa-management
docker-compose restart
```

### **Updates**
```bash
# Update application
cd /opt/hoa-management
git pull origin main
docker-compose down
docker-compose up -d --build

# Update system packages
sudo apt update && sudo apt upgrade -y
```

### **Backups**
```bash
# Backup database
docker-compose exec backend cp /usr/src/app/backend/database/hoa.db /usr/src/app/backend/database/hoa.db.backup

# Backup uploads
tar -czf /opt/backups/uploads-$(date +%Y%m%d).tar.gz /opt/hoa-management/backend/uploads/

# Backup configuration
tar -czf /opt/backups/config-$(date +%Y%m%d).tar.gz /opt/hoa-management/.env /etc/nginx/sites-enabled/hoa-management.conf
```

##  **Security Considerations**

### **Server Security**
- SSH key authentication (disable password auth)
- Regular security updates
- Fail2ban for intrusion prevention
- Regular backups
- Monitor logs for suspicious activity

### **Application Security**
- Strong JWT secrets
- HTTPS only (HTTP redirects to HTTPS)
- Security headers configured in Nginx
- File upload restrictions
- Rate limiting

##  **Troubleshooting**

### **Common Issues**

#### **Port Already in Use**
```bash
# Check what's using port 80/443
sudo netstat -tlnp | grep :80
sudo netstat -tlnp | grep :443

# Stop conflicting services
sudo systemctl stop apache2  # if installed
```

#### **Docker Permission Issues**
```bash
# Add user to docker group
sudo usermod -aG docker $USER
# Logout and login again
```

#### **SSL Certificate Issues**
```bash
# Check certificate status
sudo certbot certificates

# Renew certificate manually
sudo certbot renew --force-renewal
```

#### **Application Not Starting**
```bash
# Check Docker logs
docker-compose logs backend
docker-compose logs frontend

# Check system resources
free -h
df -h
```

### **Log Locations**
- Application logs: `docker-compose logs`
- Nginx logs: `/var/log/nginx/`
- System logs: `journalctl -u hoa-management`
- Docker logs: `docker logs <container-name>`

##  **Support**

For deployment issues:
1. Check the troubleshooting section
2. Review logs for error messages
3. Verify all services are running
4. Check firewall and DNS configuration
5. Ensure domain is properly configured

---

*This deployment guide provides a production-ready setup for the HOA Management System on Linode Ubuntu 24.04 with Docker, Nginx, and SSL encryption.*

================
File: deploy/docker-compose.prod.yml
================
version: '3.8'

services:
  backend:
    build:
      context: ../backend
      dockerfile: Dockerfile
    container_name: hoa_backend_prod
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - PORT=${APP_PORT:-3001}
      - JWT_SECRET=${JWT_SECRET}
      - JWT_EXPIRES_IN=${JWT_EXPIRES_IN:-7d}
      - DB_PATH=/usr/src/app/backend/database/hoa.db
      - MAX_FILE_SIZE_MB=${MAX_FILE_SIZE_MB:-10}
    ports:
      - "127.0.0.1:${APP_PORT:-3001}:${APP_PORT:-3001}"
    volumes:
      - ../backend/database:/usr/src/app/backend/database
      - ../backend/uploads:/usr/src/app/backend/uploads
      - /var/log/hoa-management:/var/log/hoa-management
    networks:
      - hoa-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:${APP_PORT:-3001}/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  frontend:
    build:
      context: ../frontend
      dockerfile: Dockerfile
      args:
        - VITE_API_URL=https://${DOMAIN}/api
        - VITE_APP_NAME=HOA Management System
    container_name: hoa_frontend_prod
    restart: unless-stopped
    ports:
      - "127.0.0.1:${FRONTEND_PORT:-3000}:80"
    networks:
      - hoa-network
    depends_on:
      backend:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

networks:
  hoa-network:
    driver: bridge
    name: hoa-management-network

volumes:
  database_data:
    driver: local
  uploads_data:
    driver: local

================
File: deploy/production.env
================
# HOA Management System - Production Environment Configuration
# Copy this file to .env in the project root and update the values

# =============================================================================
# APPLICATION CONFIGURATION
# =============================================================================

# Node.js Environment
NODE_ENV=production

# Server Ports
APP_PORT=3001
FRONTEND_PORT=3000

# Domain Configuration (used for SSL and CORS)
DOMAIN=sandersoncreekhoa.com

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================

# SQLite Database Path (inside container)
DB_PATH=/usr/src/app/backend/database/hoa.db

# =============================================================================
# SECURITY CONFIGURATION
# =============================================================================

# JWT Configuration - CHANGE THESE IN PRODUCTION!
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production-min-32-chars
JWT_EXPIRES_IN=7d

# Session Configuration
SESSION_SECRET=your-session-secret-change-this-in-production

# =============================================================================
# FILE UPLOAD CONFIGURATION
# =============================================================================

# Maximum file size for uploads (in MB)
MAX_FILE_SIZE_MB=10

# Allowed file types (comma-separated)
ALLOWED_FILE_TYPES=pdf,doc,docx,txt,jpg,jpeg,png,gif

# Upload directory (inside container)
UPLOAD_DIR=/usr/src/app/backend/uploads

# =============================================================================
# EMAIL CONFIGURATION (Optional - for notifications)
# =============================================================================

# SMTP Configuration (uncomment and configure if needed)
# SMTP_HOST=smtp.gmail.com
# SMTP_PORT=587
# SMTP_SECURE=false
# SMTP_USER=your-email@gmail.com
# SMTP_PASS=your-app-password

# Email settings
# FROM_EMAIL=noreply@your-domain.com
# ADMIN_EMAIL=admin@your-domain.com

# =============================================================================
# LOGGING CONFIGURATION
# =============================================================================

# Log Level (error, warn, info, debug)
LOG_LEVEL=info

# Log Directory
LOG_DIR=/var/log/hoa-management

# =============================================================================
# CORS CONFIGURATION
# =============================================================================

# Allowed origins for CORS (comma-separated)
CORS_ORIGINS=https://your-domain.com,https://www.your-domain.com

# =============================================================================
# RATE LIMITING
# =============================================================================

# Rate limiting (requests per window)
RATE_LIMIT_REQUESTS=100
RATE_LIMIT_WINDOW_MS=900000

# =============================================================================
# SSL/TLS CONFIGURATION
# =============================================================================

# SSL Configuration (handled by nginx/certbot)
SSL_ENABLED=true
FORCE_HTTPS=true

# =============================================================================
# BACKUP CONFIGURATION
# =============================================================================

# Backup retention (days)
BACKUP_RETENTION_DAYS=30

# Backup directory
BACKUP_DIR=/opt/backups

# =============================================================================
# MONITORING CONFIGURATION
# =============================================================================

# Health check endpoints
HEALTH_CHECK_ENABLED=true

# Metrics collection
METRICS_ENABLED=false

# =============================================================================
# DEVELOPMENT/DEBUG (Set to false in production)
# =============================================================================

# Debug mode
DEBUG=false

# API Documentation (Swagger)
API_DOCS_ENABLED=false

# =============================================================================
# DOCKER CONFIGURATION
# =============================================================================

# Docker network name
DOCKER_NETWORK=hoa-management-network

# Container names
BACKEND_CONTAINER=hoa_backend_prod
FRONTEND_CONTAINER=hoa_frontend_prod

# =============================================================================
# NGINX CONFIGURATION
# =============================================================================

# Nginx configuration
NGINX_CLIENT_MAX_BODY_SIZE=10M
NGINX_WORKER_PROCESSES=auto
NGINX_WORKER_CONNECTIONS=1024

# =============================================================================
# SECURITY HEADERS
# =============================================================================

# Content Security Policy
CSP_ENABLED=true

# HSTS (HTTP Strict Transport Security)
HSTS_ENABLED=true
HSTS_MAX_AGE=31536000

# =============================================================================
# PERFORMANCE CONFIGURATION
# =============================================================================

# Gzip compression
GZIP_ENABLED=true

# Static file caching (seconds)
STATIC_CACHE_MAX_AGE=86400

# API response caching
API_CACHE_ENABLED=false

# =============================================================================
# TIMEZONE CONFIGURATION
# =============================================================================

# Application timezone
TZ=America/Denver

# =============================================================================
# FEATURE FLAGS
# =============================================================================

# Enable/disable features
FEATURE_PUBLIC_DOCUMENTS=true
FEATURE_EVENT_MANAGEMENT=true
FEATURE_USER_MANAGEMENT=true
FEATURE_FILE_UPLOADS=true

# =============================================================================
# MAINTENANCE MODE
# =============================================================================

# Maintenance mode (set to true to enable maintenance page)
MAINTENANCE_MODE=false
MAINTENANCE_MESSAGE="System is under maintenance. Please try again later."

# =============================================================================
# NOTES
# =============================================================================

# 1. Change all default secrets and passwords
# 2. Update DOMAIN with your actual domain name
# 3. Configure email settings if you want notifications
# 4. Adjust file upload limits based on your needs
# 5. Set appropriate log levels for production
# 6. Review and adjust rate limiting settings
# 7. Configure backup retention based on your requirements

================
File: deploy/setup-server.sh
================
#!/bin/bash

# HOA Management System - Server Setup Script
# For Ubuntu 24.04 LTS on Linode
# Usage: curl -fsSL https://raw.githubusercontent.com/your-repo/hoa-management/main/deploy/setup-server.sh | bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}"
    exit 1
}

# Check if running as root
if [[ $EUID -eq 0 ]]; then
    error "This script should not be run as root. Please run as a regular user with sudo privileges."
fi

# Check if sudo is available
if ! command -v sudo &> /dev/null; then
    error "sudo is required but not installed. Please install sudo first."
fi

log "Starting HOA Management System server setup on Ubuntu 24.04..."

# Update system packages
log "Updating system packages..."
sudo apt update && sudo apt upgrade -y

# Install essential packages
log "Installing essential packages..."
sudo apt install -y \
    curl \
    wget \
    git \
    unzip \
    software-properties-common \
    apt-transport-https \
    ca-certificates \
    gnupg \
    lsb-release \
    ufw \
    nginx \
    certbot \
    python3-certbot-nginx \
    htop \
    tree \
    vim \
    fail2ban

# Install Docker
log "Installing Docker..."
if ! command -v docker &> /dev/null; then
    # Add Docker's official GPG key
    sudo mkdir -p /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    
    # Add Docker repository
    echo \
        "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
        $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    # Install Docker Engine
    sudo apt update
    sudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    
    # Add current user to docker group
    sudo usermod -aG docker $USER
    
    log "Docker installed successfully"
else
    log "Docker is already installed"
fi

# Install Docker Compose (standalone)
log "Installing Docker Compose..."
if ! command -v docker-compose &> /dev/null; then
    DOCKER_COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep 'tag_name' | cut -d\" -f4)
    sudo curl -L "https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    sudo chmod +x /usr/local/bin/docker-compose
    log "Docker Compose installed successfully"
else
    log "Docker Compose is already installed"
fi

# Configure firewall
log "Configuring UFW firewall..."
sudo ufw --force reset
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow ssh
sudo ufw allow 'Nginx Full'
sudo ufw --force enable

log "Firewall configured successfully"

# Configure fail2ban
log "Configuring fail2ban..."
sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local

# Create custom fail2ban configuration
sudo tee /etc/fail2ban/jail.d/hoa-management.conf > /dev/null <<EOF
[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 3600
findtime = 600

[nginx-http-auth]
enabled = true
filter = nginx-http-auth
port = http,https
logpath = /var/log/nginx/error.log
maxretry = 5
bantime = 3600

[nginx-noscript]
enabled = true
port = http,https
filter = nginx-noscript
logpath = /var/log/nginx/access.log
maxretry = 6
bantime = 86400
findtime = 60

[nginx-badbots]
enabled = true
port = http,https
filter = nginx-badbots
logpath = /var/log/nginx/access.log
maxretry = 2
bantime = 86400
EOF

sudo systemctl enable fail2ban
sudo systemctl start fail2ban

log "fail2ban configured successfully"

# Create application directory
log "Creating application directory..."
sudo mkdir -p /opt/hoa-management
sudo chown $USER:$USER /opt/hoa-management

# Create backup directory
log "Creating backup directory..."
sudo mkdir -p /opt/backups
sudo chown $USER:$USER /opt/backups

# Create log directory
log "Creating log directory..."
sudo mkdir -p /var/log/hoa-management
sudo chown $USER:$USER /var/log/hoa-management

# Configure log rotation
log "Configuring log rotation..."
sudo tee /etc/logrotate.d/hoa-management > /dev/null <<EOF
/var/log/hoa-management/*.log {
    daily
    missingok
    rotate 52
    compress
    delaycompress
    notifempty
    create 644 $USER $USER
    postrotate
        systemctl reload hoa-management || true
    endscript
}
EOF

# Create systemd service for the application
log "Creating systemd service..."
sudo tee /etc/systemd/system/hoa-management.service > /dev/null <<EOF
[Unit]
Description=HOA Management System
Requires=docker.service
After=docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
WorkingDirectory=/opt/hoa-management
ExecStart=/usr/local/bin/docker-compose -f docker-compose.prod.yml up -d
ExecStop=/usr/local/bin/docker-compose -f docker-compose.prod.yml down
TimeoutStartSec=0
User=$USER
Group=$USER

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload

# Configure automatic security updates
log "Configuring automatic security updates..."
sudo apt install -y unattended-upgrades
echo 'Unattended-Upgrade::Automatic-Reboot "false";' | sudo tee -a /etc/apt/apt.conf.d/50unattended-upgrades

# Create deployment script
log "Creating deployment script..."
tee /opt/hoa-management/deploy.sh > /dev/null <<'EOF'
#!/bin/bash

# HOA Management System Deployment Script
# Usage: ./deploy.sh domain.com email@example.com

set -e

DOMAIN=$1
EMAIL=$2

if [ -z "$DOMAIN" ] || [ -z "$EMAIL" ]; then
    echo "Usage: $0 <domain> <email>"
    echo "Example: $0 hoa.example.com admin@example.com"
    exit 1
fi

echo "Deploying HOA Management System for domain: $DOMAIN"

# Update nginx configuration with domain
sed -i "s/your-domain.com/$DOMAIN/g" /etc/nginx/sites-available/hoa-management.conf

# Test nginx configuration
sudo nginx -t

# Reload nginx
sudo systemctl reload nginx

# Start application
sudo systemctl enable hoa-management
sudo systemctl start hoa-management

# Wait for application to start
sleep 30

# Obtain SSL certificate
sudo certbot --nginx -d $DOMAIN --email $EMAIL --agree-tos --non-interactive

echo "Deployment completed successfully!"
echo "Your application is available at: https://$DOMAIN"
EOF

chmod +x /opt/hoa-management/deploy.sh

# Create backup script
log "Creating backup script..."
tee /opt/hoa-management/backup.sh > /dev/null <<'EOF'
#!/bin/bash

# HOA Management System Backup Script

BACKUP_DIR="/opt/backups"
DATE=$(date +%Y%m%d_%H%M%S)
APP_DIR="/opt/hoa-management"

echo "Starting backup process..."

# Create backup directory for this date
mkdir -p "$BACKUP_DIR/$DATE"

# Backup database
echo "Backing up database..."
docker-compose -f $APP_DIR/docker-compose.prod.yml exec -T backend cp /usr/src/app/backend/database/hoa.db /usr/src/app/backend/database/hoa.db.backup
docker cp $(docker-compose -f $APP_DIR/docker-compose.prod.yml ps -q backend):/usr/src/app/backend/database/hoa.db.backup "$BACKUP_DIR/$DATE/database.db"

# Backup uploads
echo "Backing up uploads..."
tar -czf "$BACKUP_DIR/$DATE/uploads.tar.gz" -C "$APP_DIR" backend/uploads/

# Backup configuration
echo "Backing up configuration..."
cp "$APP_DIR/.env" "$BACKUP_DIR/$DATE/"
cp "/etc/nginx/sites-available/hoa-management.conf" "$BACKUP_DIR/$DATE/"

# Create archive of entire backup
echo "Creating backup archive..."
tar -czf "$BACKUP_DIR/hoa-backup-$DATE.tar.gz" -C "$BACKUP_DIR" "$DATE"

# Remove temporary directory
rm -rf "$BACKUP_DIR/$DATE"

# Keep only last 7 backups
find "$BACKUP_DIR" -name "hoa-backup-*.tar.gz" -type f -mtime +7 -delete

echo "Backup completed: $BACKUP_DIR/hoa-backup-$DATE.tar.gz"
EOF

chmod +x /opt/hoa-management/backup.sh

# Setup cron job for backups
log "Setting up automated backups..."
(crontab -l 2>/dev/null; echo "0 2 * * * /opt/hoa-management/backup.sh >> /var/log/hoa-management/backup.log 2>&1") | crontab -

# Create health check script
log "Creating health check script..."
tee /opt/hoa-management/health-check.sh > /dev/null <<'EOF'
#!/bin/bash

# HOA Management System Health Check Script

APP_DIR="/opt/hoa-management"
LOG_FILE="/var/log/hoa-management/health-check.log"

echo "$(date): Starting health check..." >> $LOG_FILE

# Check if containers are running
if ! docker-compose -f $APP_DIR/docker-compose.prod.yml ps | grep -q "Up"; then
    echo "$(date): ERROR - Containers are not running" >> $LOG_FILE
    # Restart the service
    sudo systemctl restart hoa-management
    echo "$(date): Restarted hoa-management service" >> $LOG_FILE
fi

# Check if application is responding
if ! curl -f -s http://localhost:3001/api/health > /dev/null; then
    echo "$(date): ERROR - Backend API not responding" >> $LOG_FILE
    # Restart the service
    sudo systemctl restart hoa-management
    echo "$(date): Restarted hoa-management service" >> $LOG_FILE
fi

echo "$(date): Health check completed" >> $LOG_FILE
EOF

chmod +x /opt/hoa-management/health-check.sh

# Setup cron job for health checks
(crontab -l 2>/dev/null; echo "*/5 * * * * /opt/hoa-management/health-check.sh") | crontab -

# Configure SSH security (if not already done)
log "Configuring SSH security..."
sudo sed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config
sudo sed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config
sudo sed -i 's/#PubkeyAuthentication yes/PubkeyAuthentication yes/' /etc/ssh/sshd_config

# Restart SSH service
sudo systemctl restart ssh

# Display system information
log "Server setup completed successfully!"
echo ""
echo -e "${BLUE}=== System Information ===${NC}"
echo "OS: $(lsb_release -d | cut -f2)"
echo "Kernel: $(uname -r)"
echo "Docker: $(docker --version)"
echo "Docker Compose: $(docker-compose --version)"
echo "Nginx: $(nginx -v 2>&1)"
echo ""
echo -e "${BLUE}=== Next Steps ===${NC}"
echo "1. Upload your application code to /opt/hoa-management/"
echo "2. Configure your .env file"
echo "3. Run the deployment script: ./deploy.sh your-domain.com your-email@example.com"
echo ""
echo -e "${BLUE}=== Important Notes ===${NC}"
echo "- You need to log out and log back in for Docker group membership to take effect"
echo "- Make sure your domain's A record points to this server's IP address"
echo "- The firewall is configured to allow SSH, HTTP, and HTTPS traffic only"
echo "- Automatic backups are scheduled daily at 2:00 AM"
echo "- Health checks run every 5 minutes"
echo ""
echo -e "${GREEN}Server setup completed successfully!${NC}"

================
File: frontend/.vite/deps/_metadata.json
================
{
  "hash": "494bc422",
  "configHash": "5477c98b",
  "lockfileHash": "d49109c0",
  "browserHash": "428a9bc4",
  "optimized": {},
  "chunks": {}
}

================
File: frontend/.vite/deps/package.json
================
{
  "type": "module"
}

================
File: frontend/public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: frontend/src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: frontend/src/components/admin/AdminDataTable.tsx
================
import React from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TableSortLabel,
  Paper,
  Box,
  Typography,
  Pagination,
  CircularProgress,
  Alert,
  Chip,
  IconButton,
  Menu,
  MenuItem,
  ListItemIcon,
  ListItemText,
} from '@mui/material';
import {
  MoreVert as MoreVertIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  CheckCircle as ApproveIcon,
  Block as BlockIcon,
  Person as PersonIcon,
} from '@mui/icons-material';

export interface TableColumn<T = any> {
  id: string;
  label: string;
  sortable?: boolean;
  align?: 'left' | 'center' | 'right';
  width?: string | number;
  render?: (value: any, row: T) => React.ReactNode;
}

export interface TableAction<T = any> {
  id: string;
  label: string;
  icon?: React.ReactNode;
  color?: 'primary' | 'secondary' | 'error' | 'warning' | 'info' | 'success';
  onClick: (row: T) => void;
  show?: (row: T) => boolean;
}

export interface AdminDataTableProps<T = any> {
  columns: TableColumn<T>[];
  data: T[];
  loading?: boolean;
  error?: string | null;
  totalItems?: number;
  currentPage?: number;
  itemsPerPage?: number;
  onPageChange?: (page: number) => void;
  onSort?: (column: string, direction: 'asc' | 'desc') => void;
  sortColumn?: string;
  sortDirection?: 'asc' | 'desc';
  actions?: TableAction<T>[];
  emptyMessage?: string;
  title?: string;
}

const AdminDataTable = <T extends Record<string, any>>({
  columns,
  data,
  loading = false,
  error = null,
  totalItems = 0,
  currentPage = 1,
  itemsPerPage = 10,
  onPageChange,
  onSort,
  sortColumn,
  sortDirection = 'asc',
  actions = [],
  emptyMessage = 'No data available',
  title,
}: AdminDataTableProps<T>) => {
  const [anchorEl, setAnchorEl] = React.useState<null | HTMLElement>(null);
  const [selectedRow, setSelectedRow] = React.useState<T | null>(null);

  const handleActionClick = (event: React.MouseEvent<HTMLElement>, row: T) => {
    setAnchorEl(event.currentTarget);
    setSelectedRow(row);
  };

  const handleActionClose = () => {
    setAnchorEl(null);
    setSelectedRow(null);
  };

  const handleSort = (columnId: string) => {
    if (!onSort) return;
    
    const isCurrentColumn = sortColumn === columnId;
    const newDirection = isCurrentColumn && sortDirection === 'asc' ? 'desc' : 'asc';
    onSort(columnId, newDirection);
  };

  const totalPages = Math.ceil(totalItems / itemsPerPage);

  const renderCellValue = (column: TableColumn<T>, row: T) => {
    const value = row[column.id];
    
    if (column.render) {
      return column.render(value, row);
    }

    // Default rendering for common data types
    if (value === null || value === undefined) {
      return '-';
    }

    if (typeof value === 'boolean') {
      return (
        <Chip
          label={value ? 'Yes' : 'No'}
          color={value ? 'success' : 'default'}
          size="small"
        />
      );
    }

    if (value instanceof Date) {
      return value.toLocaleDateString();
    }

    if (typeof value === 'string' && value.length > 50) {
      return `${value.substring(0, 50)}...`;
    }

    return String(value);
  };

  const visibleActions = actions.filter(action => 
    !selectedRow || !action.show || action.show(selectedRow)
  );

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight={200}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Alert severity="error" sx={{ mb: 2 }}>
        {error}
      </Alert>
    );
  }

  return (
    <Box>
      {title && (
        <Typography variant="h5" gutterBottom sx={{ mb: 3 }}>
          {title}
        </Typography>
      )}
      
      <TableContainer component={Paper} elevation={1}>
        <Table>
          <TableHead>
            <TableRow>
              {columns.map((column) => (
                <TableCell
                  key={column.id}
                  align={column.align || 'left'}
                  style={{ width: column.width }}
                  sx={{ fontWeight: 'bold', backgroundColor: 'grey.50' }}
                >
                  {column.sortable && onSort ? (
                    <TableSortLabel
                      active={sortColumn === column.id}
                      direction={sortColumn === column.id ? sortDirection : 'asc'}
                      onClick={() => handleSort(column.id)}
                    >
                      {column.label}
                    </TableSortLabel>
                  ) : (
                    column.label
                  )}
                </TableCell>
              ))}
              {actions.length > 0 && (
                <TableCell align="center" sx={{ fontWeight: 'bold', backgroundColor: 'grey.50' }}>
                  Actions
                </TableCell>
              )}
            </TableRow>
          </TableHead>
          <TableBody>
            {data.length === 0 ? (
              <TableRow>
                <TableCell 
                  colSpan={columns.length + (actions.length > 0 ? 1 : 0)} 
                  align="center"
                  sx={{ py: 4 }}
                >
                  <Typography variant="body2" color="text.secondary">
                    {emptyMessage}
                  </Typography>
                </TableCell>
              </TableRow>
            ) : (
              data.map((row, index) => (
                <TableRow key={row.id || index} hover>
                  {columns.map((column) => (
                    <TableCell
                      key={column.id}
                      align={column.align || 'left'}
                    >
                      {renderCellValue(column, row)}
                    </TableCell>
                  ))}
                  {actions.length > 0 && (
                    <TableCell align="center">
                      <IconButton
                        size="small"
                        onClick={(e) => handleActionClick(e, row)}
                      >
                        <MoreVertIcon />
                      </IconButton>
                    </TableCell>
                  )}
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>

      {/* Actions Menu */}
      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleActionClose}
        anchorOrigin={{
          vertical: 'bottom',
          horizontal: 'right',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'right',
        }}
      >
        {visibleActions.map((action) => (
          <MenuItem
            key={action.id}
            onClick={() => {
              if (selectedRow) {
                action.onClick(selectedRow);
              }
              handleActionClose();
            }}
          >
            {action.icon && (
              <ListItemIcon>
                {action.icon}
              </ListItemIcon>
            )}
            <ListItemText>{action.label}</ListItemText>
          </MenuItem>
        ))}
      </Menu>

      {/* Pagination */}
      {totalPages > 1 && onPageChange && (
        <Box display="flex" justifyContent="center" mt={3}>
          <Pagination
            count={totalPages}
            page={currentPage}
            onChange={(_, page) => onPageChange(page)}
            color="primary"
            showFirstButton
            showLastButton
          />
        </Box>
      )}

      {/* Summary */}
      {totalItems > 0 && (
        <Box mt={2}>
          <Typography variant="body2" color="text.secondary" align="center">
            Showing {Math.min((currentPage - 1) * itemsPerPage + 1, totalItems)} to{' '}
            {Math.min(currentPage * itemsPerPage, totalItems)} of {totalItems} entries
          </Typography>
        </Box>
      )}
    </Box>
  );
};

export default AdminDataTable;

================
File: frontend/src/components/auth/AccountStatusPage.tsx
================
import React from 'react';
import { Link } from 'react-router-dom';
import {
  Box,
  Typography,
  Alert,
  Container,
  Paper,
  Button,
} from '@mui/material';
import {
  HourglassEmpty as PendingIcon,
  Block as RejectedIcon,
} from '@mui/icons-material';
import type { User } from '../../types/api';

interface AccountStatusPageProps {
  user: User;
}

const AccountStatusPage: React.FC<AccountStatusPageProps> = ({ user }) => {
  const isPending = user.status === 'pending';
  const isRejected = user.status === 'rejected';

  const getStatusInfo = () => {
    if (isPending) {
      return {
        icon: <PendingIcon sx={{ fontSize: 64, color: 'warning.main' }} />,
        title: 'Account Pending Approval',
        message: 'Your account has been created successfully and is currently pending approval from an administrator.',
        details: 'You will receive an email notification once your account has been approved. This process typically takes 1-2 business days.',
        severity: 'warning' as const,
      };
    }

    if (isRejected) {
      return {
        icon: <RejectedIcon sx={{ fontSize: 64, color: 'error.main' }} />,
        title: 'Account Access Denied',
        message: 'Your account application has been reviewed and unfortunately cannot be approved at this time.',
        details: 'If you believe this is an error or would like to appeal this decision, please contact the HOA administration directly.',
        severity: 'error' as const,
      };
    }

    return null;
  };

  const statusInfo = getStatusInfo();

  if (!statusInfo) {
    return null;
  }

  return (
    <Container component="main" maxWidth="md">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          py: 4,
        }}
      >
        <Paper elevation={3} sx={{ p: 4 }}>
          <Box sx={{ textAlign: 'center', mb: 4 }}>
            <Box sx={{ mb: 3 }}>
              {statusInfo.icon}
            </Box>
            <Typography component="h1" variant="h4" gutterBottom>
              {statusInfo.title}
            </Typography>
          </Box>

          <Alert severity={statusInfo.severity} sx={{ mb: 3 }}>
            <Typography variant="body1" gutterBottom>
              <strong>Hello, {user.name}!</strong>
            </Typography>
            <Typography variant="body1" gutterBottom>
              {statusInfo.message}
            </Typography>
            <Typography variant="body2" sx={{ mt: 2 }}>
              {statusInfo.details}
            </Typography>
          </Alert>

          <Box sx={{ textAlign: 'center', mt: 4 }}>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              Account Status: <strong>{user.status.charAt(0).toUpperCase() + user.status.slice(1)}</strong>
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              Email: {user.email}
            </Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
              Account Created: {new Date(user.created_at).toLocaleDateString()}
            </Typography>

            <Button
              component={Link}
              to="/login"
              variant="outlined"
              size="large"
            >
              Back to Login
            </Button>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default AccountStatusPage;

================
File: frontend/src/components/common/ProtectedRoute.tsx
================
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { Box, CircularProgress } from '@mui/material';
import type { ReactNode } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import AccountStatusPage from '../auth/AccountStatusPage';

interface ProtectedRouteProps {
  children: ReactNode;
  requireAdmin?: boolean;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children, requireAdmin = false }) => {
  const { isAuthenticated, isAdmin, isLoading, user } = useAuth();
  const location = useLocation();

  // Show loading spinner while checking authentication
  if (isLoading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="100vh"
      >
        <CircularProgress />
      </Box>
    );
  }

  // Redirect to login if not authenticated
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  // Check if user account is approved
  if (user && user.status !== 'approved') {
    return <AccountStatusPage user={user} />;
  }

  // Check admin requirement
  if (requireAdmin && !isAdmin) {
    return <Navigate to="/dashboard" replace />;
  }

  return <>{children}</>;
};

export default ProtectedRoute;

================
File: frontend/src/components/common/PublicRoute.tsx
================
import React from 'react';
import { Navigate } from 'react-router-dom';
import { Box, CircularProgress } from '@mui/material';
import type { ReactNode } from 'react';
import { useAuth } from '../../contexts/AuthContext';

interface PublicRouteProps {
  children: ReactNode;
}

const PublicRoute: React.FC<PublicRouteProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();

  // Show loading spinner while checking authentication
  if (isLoading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="100vh"
      >
        <CircularProgress />
      </Box>
    );
  }

  // Redirect to dashboard if already authenticated
  if (isAuthenticated) {
    return <Navigate to="/dashboard" replace />;
  }

  return <>{children}</>;
};

export default PublicRoute;

================
File: frontend/src/components/layout/Layout.tsx
================
import React, { useState } from 'react';
import { Outlet, useNavigate, useLocation } from 'react-router-dom';
import {
  Box,
  Drawer,
  AppBar,
  Toolbar,
  List,
  Typography,
  Divider,
  IconButton,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Avatar,
  Menu,
  MenuItem,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import {
  Menu as MenuIcon,
  Dashboard,
  Announcement,
  Event,
  Description,
  Forum,
  Person,
  AdminPanelSettings,
  People,
  Settings,
  History,
  Logout,
} from '@mui/icons-material';
import { useAuth } from '../../contexts/AuthContext';

const drawerWidth = 240;

interface NavigationItem {
  text: string;
  icon: React.ReactElement;
  path: string;
  adminOnly?: boolean;
}

const navigationItems: NavigationItem[] = [
  { text: 'Dashboard', icon: <Dashboard />, path: '/dashboard' },
  { text: 'Announcements', icon: <Announcement />, path: '/announcements' },
  { text: 'Events', icon: <Event />, path: '/events' },
  { text: 'Documents', icon: <Description />, path: '/documents' },
  { text: 'Discussions', icon: <Forum />, path: '/discussions' },
  { text: 'Profile', icon: <Person />, path: '/profile' },
];

const adminNavigationItems: NavigationItem[] = [
  { text: 'Admin Dashboard', icon: <AdminPanelSettings />, path: '/admin/dashboard', adminOnly: true },
  { text: 'User Management', icon: <People />, path: '/admin/users', adminOnly: true },
  { text: 'Manage Announcements', icon: <Announcement />, path: '/admin/announcements', adminOnly: true },
  { text: 'Manage Events', icon: <Event />, path: '/admin/events', adminOnly: true },
  { text: 'Manage Documents', icon: <Description />, path: '/admin/documents', adminOnly: true },
  { text: 'Site Configuration', icon: <Settings />, path: '/admin/config', adminOnly: true },
  { text: 'Audit Logs', icon: <History />, path: '/admin/audit', adminOnly: true },
];

const Layout: React.FC = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const [mobileOpen, setMobileOpen] = useState(false);
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const navigate = useNavigate();
  const location = useLocation();
  const { user, logout, isAdmin } = useAuth();

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleProfileMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleProfileMenuClose = () => {
    setAnchorEl(null);
  };

  const handleLogout = () => {
    logout();
    handleProfileMenuClose();
    navigate('/login');
  };

  const handleNavigate = (path: string) => {
    navigate(path);
    if (isMobile) {
      setMobileOpen(false);
    }
  };

  const drawer = (
    <Box>
      <Toolbar>
        <Typography variant="h6" noWrap component="div">
          HOA Community Hub
        </Typography>
      </Toolbar>
      <Divider />
      
      {/* Member Navigation */}
      <List>
        {navigationItems.map((item) => (
          <ListItem key={item.text} disablePadding>
            <ListItemButton
              selected={location.pathname === item.path}
              onClick={() => handleNavigate(item.path)}
            >
              <ListItemIcon>{item.icon}</ListItemIcon>
              <ListItemText primary={item.text} />
            </ListItemButton>
          </ListItem>
        ))}
      </List>

      {/* Admin Navigation */}
      {isAdmin && (
        <>
          <Divider />
          <List>
            <ListItem>
              <ListItemText 
                primary="Administration" 
                primaryTypographyProps={{ 
                  variant: 'overline', 
                  color: 'text.secondary',
                  fontWeight: 'bold'
                }} 
              />
            </ListItem>
            {adminNavigationItems.map((item) => (
              <ListItem key={item.text} disablePadding>
                <ListItemButton
                  selected={location.pathname === item.path}
                  onClick={() => handleNavigate(item.path)}
                >
                  <ListItemIcon>{item.icon}</ListItemIcon>
                  <ListItemText primary={item.text} />
                </ListItemButton>
              </ListItem>
            ))}
          </List>
        </>
      )}
    </Box>
  );

  return (
    <Box sx={{ display: 'flex' }}>
      <AppBar
        position="fixed"
        sx={{
          width: { md: `calc(100% - ${drawerWidth}px)` },
          ml: { md: `${drawerWidth}px` },
        }}
      >
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="open drawer"
            edge="start"
            onClick={handleDrawerToggle}
            sx={{ mr: 2, display: { md: 'none' } }}
          >
            <MenuIcon />
          </IconButton>
          
          <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
            {/* Page title could be dynamic based on current route */}
          </Typography>

          {/* User Profile Menu */}
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <Typography variant="body2" sx={{ display: { xs: 'none', sm: 'block' } }}>
              {user?.name}
            </Typography>
            <IconButton
              size="large"
              aria-label="account of current user"
              aria-controls="profile-menu"
              aria-haspopup="true"
              onClick={handleProfileMenuOpen}
              color="inherit"
            >
              <Avatar sx={{ width: 32, height: 32 }}>
                {user?.name?.charAt(0).toUpperCase()}
              </Avatar>
            </IconButton>
          </Box>
        </Toolbar>
      </AppBar>

      {/* Profile Menu */}
      <Menu
        id="profile-menu"
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleProfileMenuClose}
        onClick={handleProfileMenuClose}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >
        <MenuItem onClick={() => handleNavigate('/profile')}>
          <ListItemIcon>
            <Person fontSize="small" />
          </ListItemIcon>
          Profile
        </MenuItem>
        <MenuItem onClick={handleLogout}>
          <ListItemIcon>
            <Logout fontSize="small" />
          </ListItemIcon>
          Logout
        </MenuItem>
      </Menu>

      {/* Navigation Drawer */}
      <Box
        component="nav"
        sx={{ width: { md: drawerWidth }, flexShrink: { md: 0 } }}
        aria-label="navigation"
      >
        {/* Mobile drawer */}
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{
            keepMounted: true, // Better open performance on mobile.
          }}
          sx={{
            display: { xs: 'block', md: 'none' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
        >
          {drawer}
        </Drawer>
        
        {/* Desktop drawer */}
        <Drawer
          variant="permanent"
          sx={{
            display: { xs: 'none', md: 'block' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
          open
        >
          {drawer}
        </Drawer>
      </Box>

      {/* Main content */}
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          p: 3,
          width: { md: `calc(100% - ${drawerWidth}px)` },
          mt: '64px', // AppBar height
        }}
      >
        <Outlet />
      </Box>
    </Box>
  );
};

export default Layout;

================
File: frontend/src/contexts/AuthContext.tsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import type { ReactNode } from 'react';
import type { User, LoginRequest, RegisterRequest } from '../types/api';
import { apiService } from '../services/api';
import { useApiNotifications } from '../hooks/useApiNotifications';

interface AuthContextType {
  user: User | null;
  token: string | null;
  isLoading: boolean;
  login: (credentials: LoginRequest) => Promise<void>;
  register: (userData: RegisterRequest) => Promise<void>;
  logout: () => void;
  updateUser: (updatedUser: User) => void;
  isAuthenticated: boolean;
  isAdmin: boolean;
  isMember: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Initialize API notifications
  useApiNotifications();

  // Initialize auth state from localStorage
  useEffect(() => {
    const storedToken = localStorage.getItem('token');
    const storedUser = localStorage.getItem('user');

    if (storedToken && storedUser) {
      try {
        const parsedUser = JSON.parse(storedUser);
        setToken(storedToken);
        setUser(parsedUser);
      } catch (error) {
        console.error('Error parsing stored user data:', error);
        localStorage.removeItem('token');
        localStorage.removeItem('user');
      }
    }
    setIsLoading(false);
  }, []);

  // Verify token and refresh user data on app start
  useEffect(() => {
    const verifyToken = async () => {
      if (token && !user) {
        try {
          const userData = await apiService.getProfile();
          setUser(userData);
          localStorage.setItem('user', JSON.stringify(userData));
        } catch (error) {
          console.error('Token verification failed:', error);
          logout();
        }
      }
    };

    if (token) {
      verifyToken();
    }
  }, [token, user]);

  const login = async (credentials: LoginRequest): Promise<void> => {
    try {
      const response = await apiService.login(credentials);
      const { token: newToken, user: userData } = response;

      setToken(newToken);
      setUser(userData);
      localStorage.setItem('token', newToken);
      localStorage.setItem('user', JSON.stringify(userData));
    } catch (error) {
      throw error;
    }
  };

  const register = async (userData: RegisterRequest): Promise<void> => {
    try {
      await apiService.register(userData);
      // Note: Registration doesn't automatically log in the user
      // They need admin approval first
    } catch (error) {
      throw error;
    }
  };

  const logout = (): void => {
    setUser(null);
    setToken(null);
    localStorage.removeItem('token');
    localStorage.removeItem('user');
  };

  const updateUser = (updatedUser: User): void => {
    setUser(updatedUser);
    localStorage.setItem('user', JSON.stringify(updatedUser));
  };

  const isAuthenticated = !!user && !!token;
  const isAdmin = user?.role === 'admin';
  const isMember = user?.role === 'member';

  const value: AuthContextType = {
    user,
    token,
    isLoading,
    login,
    register,
    logout,
    updateUser,
    isAuthenticated,
    isAdmin,
    isMember,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================
File: frontend/src/contexts/NotificationContext.tsx
================
import React, { createContext, useContext } from 'react';
import { SnackbarProvider, useSnackbar } from 'notistack';
import type { ReactNode } from 'react';

interface NotificationContextType {
  showSuccess: (message: string) => void;
  showError: (message: string) => void;
  showWarning: (message: string) => void;
  showInfo: (message: string) => void;
}

const NotificationContext = createContext<NotificationContextType | undefined>(undefined);

interface NotificationProviderProps {
  children: ReactNode;
}

const NotificationProviderInner: React.FC<NotificationProviderProps> = ({ children }) => {
  const { enqueueSnackbar } = useSnackbar();

  const showSuccess = (message: string) => {
    enqueueSnackbar(message, { variant: 'success' });
  };

  const showError = (message: string) => {
    enqueueSnackbar(message, { variant: 'error' });
  };

  const showWarning = (message: string) => {
    enqueueSnackbar(message, { variant: 'warning' });
  };

  const showInfo = (message: string) => {
    enqueueSnackbar(message, { variant: 'info' });
  };

  const value: NotificationContextType = {
    showSuccess,
    showError,
    showWarning,
    showInfo,
  };

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
};

export const NotificationProvider: React.FC<NotificationProviderProps> = ({ children }) => {
  return (
    <SnackbarProvider
      maxSnack={3}
      anchorOrigin={{
        vertical: 'top',
        horizontal: 'right',
      }}
      autoHideDuration={5000}
    >
      <NotificationProviderInner>{children}</NotificationProviderInner>
    </SnackbarProvider>
  );
};

export const useNotification = (): NotificationContextType => {
  const context = useContext(NotificationContext);
  if (context === undefined) {
    throw new Error('useNotification must be used within a NotificationProvider');
  }
  return context;
};

================
File: frontend/src/hooks/useApiNotifications.ts
================
import { useEffect } from 'react';
import { useNotification } from '../contexts/NotificationContext';
import { apiService } from '../services/api';

export const useApiNotifications = () => {
  const { showError } = useNotification();

  useEffect(() => {
    // Set the error handler for the API service
    apiService.setErrorHandler(showError);
  }, [showError]);
};

================
File: frontend/src/pages/admin/AdminAnnouncementsPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Alert,
  Chip,
  IconButton,
  Tooltip,
} from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Visibility as ViewIcon,
} from '@mui/icons-material';
import { DateTimePicker } from '@mui/x-date-pickers/DateTimePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { useSnackbar } from 'notistack';
import AdminDataTable, { type TableColumn, type TableAction } from '../../components/admin/AdminDataTable';
import { apiService } from '../../services/api';
import type { Announcement, CreateAnnouncementRequest, PaginatedResponse } from '../../types/api';

const AdminAnnouncementsPage: React.FC = () => {
  const { enqueueSnackbar } = useSnackbar();
  
  // State for data
  const [announcements, setAnnouncements] = useState<Announcement[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [totalItems, setTotalItems] = useState(0);
  
  // State for pagination and sorting
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);
  const [sortColumn, setSortColumn] = useState<string>('created_at');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
  
  // State for modals
  const [createModalOpen, setCreateModalOpen] = useState(false);
  const [editModalOpen, setEditModalOpen] = useState(false);
  const [deleteModalOpen, setDeleteModalOpen] = useState(false);
  const [selectedAnnouncement, setSelectedAnnouncement] = useState<Announcement | null>(null);
  
  // State for form
  const [formData, setFormData] = useState({
    title: '',
    content: '',
    expiresAt: null as Date | null,
  });
  const [formErrors, setFormErrors] = useState<Record<string, string>>({});

  // Load announcements data
  const loadAnnouncements = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response: PaginatedResponse<Announcement> = await apiService.getAnnouncements({
        page: currentPage,
        limit: itemsPerPage,
        sortBy: sortColumn,
        sortOrder: sortDirection,
      });
      
      setAnnouncements(response.data);
      setTotalItems(response.pagination.totalItems);
    } catch (err: any) {
      setError(err.response?.data?.message || 'Failed to load announcements');
      enqueueSnackbar('Failed to load announcements', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadAnnouncements();
  }, [currentPage, sortColumn, sortDirection]);

  // Handle sorting
  const handleSort = (column: string, direction: 'asc' | 'desc') => {
    setSortColumn(column);
    setSortDirection(direction);
  };

  // Form validation
  const validateForm = () => {
    const errors: Record<string, string> = {};
    
    if (!formData.title.trim()) {
      errors.title = 'Title is required';
    } else if (formData.title.length > 200) {
      errors.title = 'Title must be less than 200 characters';
    }
    
    if (!formData.content.trim()) {
      errors.content = 'Content is required';
    } else if (formData.content.length > 5000) {
      errors.content = 'Content must be less than 5000 characters';
    }
    
    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };

  // Handle create announcement
  const handleCreateAnnouncement = async () => {
    if (!validateForm()) return;
    
    try {
      const data: CreateAnnouncementRequest = {
        title: formData.title.trim(),
        content: formData.content.trim(),
        expiresAt: formData.expiresAt?.toISOString(),
      };
      
      await apiService.createAnnouncement(data);
      
      enqueueSnackbar('Announcement created successfully', { variant: 'success' });
      setCreateModalOpen(false);
      resetForm();
      loadAnnouncements();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to create announcement', { variant: 'error' });
    }
  };

  // Handle edit announcement
  const handleEditAnnouncement = async () => {
    if (!selectedAnnouncement || !validateForm()) return;
    
    try {
      const data: Partial<CreateAnnouncementRequest> = {
        title: formData.title.trim(),
        content: formData.content.trim(),
        expiresAt: formData.expiresAt?.toISOString(),
      };
      
      await apiService.updateAnnouncement(selectedAnnouncement.id, data);
      
      enqueueSnackbar('Announcement updated successfully', { variant: 'success' });
      setEditModalOpen(false);
      setSelectedAnnouncement(null);
      resetForm();
      loadAnnouncements();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to update announcement', { variant: 'error' });
    }
  };

  // Handle delete announcement
  const handleDeleteAnnouncement = async () => {
    if (!selectedAnnouncement) return;
    
    try {
      await apiService.deleteAnnouncement(selectedAnnouncement.id);
      
      enqueueSnackbar('Announcement deleted successfully', { variant: 'success' });
      setDeleteModalOpen(false);
      setSelectedAnnouncement(null);
      loadAnnouncements();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to delete announcement', { variant: 'error' });
    }
  };

  // Reset form
  const resetForm = () => {
    setFormData({
      title: '',
      content: '',
      expiresAt: null,
    });
    setFormErrors({});
  };

  // Open edit modal with data
  const openEditModal = (announcement: Announcement) => {
    setSelectedAnnouncement(announcement);
    setFormData({
      title: announcement.title,
      content: announcement.content,
      expiresAt: announcement.expires_at ? new Date(announcement.expires_at) : null,
    });
    setEditModalOpen(true);
  };

  // Define table columns
  const columns: TableColumn<Announcement>[] = [
    {
      id: 'title',
      label: 'Title',
      sortable: true,
      render: (value: string, announcement: Announcement) => (
        <Box>
          <Typography variant="body2" fontWeight="medium">
            {value}
          </Typography>
          <Typography variant="caption" color="text.secondary">
            {announcement.creator?.name || 'Unknown'}
          </Typography>
        </Box>
      ),
    },
    {
      id: 'content',
      label: 'Content',
      render: (value: string) => (
        <Typography variant="body2" sx={{ maxWidth: 300 }}>
          {value.length > 100 ? `${value.substring(0, 100)}...` : value}
        </Typography>
      ),
    },
    {
      id: 'expires_at',
      label: 'Expires',
      align: 'center',
      sortable: true,
      render: (value: string | null) => {
        if (!value) {
          return <Chip label="Never" color="default" size="small" />;
        }
        
        const expiryDate = new Date(value);
        const isExpired = expiryDate < new Date();
        
        return (
          <Tooltip title={expiryDate.toLocaleString()}>
            <Chip
              label={isExpired ? 'Expired' : 'Active'}
              color={isExpired ? 'error' : 'success'}
              size="small"
            />
          </Tooltip>
        );
      },
    },
    {
      id: 'created_at',
      label: 'Created',
      align: 'center',
      sortable: true,
      render: (value: string) => new Date(value).toLocaleDateString(),
    },
  ];

  // Define table actions
  const actions: TableAction<Announcement>[] = [
    {
      id: 'edit',
      label: 'Edit Announcement',
      icon: <EditIcon />,
      color: 'primary',
      onClick: openEditModal,
    },
    {
      id: 'delete',
      label: 'Delete Announcement',
      icon: <DeleteIcon />,
      color: 'error',
      onClick: (announcement: Announcement) => {
        setSelectedAnnouncement(announcement);
        setDeleteModalOpen(true);
      },
    },
  ];

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
          <Box>
            <Typography variant="h4" gutterBottom>
              Announcement Management
            </Typography>
            <Typography variant="body1" color="text.secondary">
              Create and manage community announcements
            </Typography>
          </Box>
          
          <Button
            variant="contained"
            startIcon={<AddIcon />}
            onClick={() => {
              resetForm();
              setCreateModalOpen(true);
            }}
          >
            Create Announcement
          </Button>
        </Box>

        {/* Data Table */}
        <AdminDataTable
          columns={columns}
          data={announcements}
          loading={loading}
          error={error}
          totalItems={totalItems}
          currentPage={currentPage}
          itemsPerPage={itemsPerPage}
          onPageChange={setCurrentPage}
          onSort={handleSort}
          sortColumn={sortColumn}
          sortDirection={sortDirection}
          actions={actions}
          emptyMessage="No announcements found"
        />

        {/* Create/Edit Modal */}
        <Dialog
          open={createModalOpen || editModalOpen}
          onClose={() => {
            setCreateModalOpen(false);
            setEditModalOpen(false);
            setSelectedAnnouncement(null);
            resetForm();
          }}
          maxWidth="md"
          fullWidth
        >
          <DialogTitle>
            {createModalOpen ? 'Create Announcement' : 'Edit Announcement'}
          </DialogTitle>
          <DialogContent>
            <Box display="flex" flexDirection="column" gap={2} mt={1}>
              <TextField
                label="Title"
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                error={!!formErrors.title}
                helperText={formErrors.title || `${formData.title.length}/200 characters`}
                fullWidth
                required
              />
              
              <TextField
                label="Content"
                value={formData.content}
                onChange={(e) => setFormData({ ...formData, content: e.target.value })}
                error={!!formErrors.content}
                helperText={formErrors.content || `${formData.content.length}/5000 characters`}
                multiline
                rows={6}
                fullWidth
                required
              />
              
              <DateTimePicker
                label="Expires At (Optional)"
                value={formData.expiresAt}
                onChange={(date) => setFormData({
                  ...formData,
                  expiresAt: date ? (date instanceof Date ? date : date.toDate()) : null
                })}
                slotProps={{
                  textField: {
                    fullWidth: true,
                    helperText: 'Leave empty for permanent announcement',
                  },
                }}
              />
            </Box>
          </DialogContent>
          <DialogActions>
            <Button
              onClick={() => {
                setCreateModalOpen(false);
                setEditModalOpen(false);
                setSelectedAnnouncement(null);
                resetForm();
              }}
            >
              Cancel
            </Button>
            <Button
              onClick={createModalOpen ? handleCreateAnnouncement : handleEditAnnouncement}
              variant="contained"
              color="primary"
            >
              {createModalOpen ? 'Create' : 'Update'}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Delete Confirmation Modal */}
        <Dialog open={deleteModalOpen} onClose={() => setDeleteModalOpen(false)} maxWidth="sm" fullWidth>
          <DialogTitle>Delete Announcement</DialogTitle>
          <DialogContent>
            {selectedAnnouncement && (
              <Box>
                <Alert severity="warning" sx={{ mb: 2 }}>
                  This action cannot be undone. The announcement will be permanently deleted.
                </Alert>
                
                <Typography variant="body1">
                  Are you sure you want to delete the announcement <strong>"{selectedAnnouncement.title}"</strong>?
                </Typography>
              </Box>
            )}
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setDeleteModalOpen(false)}>Cancel</Button>
            <Button onClick={handleDeleteAnnouncement} variant="contained" color="error">
              Delete Announcement
            </Button>
          </DialogActions>
        </Dialog>
      </Box>
    </LocalizationProvider>
  );
};

export default AdminAnnouncementsPage;

================
File: frontend/src/pages/admin/AdminAuditPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Chip,
  Card,
  CardContent,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Button,
} from '@mui/material';
import {
  ExpandMore as ExpandMoreIcon,
  Search as SearchIcon,
  Refresh as RefreshIcon,
  Person as PersonIcon,
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import AdminDataTable, { type TableColumn } from '../../components/admin/AdminDataTable';
import { apiService } from '../../services/api';
import type { AuditLog, PaginatedResponse } from '../../types/api';

const AdminAuditPage: React.FC = () => {
  const { enqueueSnackbar } = useSnackbar();
  
  // State for data
  const [auditLogs, setAuditLogs] = useState<AuditLog[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [totalItems, setTotalItems] = useState(0);
  
  // State for pagination and filtering
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(20);
  const [searchTerm, setSearchTerm] = useState('');
  const [actionFilter, setActionFilter] = useState<string>('all');
  
  // Available action types for filtering
  const actionTypes = [
    'all',
    'user_created',
    'user_updated',
    'user_deleted',
    'announcement_created',
    'announcement_updated',
    'announcement_deleted',
    'event_created',
    'event_updated',
    'event_deleted',
    'document_uploaded',
    'document_approved',
    'document_deleted',
    'config_updated',
    'login',
    'logout',
  ];

  // Load audit logs data
  const loadAuditLogs = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response: PaginatedResponse<AuditLog> = await apiService.getAuditLogs({
        page: currentPage,
        limit: itemsPerPage,
      });
      
      // Apply client-side filtering since the API might not support all filters
      let filteredLogs = response.data;
      
      // Apply search filter
      if (searchTerm) {
        filteredLogs = filteredLogs.filter(log =>
          log.admin_name.toLowerCase().includes(searchTerm.toLowerCase()) ||
          log.action.toLowerCase().includes(searchTerm.toLowerCase()) ||
          JSON.stringify(log.details).toLowerCase().includes(searchTerm.toLowerCase())
        );
      }
      
      // Apply action filter
      if (actionFilter !== 'all') {
        filteredLogs = filteredLogs.filter(log => log.action === actionFilter);
      }
      
      setAuditLogs(filteredLogs);
      setTotalItems(response.pagination.totalItems);
    } catch (err: any) {
      setError(err.response?.data?.message || 'Failed to load audit logs');
      enqueueSnackbar('Failed to load audit logs', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadAuditLogs();
  }, [currentPage, searchTerm, actionFilter]);

  // Format JSON details for display
  const formatDetails = (details: object): string => {
    try {
      return JSON.stringify(details, null, 2);
    } catch {
      return 'Invalid JSON data';
    }
  };

  // Get action color based on action type
  const getActionColor = (action: string): 'default' | 'primary' | 'secondary' | 'error' | 'info' | 'success' | 'warning' => {
    if (action.includes('created') || action.includes('uploaded')) return 'success';
    if (action.includes('updated') || action.includes('approved')) return 'info';
    if (action.includes('deleted')) return 'error';
    if (action.includes('login')) return 'primary';
    if (action.includes('logout')) return 'secondary';
    return 'default';
  };

  // Define table columns
  const columns: TableColumn<AuditLog>[] = [
    {
      id: 'created_at',
      label: 'Timestamp',
      sortable: true,
      width: 180,
      render: (value: string) => {
        const date = new Date(value);
        return (
          <Box>
            <Typography variant="body2">
              {date.toLocaleDateString()}
            </Typography>
            <Typography variant="caption" color="text.secondary">
              {date.toLocaleTimeString()}
            </Typography>
          </Box>
        );
      },
    },
    {
      id: 'admin_name',
      label: 'Admin',
      width: 150,
      render: (value: string) => (
        <Box display="flex" alignItems="center" gap={1}>
          <PersonIcon fontSize="small" color="primary" />
          <Typography variant="body2" fontWeight="medium">
            {value}
          </Typography>
        </Box>
      ),
    },
    {
      id: 'action',
      label: 'Action',
      width: 200,
      render: (value: string) => (
        <Chip
          label={value.replace(/_/g, ' ').toUpperCase()}
          color={getActionColor(value)}
          size="small"
          variant="outlined"
        />
      ),
    },
    {
      id: 'details',
      label: 'Details',
      render: (value: object, log: AuditLog) => {
        const detailsStr = formatDetails(value);
        const preview = detailsStr.length > 100 ? `${detailsStr.substring(0, 100)}...` : detailsStr;
        
        return (
          <Accordion elevation={0} sx={{ boxShadow: 'none', '&:before': { display: 'none' } }}>
            <AccordionSummary
              expandIcon={<ExpandMoreIcon />}
              sx={{ 
                minHeight: 'auto',
                '& .MuiAccordionSummary-content': { margin: '8px 0' }
              }}
            >
              <Typography variant="body2" sx={{ fontFamily: 'monospace', fontSize: '0.75rem' }}>
                {preview}
              </Typography>
            </AccordionSummary>
            <AccordionDetails sx={{ pt: 0 }}>
              <Card variant="outlined">
                <CardContent>
                  <Typography variant="caption" color="text.secondary" gutterBottom>
                    Full Details:
                  </Typography>
                  <Box
                    component="pre"
                    sx={{
                      fontFamily: 'monospace',
                      fontSize: '0.75rem',
                      whiteSpace: 'pre-wrap',
                      wordBreak: 'break-word',
                      maxHeight: 300,
                      overflow: 'auto',
                      backgroundColor: 'grey.50',
                      p: 1,
                      borderRadius: 1,
                    }}
                  >
                    {detailsStr}
                  </Box>
                </CardContent>
              </Card>
            </AccordionDetails>
          </Accordion>
        );
      },
    },
  ];

  return (
    <Box>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Box>
          <Typography variant="h4" gutterBottom>
            Audit Logs
          </Typography>
          <Typography variant="body1" color="text.secondary">
            View system activity and administrative actions
          </Typography>
        </Box>
        
        <Button
          variant="outlined"
          startIcon={<RefreshIcon />}
          onClick={loadAuditLogs}
          disabled={loading}
        >
          Refresh
        </Button>
      </Box>

      {/* Search and Filters */}
      <Box display="flex" gap={2} mb={3} flexWrap="wrap">
        <TextField
          label="Search logs"
          variant="outlined"
          size="small"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            startAdornment: <SearchIcon sx={{ mr: 1, color: 'text.secondary' }} />,
          }}
          sx={{ minWidth: 300 }}
          placeholder="Search by admin name, action, or details..."
        />
        
        <FormControl size="small" sx={{ minWidth: 200 }}>
          <InputLabel>Action Type</InputLabel>
          <Select
            value={actionFilter}
            label="Action Type"
            onChange={(e) => setActionFilter(e.target.value)}
          >
            {actionTypes.map((action) => (
              <MenuItem key={action} value={action}>
                {action === 'all' ? 'All Actions' : action.replace(/_/g, ' ').toUpperCase()}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
        
        <Button
          variant="outlined"
          onClick={() => {
            setSearchTerm('');
            setActionFilter('all');
            setCurrentPage(1);
          }}
        >
          Clear Filters
        </Button>
      </Box>

      {/* Data Table */}
      <AdminDataTable
        columns={columns}
        data={auditLogs}
        loading={loading}
        error={error}
        totalItems={totalItems}
        currentPage={currentPage}
        itemsPerPage={itemsPerPage}
        onPageChange={setCurrentPage}
        emptyMessage="No audit logs found"
      />

      {/* Summary Information */}
      {auditLogs.length > 0 && (
        <Box mt={3}>
          <Card variant="outlined">
            <CardContent>
              <Typography variant="h6" gutterBottom>
                Summary
              </Typography>
              <Box display="flex" gap={2} flexWrap="wrap">
                <Chip
                  label={`Total Logs: ${totalItems}`}
                  color="primary"
                  variant="outlined"
                />
                <Chip
                  label={`Filtered Results: ${auditLogs.length}`}
                  color="secondary"
                  variant="outlined"
                />
                <Chip
                  label={`Current Page: ${currentPage}`}
                  color="default"
                  variant="outlined"
                />
              </Box>
            </CardContent>
          </Card>
        </Box>
      )}
    </Box>
  );
};

export default AdminAuditPage;

================
File: frontend/src/pages/admin/AdminConfigPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  TextField,
  Button,
  Card,
  CardContent,
  CardActions,
  Grid,
  Alert,
  Divider,
  CircularProgress,
} from '@mui/material';
import {
  Save as SaveIcon,
  Refresh as RefreshIcon,
  Settings as SettingsIcon,
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import { apiService } from '../../services/api';
import type { Config, UpdateConfigRequest } from '../../types/api';

interface ConfigField {
  key: string;
  label: string;
  description: string;
  type: 'text' | 'textarea' | 'email' | 'url';
  required?: boolean;
  maxLength?: number;
}

const configFields: ConfigField[] = [
  {
    key: 'hoa_name',
    label: 'HOA Name',
    description: 'The official name of your Homeowners Association',
    type: 'text',
    required: true,
    maxLength: 200,
  },
  {
    key: 'hoa_description',
    label: 'HOA Description',
    description: 'A brief description of your HOA community',
    type: 'textarea',
    maxLength: 1000,
  },
  {
    key: 'contact_email',
    label: 'Contact Email',
    description: 'Primary contact email for the HOA',
    type: 'email',
    required: true,
    maxLength: 100,
  },
  {
    key: 'contact_phone',
    label: 'Contact Phone',
    description: 'Primary contact phone number for the HOA',
    type: 'text',
    maxLength: 20,
  },
  {
    key: 'address',
    label: 'HOA Address',
    description: 'Physical address of the HOA office or community',
    type: 'textarea',
    maxLength: 500,
  },
  {
    key: 'website_url',
    label: 'Website URL',
    description: 'Official website URL (if any)',
    type: 'url',
    maxLength: 200,
  },
  {
    key: 'office_hours',
    label: 'Office Hours',
    description: 'HOA office hours or availability',
    type: 'textarea',
    maxLength: 200,
  },
  {
    key: 'emergency_contact',
    label: 'Emergency Contact',
    description: 'Emergency contact information',
    type: 'textarea',
    maxLength: 500,
  },
];

const AdminConfigPage: React.FC = () => {
  const { enqueueSnackbar } = useSnackbar();
  
  // State for data
  const [config, setConfig] = useState<Config>({});
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState<Record<string, boolean>>({});
  const [error, setError] = useState<string | null>(null);
  
  // State for form values
  const [formValues, setFormValues] = useState<Record<string, string>>({});
  const [formErrors, setFormErrors] = useState<Record<string, string>>({});
  const [hasChanges, setHasChanges] = useState<Record<string, boolean>>({});

  // Load configuration data
  const loadConfig = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response: Config = await apiService.getConfig();
      setConfig(response);
      
      // Initialize form values
      const initialValues: Record<string, string> = {};
      configFields.forEach(field => {
        initialValues[field.key] = response[field.key] || '';
      });
      setFormValues(initialValues);
      setHasChanges({});
      
    } catch (err: any) {
      setError(err.response?.data?.message || 'Failed to load configuration');
      enqueueSnackbar('Failed to load configuration', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadConfig();
  }, []);

  // Handle form value changes
  const handleValueChange = (key: string, value: string) => {
    setFormValues(prev => ({ ...prev, [key]: value }));
    setHasChanges(prev => ({ ...prev, [key]: value !== (config[key] || '') }));
    
    // Clear error for this field
    if (formErrors[key]) {
      setFormErrors(prev => ({ ...prev, [key]: '' }));
    }
  };

  // Validate field
  const validateField = (field: ConfigField, value: string): string => {
    if (field.required && !value.trim()) {
      return `${field.label} is required`;
    }
    
    if (field.maxLength && value.length > field.maxLength) {
      return `${field.label} must be less than ${field.maxLength} characters`;
    }
    
    if (field.type === 'email' && value && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
      return 'Please enter a valid email address';
    }
    
    if (field.type === 'url' && value && !/^https?:\/\/.+/.test(value)) {
      return 'Please enter a valid URL (starting with http:// or https://)';
    }
    
    return '';
  };

  // Handle save configuration
  const handleSaveConfig = async (field: ConfigField) => {
    const value = formValues[field.key] || '';
    const error = validateField(field, value);
    
    if (error) {
      setFormErrors(prev => ({ ...prev, [field.key]: error }));
      return;
    }
    
    try {
      setSaving(prev => ({ ...prev, [field.key]: true }));
      
      const data: UpdateConfigRequest = { value: value.trim() };
      await apiService.updateConfig(field.key, data);
      
      // Update local config
      setConfig(prev => ({ ...prev, [field.key]: value.trim() }));
      setHasChanges(prev => ({ ...prev, [field.key]: false }));
      
      enqueueSnackbar(`${field.label} updated successfully`, { variant: 'success' });
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || `Failed to update ${field.label}`, { variant: 'error' });
    } finally {
      setSaving(prev => ({ ...prev, [field.key]: false }));
    }
  };

  // Handle save all changes
  const handleSaveAll = async () => {
    const fieldsWithChanges = configFields.filter(field => hasChanges[field.key]);
    
    if (fieldsWithChanges.length === 0) {
      enqueueSnackbar('No changes to save', { variant: 'info' });
      return;
    }
    
    // Validate all changed fields
    const errors: Record<string, string> = {};
    fieldsWithChanges.forEach(field => {
      const error = validateField(field, formValues[field.key] || '');
      if (error) {
        errors[field.key] = error;
      }
    });
    
    if (Object.keys(errors).length > 0) {
      setFormErrors(errors);
      enqueueSnackbar('Please fix validation errors before saving', { variant: 'error' });
      return;
    }
    
    // Save all changes
    try {
      setSaving({ all: true });
      
      for (const field of fieldsWithChanges) {
        const value = formValues[field.key] || '';
        const data: UpdateConfigRequest = { value: value.trim() };
        await apiService.updateConfig(field.key, data);
        
        // Update local config
        setConfig(prev => ({ ...prev, [field.key]: value.trim() }));
      }
      
      setHasChanges({});
      enqueueSnackbar('All settings saved successfully', { variant: 'success' });
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to save settings', { variant: 'error' });
    } finally {
      setSaving({});
    }
  };

  // Reset field to original value
  const handleResetField = (field: ConfigField) => {
    const originalValue = config[field.key] || '';
    setFormValues(prev => ({ ...prev, [field.key]: originalValue }));
    setHasChanges(prev => ({ ...prev, [field.key]: false }));
    setFormErrors(prev => ({ ...prev, [field.key]: '' }));
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight={400}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box>
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
        <Button
          variant="outlined"
          startIcon={<RefreshIcon />}
          onClick={loadConfig}
        >
          Retry
        </Button>
      </Box>
    );
  }

  const totalChanges = Object.values(hasChanges).filter(Boolean).length;

  return (
    <Box>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Box>
          <Typography variant="h4" gutterBottom>
            System Configuration
          </Typography>
          <Typography variant="body1" color="text.secondary">
            Manage HOA system settings and information
          </Typography>
        </Box>
        
        <Box display="flex" gap={2}>
          <Button
            variant="outlined"
            startIcon={<RefreshIcon />}
            onClick={loadConfig}
            disabled={Object.values(saving).some(Boolean)}
          >
            Refresh
          </Button>
          
          {totalChanges > 0 && (
            <Button
              variant="contained"
              startIcon={<SaveIcon />}
              onClick={handleSaveAll}
              disabled={saving.all}
            >
              Save All Changes ({totalChanges})
            </Button>
          )}
        </Box>
      </Box>

      <Grid container spacing={3}>
        {configFields.map((field) => (
          <Grid key={field.key} size={{ xs: 12, md: 6 }}>
            <Card elevation={1}>
              <CardContent>
                <Box display="flex" alignItems="center" gap={1} mb={2}>
                  <SettingsIcon color="primary" />
                  <Typography variant="h6">
                    {field.label}
                    {field.required && <span style={{ color: 'red' }}> *</span>}
                  </Typography>
                </Box>
                
                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  {field.description}
                </Typography>
                
                <TextField
                  fullWidth
                  label={field.label}
                  value={formValues[field.key] || ''}
                  onChange={(e) => handleValueChange(field.key, e.target.value)}
                  error={!!formErrors[field.key]}
                  helperText={
                    formErrors[field.key] || 
                    (field.maxLength ? `${(formValues[field.key] || '').length}/${field.maxLength} characters` : '')
                  }
                  multiline={field.type === 'textarea'}
                  rows={field.type === 'textarea' ? 3 : 1}
                  type={field.type === 'email' ? 'email' : field.type === 'url' ? 'url' : 'text'}
                  required={field.required}
                  disabled={saving[field.key]}
                />
              </CardContent>
              
              <Divider />
              
              <CardActions sx={{ justifyContent: 'space-between' }}>
                <Box>
                  {hasChanges[field.key] && (
                    <Typography variant="caption" color="warning.main">
                      Unsaved changes
                    </Typography>
                  )}
                </Box>
                
                <Box display="flex" gap={1}>
                  {hasChanges[field.key] && (
                    <Button
                      size="small"
                      onClick={() => handleResetField(field)}
                      disabled={saving[field.key]}
                    >
                      Reset
                    </Button>
                  )}
                  
                  <Button
                    size="small"
                    variant="contained"
                    startIcon={saving[field.key] ? <CircularProgress size={16} /> : <SaveIcon />}
                    onClick={() => handleSaveConfig(field)}
                    disabled={saving[field.key] || !hasChanges[field.key]}
                  >
                    {saving[field.key] ? 'Saving...' : 'Save'}
                  </Button>
                </Box>
              </CardActions>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};

export default AdminConfigPage;

================
File: frontend/src/pages/admin/AdminDashboardPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminDashboardPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Admin Dashboard
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Admin dashboard coming soon...
      </Typography>
    </Box>
  );
};

export default AdminDashboardPage;

================
File: frontend/src/pages/admin/AdminDocumentsPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Alert,
  Chip,
  LinearProgress,
  FormControlLabel,
  Switch,
} from '@mui/material';
import {
  Upload as UploadIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  CheckCircle as ApproveIcon,
  GetApp as DownloadIcon,
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import AdminDataTable, { type TableColumn, type TableAction } from '../../components/admin/AdminDataTable';
import { apiService } from '../../services/api';
import type { Document, DocumentsResponse } from '../../types/api';

const AdminDocumentsPage: React.FC = () => {
  const { enqueueSnackbar } = useSnackbar();
  
  // State for data
  const [documents, setDocuments] = useState<Document[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [totalItems, setTotalItems] = useState(0);
  
  // State for pagination
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);
  
  // State for modals
  const [uploadModalOpen, setUploadModalOpen] = useState(false);
  const [deleteModalOpen, setDeleteModalOpen] = useState(false);
  const [selectedDocument, setSelectedDocument] = useState<Document | null>(null);
  
  // State for upload form
  const [uploadData, setUploadData] = useState({
    title: '',
    description: '',
    isPublic: true,
    file: null as File | null,
  });
  const [uploadProgress, setUploadProgress] = useState(0);
  const [uploading, setUploading] = useState(false);
  const [formErrors, setFormErrors] = useState<Record<string, string>>({});

  // Load documents data
  const loadDocuments = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const offset = (currentPage - 1) * itemsPerPage;
      const response: DocumentsResponse = await apiService.getDocuments({
        limit: itemsPerPage,
        offset,
      });
      
      setDocuments(response.documents);
      setTotalItems(response.count);
    } catch (err: any) {
      setError(err.response?.data?.message || 'Failed to load documents');
      enqueueSnackbar('Failed to load documents', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadDocuments();
  }, [currentPage]);

  // Form validation
  const validateForm = () => {
    const errors: Record<string, string> = {};
    
    if (!uploadData.title.trim()) {
      errors.title = 'Title is required';
    } else if (uploadData.title.length > 200) {
      errors.title = 'Title must be less than 200 characters';
    }
    
    if (uploadData.description && uploadData.description.length > 1000) {
      errors.description = 'Description must be less than 1000 characters';
    }
    
    if (!uploadData.file) {
      errors.file = 'Please select a file to upload';
    } else {
      // Check file size (10MB limit)
      const maxSize = 10 * 1024 * 1024; // 10MB
      if (uploadData.file.size > maxSize) {
        errors.file = 'File size must be less than 10MB';
      }
      
      // Check file type (basic validation)
      const allowedTypes = [
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'application/vnd.ms-excel',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'text/plain',
        'image/jpeg',
        'image/png',
        'image/gif',
      ];
      
      if (!allowedTypes.includes(uploadData.file.type)) {
        errors.file = 'File type not supported. Please upload PDF, Word, Excel, text, or image files.';
      }
    }
    
    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };

  // Handle file upload
  const handleUploadDocument = async () => {
    if (!validateForm()) return;
    
    try {
      setUploading(true);
      setUploadProgress(0);
      
      const formData = new FormData();
      formData.append('documentFile', uploadData.file!);
      formData.append('title', uploadData.title.trim());
      if (uploadData.description) {
        formData.append('description', uploadData.description.trim());
      }
      formData.append('is_public', uploadData.isPublic.toString());
      
      // Simulate upload progress (since we don't have real progress tracking)
      const progressInterval = setInterval(() => {
        setUploadProgress(prev => Math.min(prev + 10, 90));
      }, 200);
      
      await apiService.uploadDocument(formData);
      
      clearInterval(progressInterval);
      setUploadProgress(100);
      
      enqueueSnackbar('Document uploaded successfully', { variant: 'success' });
      setUploadModalOpen(false);
      resetUploadForm();
      loadDocuments();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to upload document', { variant: 'error' });
    } finally {
      setUploading(false);
      setUploadProgress(0);
    }
  };

  // Handle document approval
  const handleApproveDocument = async (document: Document) => {
    try {
      await apiService.approveDocument(document.id);
      enqueueSnackbar('Document approved successfully', { variant: 'success' });
      loadDocuments();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to approve document', { variant: 'error' });
    }
  };

  // Handle document download
  const handleDownloadDocument = async (document: Document) => {
    try {
      const blob = await apiService.downloadDocument(document.id);
      
      // Create download link
      const url = window.URL.createObjectURL(blob);
      const link = window.document.createElement('a');
      link.href = url;
      link.download = document.original_file_name;
      window.document.body.appendChild(link);
      link.click();
      window.document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
      
      enqueueSnackbar('Document downloaded successfully', { variant: 'success' });
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to download document', { variant: 'error' });
    }
  };

  // Handle document deletion
  const handleDeleteDocument = async () => {
    if (!selectedDocument) return;
    
    try {
      await apiService.deleteDocument(selectedDocument.id);
      
      enqueueSnackbar('Document deleted successfully', { variant: 'success' });
      setDeleteModalOpen(false);
      setSelectedDocument(null);
      loadDocuments();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to delete document', { variant: 'error' });
    }
  };

  // Reset upload form
  const resetUploadForm = () => {
    setUploadData({
      title: '',
      description: '',
      isPublic: true,
      file: null,
    });
    setFormErrors({});
    setUploadProgress(0);
  };

  // Handle file selection
  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0] || null;
    setUploadData({ ...uploadData, file });
    
    // Auto-fill title from filename if empty
    if (file && !uploadData.title) {
      const nameWithoutExtension = file.name.replace(/\.[^/.]+$/, '');
      setUploadData(prev => ({ ...prev, title: nameWithoutExtension, file }));
    }
  };

  // Define table columns
  const columns: TableColumn<Document>[] = [
    {
      id: 'title',
      label: 'Document',
      sortable: true,
      render: (value: string, document: Document) => (
        <Box>
          <Typography variant="body2" fontWeight="medium">
            {value}
          </Typography>
          <Typography variant="caption" color="text.secondary">
            {document.original_file_name}
          </Typography>
        </Box>
      ),
    },
    {
      id: 'description',
      label: 'Description',
      render: (value: string | null) => (
        <Typography variant="body2" sx={{ maxWidth: 300 }}>
          {value ? (value.length > 100 ? `${value.substring(0, 100)}...` : value) : '-'}
        </Typography>
      ),
    },
    {
      id: 'uploader',
      label: 'Uploaded By',
      align: 'center',
      render: (_, document: Document) => (
        <Typography variant="body2">
          {document.uploader?.name || 'Unknown'}
        </Typography>
      ),
    },
    {
      id: 'approved',
      label: 'Status',
      align: 'center',
      render: (value: boolean) => (
        <Chip
          label={value ? 'Approved' : 'Pending'}
          color={value ? 'success' : 'warning'}
          size="small"
        />
      ),
    },
    {
      id: 'is_public',
      label: 'Visibility',
      align: 'center',
      render: (value: boolean) => (
        <Chip
          label={value ? 'Public' : 'Private'}
          color={value ? 'primary' : 'default'}
          size="small"
        />
      ),
    },
    {
      id: 'uploaded_at',
      label: 'Uploaded',
      align: 'center',
      sortable: true,
      render: (value: string) => new Date(value).toLocaleDateString(),
    },
  ];

  // Define table actions
  const actions: TableAction<Document>[] = [
    {
      id: 'download',
      label: 'Download',
      icon: <DownloadIcon />,
      color: 'primary',
      onClick: handleDownloadDocument,
    },
    {
      id: 'approve',
      label: 'Approve',
      icon: <ApproveIcon />,
      color: 'success',
      onClick: handleApproveDocument,
      show: (document: Document) => !document.approved,
    },
    {
      id: 'delete',
      label: 'Delete Document',
      icon: <DeleteIcon />,
      color: 'error',
      onClick: (document: Document) => {
        setSelectedDocument(document);
        setDeleteModalOpen(true);
      },
    },
  ];

  return (
    <Box>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Box>
          <Typography variant="h4" gutterBottom>
            Document Management
          </Typography>
          <Typography variant="body1" color="text.secondary">
            Upload and manage community documents
          </Typography>
        </Box>
        
        <Button
          variant="contained"
          startIcon={<UploadIcon />}
          onClick={() => {
            resetUploadForm();
            setUploadModalOpen(true);
          }}
        >
          Upload Document
        </Button>
      </Box>

      {/* Data Table */}
      <AdminDataTable
        columns={columns}
        data={documents}
        loading={loading}
        error={error}
        totalItems={totalItems}
        currentPage={currentPage}
        itemsPerPage={itemsPerPage}
        onPageChange={setCurrentPage}
        actions={actions}
        emptyMessage="No documents found"
      />

      {/* Upload Modal */}
      <Dialog
        open={uploadModalOpen}
        onClose={() => {
          if (!uploading) {
            setUploadModalOpen(false);
            resetUploadForm();
          }
        }}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Upload Document</DialogTitle>
        <DialogContent>
          <Box display="flex" flexDirection="column" gap={2} mt={1}>
            <TextField
              label="Title"
              value={uploadData.title}
              onChange={(e) => setUploadData({ ...uploadData, title: e.target.value })}
              error={!!formErrors.title}
              helperText={formErrors.title || `${uploadData.title.length}/200 characters`}
              fullWidth
              required
              disabled={uploading}
            />
            
            <TextField
              label="Description (Optional)"
              value={uploadData.description}
              onChange={(e) => setUploadData({ ...uploadData, description: e.target.value })}
              error={!!formErrors.description}
              helperText={formErrors.description || `${uploadData.description.length}/1000 characters`}
              multiline
              rows={3}
              fullWidth
              disabled={uploading}
            />
            
            <FormControlLabel
              control={
                <Switch
                  checked={uploadData.isPublic}
                  onChange={(e) => setUploadData({ ...uploadData, isPublic: e.target.checked })}
                  disabled={uploading}
                />
              }
              label="Make document publicly visible"
            />
            
            <Box>
              <input
                type="file"
                id="file-upload"
                style={{ display: 'none' }}
                onChange={handleFileSelect}
                disabled={uploading}
              />
              <label htmlFor="file-upload">
                <Button
                  variant="outlined"
                  component="span"
                  fullWidth
                  disabled={uploading}
                  sx={{ mb: 1 }}
                >
                  {uploadData.file ? uploadData.file.name : 'Select File'}
                </Button>
              </label>
              {formErrors.file && (
                <Typography variant="caption" color="error">
                  {formErrors.file}
                </Typography>
              )}
            </Box>
            
            {uploading && (
              <Box>
                <Typography variant="body2" sx={{ mb: 1 }}>
                  Uploading... {uploadProgress}%
                </Typography>
                <LinearProgress variant="determinate" value={uploadProgress} />
              </Box>
            )}
          </Box>
        </DialogContent>
        <DialogActions>
          <Button
            onClick={() => {
              setUploadModalOpen(false);
              resetUploadForm();
            }}
            disabled={uploading}
          >
            Cancel
          </Button>
          <Button
            onClick={handleUploadDocument}
            variant="contained"
            color="primary"
            disabled={uploading}
          >
            {uploading ? 'Uploading...' : 'Upload'}
          </Button>
        </DialogActions>
      </Dialog>

      {/* Delete Confirmation Modal */}
      <Dialog open={deleteModalOpen} onClose={() => setDeleteModalOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Delete Document</DialogTitle>
        <DialogContent>
          {selectedDocument && (
            <Box>
              <Alert severity="warning" sx={{ mb: 2 }}>
                This action cannot be undone. The document will be permanently deleted.
              </Alert>
              
              <Typography variant="body1">
                Are you sure you want to delete the document <strong>"{selectedDocument.title}"</strong>?
              </Typography>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteModalOpen(false)}>Cancel</Button>
          <Button onClick={handleDeleteDocument} variant="contained" color="error">
            Delete Document
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default AdminDocumentsPage;

================
File: frontend/src/pages/admin/AdminEventsPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Alert,
  Chip,
} from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Event as EventIcon,
} from '@mui/icons-material';
import { DateTimePicker } from '@mui/x-date-pickers/DateTimePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { useSnackbar } from 'notistack';
import AdminDataTable, { type TableColumn, type TableAction } from '../../components/admin/AdminDataTable';
import { apiService } from '../../services/api';
import type { Event, CreateEventRequest, UpdateEventRequest, PaginatedResponse } from '../../types/api';

const AdminEventsPage: React.FC = () => {
  const { enqueueSnackbar } = useSnackbar();
  
  // State for data
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [totalItems, setTotalItems] = useState(0);
  
  // State for pagination and sorting
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);
  const [sortColumn, setSortColumn] = useState<string>('event_date');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
  
  // State for modals
  const [createModalOpen, setCreateModalOpen] = useState(false);
  const [editModalOpen, setEditModalOpen] = useState(false);
  const [deleteModalOpen, setDeleteModalOpen] = useState(false);
  const [selectedEvent, setSelectedEvent] = useState<Event | null>(null);
  
  // State for form
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    startDate: null as Date | null,
    endDate: null as Date | null,
    location: '',
  });
  const [formErrors, setFormErrors] = useState<Record<string, string>>({});

  // Load events data
  const loadEvents = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response: PaginatedResponse<Event> = await apiService.getEvents({
        page: currentPage,
        limit: itemsPerPage,
        sortBy: sortColumn,
        sortOrder: sortDirection,
      });
      
      setEvents(response.data);
      setTotalItems(response.pagination.totalItems);
    } catch (err: any) {
      setError(err.response?.data?.message || 'Failed to load events');
      enqueueSnackbar('Failed to load events', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadEvents();
  }, [currentPage, sortColumn, sortDirection]);

  // Handle sorting
  const handleSort = (column: string, direction: 'asc' | 'desc') => {
    setSortColumn(column);
    setSortDirection(direction);
  };

  // Form validation
  const validateForm = () => {
    const errors: Record<string, string> = {};
    
    if (!formData.title.trim()) {
      errors.title = 'Title is required';
    } else if (formData.title.length > 200) {
      errors.title = 'Title must be less than 200 characters';
    }
    
    if (!formData.description.trim()) {
      errors.description = 'Description is required';
    } else if (formData.description.length > 2000) {
      errors.description = 'Description must be less than 2000 characters';
    }
    
    if (!formData.startDate) {
      errors.startDate = 'Start date is required';
    }
    
    if (!formData.endDate) {
      errors.endDate = 'End date is required';
    } else if (formData.startDate && formData.endDate < formData.startDate) {
      errors.endDate = 'End date must be after start date';
    }
    
    if (!formData.location.trim()) {
      errors.location = 'Location is required';
    } else if (formData.location.length > 200) {
      errors.location = 'Location must be less than 200 characters';
    }
    
    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };

  // Handle create event
  const handleCreateEvent = async () => {
    if (!validateForm()) return;
    
    try {
      const data: CreateEventRequest = {
        title: formData.title.trim(),
        description: formData.description.trim(),
        event_date: formData.startDate!.toISOString(),
        location: formData.location.trim(),
      };
      
      await apiService.createEvent(data);
      
      enqueueSnackbar('Event created successfully', { variant: 'success' });
      setCreateModalOpen(false);
      resetForm();
      loadEvents();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to create event', { variant: 'error' });
    }
  };

  // Handle edit event
  const handleEditEvent = async () => {
    if (!selectedEvent || !validateForm()) return;
    
    try {
      const data: UpdateEventRequest = {
        title: formData.title.trim(),
        description: formData.description.trim(),
        start_date: formData.startDate!.toISOString(),
        end_date: formData.endDate!.toISOString(),
        location: formData.location.trim(),
      };
      
      await apiService.updateEvent(selectedEvent.id, data);
      
      enqueueSnackbar('Event updated successfully', { variant: 'success' });
      setEditModalOpen(false);
      setSelectedEvent(null);
      resetForm();
      loadEvents();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to update event', { variant: 'error' });
    }
  };

  // Handle delete event
  const handleDeleteEvent = async () => {
    if (!selectedEvent) return;
    
    try {
      await apiService.deleteEvent(selectedEvent.id);
      
      enqueueSnackbar('Event deleted successfully', { variant: 'success' });
      setDeleteModalOpen(false);
      setSelectedEvent(null);
      loadEvents();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to delete event', { variant: 'error' });
    }
  };

  // Reset form
  const resetForm = () => {
    setFormData({
      title: '',
      description: '',
      startDate: null,
      endDate: null,
      location: '',
    });
    setFormErrors({});
  };

  // Open edit modal with data
  const openEditModal = (event: Event) => {
    setSelectedEvent(event);
    setFormData({
      title: event.title,
      description: event.description,
      startDate: new Date(event.start_date),
      endDate: new Date(event.end_date),
      location: event.location,
    });
    setEditModalOpen(true);
  };

  // Define table columns
  const columns: TableColumn<Event>[] = [
    {
      id: 'title',
      label: 'Event',
      sortable: true,
      render: (value: string, event: Event) => (
        <Box>
          <Typography variant="body2" fontWeight="medium">
            {value}
          </Typography>
          <Typography variant="caption" color="text.secondary">
            {event.location}
          </Typography>
        </Box>
      ),
    },
    {
      id: 'description',
      label: 'Description',
      render: (value: string) => (
        <Typography variant="body2" sx={{ maxWidth: 300 }}>
          {value.length > 100 ? `${value.substring(0, 100)}...` : value}
        </Typography>
      ),
    },
    {
      id: 'start_date',
      label: 'Start Date',
      align: 'center',
      sortable: true,
      render: (value: string) => {
        const date = new Date(value);
        return (
          <Box>
            <Typography variant="body2">
              {date.toLocaleDateString()}
            </Typography>
            <Typography variant="caption" color="text.secondary">
              {date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
            </Typography>
          </Box>
        );
      },
    },
    {
      id: 'end_date',
      label: 'End Date',
      align: 'center',
      sortable: true,
      render: (value: string) => {
        const date = new Date(value);
        return (
          <Box>
            <Typography variant="body2">
              {date.toLocaleDateString()}
            </Typography>
            <Typography variant="caption" color="text.secondary">
              {date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
            </Typography>
          </Box>
        );
      },
    },
    {
      id: 'status',
      label: 'Status',
      align: 'center',
      render: (_, event: Event) => {
        const now = new Date();
        const startDate = new Date(event.start_date);
        const endDate = new Date(event.end_date);
        
        let status = 'upcoming';
        let color: 'default' | 'primary' | 'secondary' | 'error' | 'info' | 'success' | 'warning' = 'primary';
        
        if (now > endDate) {
          status = 'completed';
          color = 'default';
        } else if (now >= startDate && now <= endDate) {
          status = 'ongoing';
          color = 'success';
        }
        
        return (
          <Chip
            label={status.charAt(0).toUpperCase() + status.slice(1)}
            color={color}
            size="small"
          />
        );
      },
    },
    {
      id: 'created_at',
      label: 'Created',
      align: 'center',
      sortable: true,
      render: (value: string) => new Date(value).toLocaleDateString(),
    },
  ];

  // Define table actions
  const actions: TableAction<Event>[] = [
    {
      id: 'edit',
      label: 'Edit Event',
      icon: <EditIcon />,
      color: 'primary',
      onClick: openEditModal,
    },
    {
      id: 'delete',
      label: 'Delete Event',
      icon: <DeleteIcon />,
      color: 'error',
      onClick: (event: Event) => {
        setSelectedEvent(event);
        setDeleteModalOpen(true);
      },
    },
  ];

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
          <Box>
            <Typography variant="h4" gutterBottom>
              Event Management
            </Typography>
            <Typography variant="body1" color="text.secondary">
              Create and manage community events
            </Typography>
          </Box>
          
          <Button
            variant="contained"
            startIcon={<AddIcon />}
            onClick={() => {
              resetForm();
              setCreateModalOpen(true);
            }}
          >
            Create Event
          </Button>
        </Box>

        {/* Data Table */}
        <AdminDataTable
          columns={columns}
          data={events}
          loading={loading}
          error={error}
          totalItems={totalItems}
          currentPage={currentPage}
          itemsPerPage={itemsPerPage}
          onPageChange={setCurrentPage}
          onSort={handleSort}
          sortColumn={sortColumn}
          sortDirection={sortDirection}
          actions={actions}
          emptyMessage="No events found"
        />

        {/* Create/Edit Modal */}
        <Dialog
          open={createModalOpen || editModalOpen}
          onClose={() => {
            setCreateModalOpen(false);
            setEditModalOpen(false);
            setSelectedEvent(null);
            resetForm();
          }}
          maxWidth="md"
          fullWidth
        >
          <DialogTitle>
            {createModalOpen ? 'Create Event' : 'Edit Event'}
          </DialogTitle>
          <DialogContent>
            <Box display="flex" flexDirection="column" gap={2} mt={1}>
              <TextField
                label="Title"
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                error={!!formErrors.title}
                helperText={formErrors.title || `${formData.title.length}/200 characters`}
                fullWidth
                required
              />
              
              <TextField
                label="Description"
                value={formData.description}
                onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                error={!!formErrors.description}
                helperText={formErrors.description || `${formData.description.length}/2000 characters`}
                multiline
                rows={4}
                fullWidth
                required
              />
              
              <TextField
                label="Location"
                value={formData.location}
                onChange={(e) => setFormData({ ...formData, location: e.target.value })}
                error={!!formErrors.location}
                helperText={formErrors.location || `${formData.location.length}/200 characters`}
                fullWidth
                required
              />
              
              <Box display="flex" gap={2}>
                <DateTimePicker
                  label="Start Date & Time"
                  value={formData.startDate}
                  onChange={(date) => setFormData({
                    ...formData,
                    startDate: date ? (date instanceof Date ? date : date.toDate()) : null
                  })}
                  slotProps={{
                    textField: {
                      fullWidth: true,
                      error: !!formErrors.startDate,
                      helperText: formErrors.startDate,
                      required: true,
                    },
                  }}
                />
                
                <DateTimePicker
                  label="End Date & Time"
                  value={formData.endDate}
                  onChange={(date) => setFormData({
                    ...formData,
                    endDate: date ? (date instanceof Date ? date : date.toDate()) : null
                  })}
                  slotProps={{
                    textField: {
                      fullWidth: true,
                      error: !!formErrors.endDate,
                      helperText: formErrors.endDate,
                      required: true,
                    },
                  }}
                />
              </Box>
            </Box>
          </DialogContent>
          <DialogActions>
            <Button
              onClick={() => {
                setCreateModalOpen(false);
                setEditModalOpen(false);
                setSelectedEvent(null);
                resetForm();
              }}
            >
              Cancel
            </Button>
            <Button
              onClick={createModalOpen ? handleCreateEvent : handleEditEvent}
              variant="contained"
              color="primary"
            >
              {createModalOpen ? 'Create' : 'Update'}
            </Button>
          </DialogActions>
        </Dialog>

        {/* Delete Confirmation Modal */}
        <Dialog open={deleteModalOpen} onClose={() => setDeleteModalOpen(false)} maxWidth="sm" fullWidth>
          <DialogTitle>Delete Event</DialogTitle>
          <DialogContent>
            {selectedEvent && (
              <Box>
                <Alert severity="warning" sx={{ mb: 2 }}>
                  This action cannot be undone. The event will be permanently deleted.
                </Alert>
                
                <Typography variant="body1">
                  Are you sure you want to delete the event <strong>"{selectedEvent.title}"</strong>?
                </Typography>
              </Box>
            )}
          </DialogContent>
          <DialogActions>
            <Button onClick={() => setDeleteModalOpen(false)}>Cancel</Button>
            <Button onClick={handleDeleteEvent} variant="contained" color="error">
              Delete Event
            </Button>
          </DialogActions>
        </Dialog>
      </Box>
      </LocalizationProvider>
  );
};

export default AdminEventsPage;

================
File: frontend/src/pages/admin/AdminUsersPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControlLabel,
  RadioGroup,
  Radio,
  Alert,
  Chip,
  Avatar,
} from '@mui/material';
import {
  Edit as EditIcon,
  Delete as DeleteIcon,
  Person as PersonIcon,
  Search as SearchIcon,
} from '@mui/icons-material';
import { useSnackbar } from 'notistack';
import AdminDataTable, { type TableColumn, type TableAction } from '../../components/admin/AdminDataTable';
import { apiService } from '../../services/api';
import type { User, UpdateUserStatusRequest, UpdateUserRoleRequest } from '../../types/api';

interface UsersResponse {
  count: number;
  users: User[];
}

const AdminUsersPage: React.FC = () => {
  const { enqueueSnackbar } = useSnackbar();
  
  // State for data
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [totalUsers, setTotalUsers] = useState(0);
  
  // State for pagination and filtering
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState<string>('all');
  const [roleFilter, setRoleFilter] = useState<string>('all');
  
  // State for modals
  const [statusModalOpen, setStatusModalOpen] = useState(false);
  const [roleModalOpen, setRoleModalOpen] = useState(false);
  const [deleteModalOpen, setDeleteModalOpen] = useState(false);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  const [newStatus, setNewStatus] = useState<'pending' | 'approved' | 'rejected'>('approved');
  const [newRole, setNewRole] = useState<'admin' | 'member'>('member');

  // Load users data
  const loadUsers = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const offset = (currentPage - 1) * itemsPerPage;
      const response: UsersResponse = await apiService.getUsers({
        limit: itemsPerPage,
        offset,
      });
      
      // Filter out system users and apply search/filters
      let filteredUsers = response.users.filter(user => !user.is_system_user);
      
      // Apply search filter
      if (searchTerm) {
        filteredUsers = filteredUsers.filter(user =>
          user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
          user.email.toLowerCase().includes(searchTerm.toLowerCase())
        );
      }
      
      // Apply status filter
      if (statusFilter !== 'all') {
        filteredUsers = filteredUsers.filter(user => user.status === statusFilter);
      }
      
      // Apply role filter
      if (roleFilter !== 'all') {
        filteredUsers = filteredUsers.filter(user => user.role === roleFilter);
      }
      
      setUsers(filteredUsers);
      setTotalUsers(filteredUsers.length);
    } catch (err: any) {
      setError(err.response?.data?.message || 'Failed to load users');
      enqueueSnackbar('Failed to load users', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadUsers();
  }, [currentPage, searchTerm, statusFilter, roleFilter]);

  // Handle user status update
  const handleUpdateStatus = async () => {
    if (!selectedUser) return;
    
    try {
      const data: UpdateUserStatusRequest = { status: newStatus };
      await apiService.updateUserStatus(selectedUser.id, data);
      
      enqueueSnackbar(`User status updated to ${newStatus}`, { variant: 'success' });
      setStatusModalOpen(false);
      setSelectedUser(null);
      loadUsers();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to update user status', { variant: 'error' });
    }
  };

  // Handle user role update
  const handleUpdateRole = async () => {
    if (!selectedUser) return;
    
    try {
      const data: UpdateUserRoleRequest = { role: newRole };
      await apiService.updateUserRole(selectedUser.id, data);
      
      enqueueSnackbar(`User role updated to ${newRole}`, { variant: 'success' });
      setRoleModalOpen(false);
      setSelectedUser(null);
      loadUsers();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to update user role', { variant: 'error' });
    }
  };

  // Handle user deletion
  const handleDeleteUser = async () => {
    if (!selectedUser) return;
    
    try {
      await apiService.deleteUser(selectedUser.id);
      
      enqueueSnackbar('User deleted successfully', { variant: 'success' });
      setDeleteModalOpen(false);
      setSelectedUser(null);
      loadUsers();
    } catch (err: any) {
      enqueueSnackbar(err.response?.data?.message || 'Failed to delete user', { variant: 'error' });
    }
  };

  // Define table columns
  const columns: TableColumn<User>[] = [
    {
      id: 'name',
      label: 'Name',
      sortable: true,
      render: (value: string, user: User) => (
        <Box display="flex" alignItems="center" gap={1}>
          <Avatar sx={{ width: 32, height: 32, fontSize: '0.875rem' }}>
            {user.name.charAt(0).toUpperCase()}
          </Avatar>
          <Box>
            <Typography variant="body2" fontWeight="medium">
              {user.name}
            </Typography>
            <Typography variant="caption" color="text.secondary">
              {user.email}
            </Typography>
          </Box>
        </Box>
      ),
    },
    {
      id: 'role',
      label: 'Role',
      align: 'center',
      render: (value: string) => (
        <Chip
          label={value.charAt(0).toUpperCase() + value.slice(1)}
          color={value === 'admin' ? 'primary' : 'default'}
          size="small"
        />
      ),
    },
    {
      id: 'status',
      label: 'Status',
      align: 'center',
      render: (value: string) => (
        <Chip
          label={value.charAt(0).toUpperCase() + value.slice(1)}
          color={
            value === 'approved' ? 'success' :
            value === 'pending' ? 'warning' : 'error'
          }
          size="small"
        />
      ),
    },
    {
      id: 'email_verified',
      label: 'Email Verified',
      align: 'center',
      render: (value: boolean) => (
        <Chip
          label={value ? 'Yes' : 'No'}
          color={value ? 'success' : 'default'}
          size="small"
        />
      ),
    },
    {
      id: 'created_at',
      label: 'Joined Date',
      align: 'center',
      render: (value: string) => new Date(value).toLocaleDateString(),
    },
  ];

  // Define table actions
  const actions: TableAction<User>[] = [
    {
      id: 'update-status',
      label: 'Update Status',
      icon: <EditIcon />,
      color: 'primary',
      onClick: (user: User) => {
        setSelectedUser(user);
        setNewStatus(user.status);
        setStatusModalOpen(true);
      },
    },
    {
      id: 'update-role',
      label: 'Update Role',
      icon: <PersonIcon />,
      color: 'secondary',
      onClick: (user: User) => {
        setSelectedUser(user);
        setNewRole(user.role);
        setRoleModalOpen(true);
      },
    },
    {
      id: 'delete',
      label: 'Delete User',
      icon: <DeleteIcon />,
      color: 'error',
      onClick: (user: User) => {
        setSelectedUser(user);
        setDeleteModalOpen(true);
      },
    },
  ];

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        User Management
      </Typography>
      
      <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
        Manage user accounts, roles, and permissions
      </Typography>

      {/* Search and Filters */}
      <Box display="flex" gap={2} mb={3} flexWrap="wrap">
        <TextField
          label="Search users"
          variant="outlined"
          size="small"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            startAdornment: <SearchIcon sx={{ mr: 1, color: 'text.secondary' }} />,
          }}
          sx={{ minWidth: 250 }}
        />
        
        <FormControl size="small" sx={{ minWidth: 120 }}>
          <InputLabel>Status</InputLabel>
          <Select
            value={statusFilter}
            label="Status"
            onChange={(e) => setStatusFilter(e.target.value)}
          >
            <MenuItem value="all">All</MenuItem>
            <MenuItem value="pending">Pending</MenuItem>
            <MenuItem value="approved">Approved</MenuItem>
            <MenuItem value="rejected">Rejected</MenuItem>
          </Select>
        </FormControl>
        
        <FormControl size="small" sx={{ minWidth: 120 }}>
          <InputLabel>Role</InputLabel>
          <Select
            value={roleFilter}
            label="Role"
            onChange={(e) => setRoleFilter(e.target.value)}
          >
            <MenuItem value="all">All</MenuItem>
            <MenuItem value="member">Member</MenuItem>
            <MenuItem value="admin">Admin</MenuItem>
          </Select>
        </FormControl>
        
        <Button
          variant="outlined"
          onClick={() => {
            setSearchTerm('');
            setStatusFilter('all');
            setRoleFilter('all');
            setCurrentPage(1);
          }}
        >
          Clear Filters
        </Button>
      </Box>

      {/* Data Table */}
      <AdminDataTable
        columns={columns}
        data={users}
        loading={loading}
        error={error}
        totalItems={totalUsers}
        currentPage={currentPage}
        itemsPerPage={itemsPerPage}
        onPageChange={setCurrentPage}
        actions={actions}
        emptyMessage="No users found"
      />

      {/* Update Status Modal */}
      <Dialog open={statusModalOpen} onClose={() => setStatusModalOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Update User Status</DialogTitle>
        <DialogContent>
          {selectedUser && (
            <Box>
              <Typography variant="body1" sx={{ mb: 2 }}>
                Update status for <strong>{selectedUser.name}</strong> ({selectedUser.email})
              </Typography>
              
              <FormControl component="fieldset">
                <RadioGroup
                  value={newStatus}
                  onChange={(e) => setNewStatus(e.target.value as 'pending' | 'approved' | 'rejected')}
                >
                  <FormControlLabel value="approved" control={<Radio />} label="Approved" />
                  <FormControlLabel value="pending" control={<Radio />} label="Pending" />
                  <FormControlLabel value="rejected" control={<Radio />} label="Rejected" />
                </RadioGroup>
              </FormControl>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setStatusModalOpen(false)}>Cancel</Button>
          <Button onClick={handleUpdateStatus} variant="contained" color="primary">
            Update Status
          </Button>
        </DialogActions>
      </Dialog>

      {/* Update Role Modal */}
      <Dialog open={roleModalOpen} onClose={() => setRoleModalOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Update User Role</DialogTitle>
        <DialogContent>
          {selectedUser && (
            <Box>
              <Typography variant="body1" sx={{ mb: 2 }}>
                Update role for <strong>{selectedUser.name}</strong> ({selectedUser.email})
              </Typography>
              
              <FormControl component="fieldset">
                <RadioGroup
                  value={newRole}
                  onChange={(e) => setNewRole(e.target.value as 'admin' | 'member')}
                >
                  <FormControlLabel value="member" control={<Radio />} label="Member" />
                  <FormControlLabel value="admin" control={<Radio />} label="Admin" />
                </RadioGroup>
              </FormControl>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setRoleModalOpen(false)}>Cancel</Button>
          <Button onClick={handleUpdateRole} variant="contained" color="primary">
            Update Role
          </Button>
        </DialogActions>
      </Dialog>

      {/* Delete Confirmation Modal */}
      <Dialog open={deleteModalOpen} onClose={() => setDeleteModalOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Delete User</DialogTitle>
        <DialogContent>
          {selectedUser && (
            <Box>
              <Alert severity="warning" sx={{ mb: 2 }}>
                This action cannot be undone. The user will be permanently deleted.
              </Alert>
              
              <Typography variant="body1">
                Are you sure you want to delete <strong>{selectedUser.name}</strong> ({selectedUser.email})?
              </Typography>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteModalOpen(false)}>Cancel</Button>
          <Button onClick={handleDeleteUser} variant="contained" color="error">
            Delete User
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default AdminUsersPage;

================
File: frontend/src/pages/auth/ForgotPasswordPage.tsx
================
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import {
  Box,
  TextField,
  Button,
  Typography,
  Alert,
  Container,
  Paper,
  Divider,
} from '@mui/material';
import { Formik, Form, Field } from 'formik';
import * as Yup from 'yup';
import type { ForgotPasswordRequest } from '../../types/api';
import { apiService } from '../../services/api';

const validationSchema = Yup.object({
  email: Yup.string()
    .trim()
    .email('Email must be a valid email address')
    .required('Email is required'),
});

const ForgotPasswordPage: React.FC = () => {
  const [error, setError] = useState<string>('');
  const [success, setSuccess] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (values: ForgotPasswordRequest) => {
    setError('');
    setSuccess('');
    setIsLoading(true);

    try {
      await apiService.forgotPassword(values);
      setSuccess('If an account with that email exists, a password reset link has been sent.');
    } catch (err: any) {
      setError(err.response?.data?.message || 'Failed to send password reset email. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="sm">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          py: 4,
        }}
      >
        <Paper elevation={3} sx={{ p: 4 }}>
          <Box sx={{ textAlign: 'center', mb: 4 }}>
            <Typography component="h1" variant="h4" gutterBottom>
              HOA Community Hub
            </Typography>
            <Typography variant="h5" color="text.secondary">
              Reset Password
            </Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
              Enter your email address and we'll send you a link to reset your password.
            </Typography>
          </Box>

          {error && (
            <Alert severity="error" sx={{ mb: 3 }}>
              {error}
            </Alert>
          )}

          {success && (
            <Alert severity="success" sx={{ mb: 3 }}>
              {success}
            </Alert>
          )}

          <Formik
            initialValues={{
              email: '',
            }}
            validationSchema={validationSchema}
            onSubmit={handleSubmit}
          >
            {({ errors, touched, isSubmitting }) => (
              <Form>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                  <Field
                    as={TextField}
                    name="email"
                    type="email"
                    label="Email Address"
                    fullWidth
                    autoComplete="email"
                    autoFocus
                    error={touched.email && !!errors.email}
                    helperText={touched.email && errors.email}
                  />

                  <Button
                    type="submit"
                    fullWidth
                    variant="contained"
                    size="large"
                    disabled={isLoading || isSubmitting}
                    sx={{ mt: 2 }}
                  >
                    {isLoading ? 'Sending...' : 'Send Reset Link'}
                  </Button>
                </Box>
              </Form>
            )}
          </Formik>

          <Divider sx={{ my: 3 }} />

          <Box sx={{ textAlign: 'center', display: 'flex', flexDirection: 'column', gap: 2 }}>
            <Typography variant="body2">
              Remember your password?{' '}
              <Link
                to="/login"
                style={{ textDecoration: 'none', fontWeight: 'bold' }}
              >
                Sign in here
              </Link>
            </Typography>
            
            <Typography variant="body2">
              Don't have an account?{' '}
              <Link
                to="/register"
                style={{ textDecoration: 'none', fontWeight: 'bold' }}
              >
                Sign up here
              </Link>
            </Typography>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default ForgotPasswordPage;

================
File: frontend/src/pages/auth/LoginPage.tsx
================
import React, { useState } from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Alert,
  Container,
  Paper,
  Divider,
} from '@mui/material';
import { Formik, Form, Field } from 'formik';
import * as Yup from 'yup';
import type { LoginRequest } from '../../types/api';
import { useAuth } from '../../contexts/AuthContext';
import { useNotification } from '../../contexts/NotificationContext';

const validationSchema = Yup.object({
  email: Yup.string()
    .email('Invalid email address')
    .required('Email is required'),
  password: Yup.string()
    .required('Password is required'),
});

const LoginPage: React.FC = () => {
  const [error, setError] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  const { login } = useAuth();
  const { showSuccess, showError } = useNotification();
  const navigate = useNavigate();
  const location = useLocation();

  const from = location.state?.from?.pathname || '/dashboard';

  const handleSubmit = async (values: LoginRequest) => {
    setError('');
    setIsLoading(true);

    try {
      await login(values);
      showSuccess('Welcome back! You have successfully signed in.');
      navigate(from, { replace: true });
    } catch (err: any) {
      // Backend returns errors in { error: "message" } format
      const errorMessage = err.response?.data?.error ||
                          err.response?.data?.message ||
                          'Login failed. Please try again.';
      setError(errorMessage);
      showError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="sm">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          py: 4,
        }}
      >
        <Paper elevation={3} sx={{ p: 4 }}>
          <Box sx={{ textAlign: 'center', mb: 4 }}>
            <Typography component="h1" variant="h4" gutterBottom>
              HOA Community Hub
            </Typography>
            <Typography variant="h5" color="text.secondary">
              Sign In
            </Typography>
          </Box>

          {error && (
            <Alert severity="error" sx={{ mb: 3 }}>
              {error}
            </Alert>
          )}

          <Formik
            initialValues={{
              email: '',
              password: '',
            }}
            validationSchema={validationSchema}
            onSubmit={handleSubmit}
          >
            {({ errors, touched, isSubmitting }) => (
              <Form>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                  <Field
                    as={TextField}
                    name="email"
                    type="email"
                    label="Email Address"
                    fullWidth
                    autoComplete="email"
                    autoFocus
                    error={touched.email && !!errors.email}
                    helperText={touched.email && errors.email}
                  />

                  <Field
                    as={TextField}
                    name="password"
                    type="password"
                    label="Password"
                    fullWidth
                    autoComplete="current-password"
                    error={touched.password && !!errors.password}
                    helperText={touched.password && errors.password}
                  />

                  <Button
                    type="submit"
                    fullWidth
                    variant="contained"
                    size="large"
                    disabled={isLoading || isSubmitting}
                    sx={{ mt: 2 }}
                  >
                    {isLoading ? 'Signing In...' : 'Sign In'}
                  </Button>
                </Box>
              </Form>
            )}
          </Formik>

          <Divider sx={{ my: 3 }} />

          <Box sx={{ textAlign: 'center', display: 'flex', flexDirection: 'column', gap: 2 }}>
            <Typography variant="body2">
              <Link 
                to="/forgot-password" 
                style={{ textDecoration: 'none', color: 'inherit' }}
              >
                Forgot your password?
              </Link>
            </Typography>
            
            <Typography variant="body2">
              Don't have an account?{' '}
              <Link 
                to="/register" 
                style={{ textDecoration: 'none', fontWeight: 'bold' }}
              >
                Sign up here
              </Link>
            </Typography>

            <Typography variant="body2" color="text.secondary">
              <Link 
                to="/public" 
                style={{ textDecoration: 'none', color: 'inherit' }}
              >
                View public information
              </Link>
            </Typography>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default LoginPage;

================
File: frontend/src/pages/auth/RegisterPage.tsx
================
import React, { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Alert,
  Container,
  Paper,
  Divider,
} from '@mui/material';
import { Formik, Form, Field } from 'formik';
import * as Yup from 'yup';
import type { RegisterRequest } from '../../types/api';
import { useAuth } from '../../contexts/AuthContext';
import { useNotification } from '../../contexts/NotificationContext';

const validationSchema = Yup.object({
  name: Yup.string()
    .trim()
    .min(1, 'Name is required')
    .required('Name is required'),
  email: Yup.string()
    .trim()
    .email('Email must be a valid email address')
    .required('Email is required'),
  password: Yup.string()
    .min(8, 'Password must be at least 8 characters long')
    .matches(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]).*$/,
      'Password must include at least one uppercase letter, one lowercase letter, one number, and one special character'
    )
    .required('Password is required'),
  confirmPassword: Yup.string()
    .oneOf([Yup.ref('password')], 'Password confirmation must match password')
    .required('Password confirmation is required'),
});

const RegisterPage: React.FC = () => {
  const [error, setError] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  const { register } = useAuth();
  const { showSuccess } = useNotification();
  const navigate = useNavigate();

  const handleSubmit = async (values: RegisterRequest & { confirmPassword: string }) => {
    setError('');
    setIsLoading(true);

    try {
      // Remove confirmPassword before sending to API
      const { confirmPassword, ...registerData } = values;
      await register(registerData);
      
      showSuccess('Registration successful. Your account is now pending approval from an administrator.');
      navigate('/login');
    } catch (err: any) {
      if (err.response?.status === 409) {
        setError('An account with this email address already exists.');
      } else {
        setError(err.response?.data?.message || 'Registration failed. Please try again.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="sm">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          py: 4,
        }}
      >
        <Paper elevation={3} sx={{ p: 4 }}>
          <Box sx={{ textAlign: 'center', mb: 4 }}>
            <Typography component="h1" variant="h4" gutterBottom>
              HOA Community Hub
            </Typography>
            <Typography variant="h5" color="text.secondary">
              Create Account
            </Typography>
          </Box>

          {error && (
            <Alert severity="error" sx={{ mb: 3 }}>
              {error}
            </Alert>
          )}

          <Formik
            initialValues={{
              name: '',
              email: '',
              password: '',
              confirmPassword: '',
            }}
            validationSchema={validationSchema}
            onSubmit={handleSubmit}
          >
            {({ errors, touched, isSubmitting }) => (
              <Form>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                  <Field
                    as={TextField}
                    name="name"
                    label="Full Name"
                    fullWidth
                    autoComplete="name"
                    autoFocus
                    error={touched.name && !!errors.name}
                    helperText={touched.name && errors.name}
                  />

                  <Field
                    as={TextField}
                    name="email"
                    type="email"
                    label="Email Address"
                    fullWidth
                    autoComplete="email"
                    error={touched.email && !!errors.email}
                    helperText={touched.email && errors.email}
                  />

                  <Field
                    as={TextField}
                    name="password"
                    type="password"
                    label="Password"
                    fullWidth
                    autoComplete="new-password"
                    error={touched.password && !!errors.password}
                    helperText={touched.password && errors.password}
                  />

                  <Field
                    as={TextField}
                    name="confirmPassword"
                    type="password"
                    label="Confirm Password"
                    fullWidth
                    autoComplete="new-password"
                    error={touched.confirmPassword && !!errors.confirmPassword}
                    helperText={touched.confirmPassword && errors.confirmPassword}
                  />

                  <Button
                    type="submit"
                    fullWidth
                    variant="contained"
                    size="large"
                    disabled={isLoading || isSubmitting}
                    sx={{ mt: 2 }}
                  >
                    {isLoading ? 'Creating Account...' : 'Create Account'}
                  </Button>
                </Box>
              </Form>
            )}
          </Formik>

          <Divider sx={{ my: 3 }} />

          <Box sx={{ textAlign: 'center' }}>
            <Typography variant="body2">
              Already have an account?{' '}
              <Link
                to="/login"
                style={{ textDecoration: 'none', fontWeight: 'bold' }}
              >
                Sign in here
              </Link>
            </Typography>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default RegisterPage;

================
File: frontend/src/pages/auth/ResetPasswordPage.tsx
================
import React, { useState, useEffect } from 'react';
import { Link, useNavigate, useSearchParams } from 'react-router-dom';
import {
  Box,
  TextField,
  Button,
  Typography,
  Alert,
  Container,
  Paper,
  Divider,
} from '@mui/material';
import { Formik, Form, Field } from 'formik';
import * as Yup from 'yup';
import type { ResetPasswordRequest } from '../../types/api';
import { apiService } from '../../services/api';
import { useNotification } from '../../contexts/NotificationContext';

const validationSchema = Yup.object({
  newPassword: Yup.string()
    .min(8, 'Password must be at least 8 characters long')
    .matches(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]).*$/,
      'Password must include uppercase, lowercase, number, and special character'
    )
    .required('New password is required'),
  confirmNewPassword: Yup.string()
    .oneOf([Yup.ref('newPassword')], 'Password confirmation must match password')
    .required('Password confirmation is required'),
});

const ResetPasswordPage: React.FC = () => {
  const [searchParams] = useSearchParams();
  const [error, setError] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  const [token, setToken] = useState<string>('');
  const { showSuccess } = useNotification();
  const navigate = useNavigate();

  useEffect(() => {
    const tokenFromUrl = searchParams.get('token');
    if (!tokenFromUrl) {
      setError('Invalid or missing reset token. Please request a new password reset.');
    } else {
      setToken(tokenFromUrl);
    }
  }, [searchParams]);

  const handleSubmit = async (values: { newPassword: string; confirmNewPassword: string }) => {
    if (!token) {
      setError('Invalid or missing reset token.');
      return;
    }

    setError('');
    setIsLoading(true);

    try {
      const resetData: ResetPasswordRequest = {
        token,
        newPassword: values.newPassword,
      };
      
      await apiService.resetPassword(resetData);
      showSuccess('Password has been reset successfully. You can now sign in with your new password.');
      navigate('/login');
    } catch (err: any) {
      if (err.response?.status === 400) {
        setError('Invalid or expired reset token. Please request a new password reset.');
      } else {
        setError(err.response?.data?.message || 'Failed to reset password. Please try again.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  if (!token && !error) {
    return (
      <Container component="main" maxWidth="sm">
        <Box
          sx={{
            minHeight: '100vh',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center',
          }}
        >
          <Typography variant="h6">Loading...</Typography>
        </Box>
      </Container>
    );
  }

  return (
    <Container component="main" maxWidth="sm">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          py: 4,
        }}
      >
        <Paper elevation={3} sx={{ p: 4 }}>
          <Box sx={{ textAlign: 'center', mb: 4 }}>
            <Typography component="h1" variant="h4" gutterBottom>
              HOA Community Hub
            </Typography>
            <Typography variant="h5" color="text.secondary">
              Set New Password
            </Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
              Enter your new password below.
            </Typography>
          </Box>

          {error && (
            <Alert severity="error" sx={{ mb: 3 }}>
              {error}
            </Alert>
          )}

          {token && (
            <Formik
              initialValues={{
                newPassword: '',
                confirmNewPassword: '',
              }}
              validationSchema={validationSchema}
              onSubmit={handleSubmit}
            >
              {({ errors, touched, isSubmitting }) => (
                <Form>
                  <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                    <Field
                      as={TextField}
                      name="newPassword"
                      type="password"
                      label="New Password"
                      fullWidth
                      autoComplete="new-password"
                      autoFocus
                      error={touched.newPassword && !!errors.newPassword}
                      helperText={touched.newPassword && errors.newPassword}
                    />

                    <Field
                      as={TextField}
                      name="confirmNewPassword"
                      type="password"
                      label="Confirm New Password"
                      fullWidth
                      autoComplete="new-password"
                      error={touched.confirmNewPassword && !!errors.confirmNewPassword}
                      helperText={touched.confirmNewPassword && errors.confirmNewPassword}
                    />

                    <Button
                      type="submit"
                      fullWidth
                      variant="contained"
                      size="large"
                      disabled={isLoading || isSubmitting}
                      sx={{ mt: 2 }}
                    >
                      {isLoading ? 'Resetting Password...' : 'Reset Password'}
                    </Button>
                  </Box>
                </Form>
              )}
            </Formik>
          )}

          <Divider sx={{ my: 3 }} />

          <Box sx={{ textAlign: 'center' }}>
            <Typography variant="body2">
              Remember your password?{' '}
              <Link
                to="/login"
                style={{ textDecoration: 'none', fontWeight: 'bold' }}
              >
                Sign in here
              </Link>
            </Typography>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default ResetPasswordPage;

================
File: frontend/src/pages/member/AnnouncementsPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Typography,
  Box,
  Card,
  CardContent,
  Pagination,
  Alert,
  CircularProgress,
  Divider,
} from '@mui/material';
import { useNotification } from '../../contexts/NotificationContext';
import { apiService } from '../../services/api';
import type { Announcement, PaginatedResponse } from '../../types/api';

const AnnouncementsPage: React.FC = () => {
  const [announcements, setAnnouncements] = useState<Announcement[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string>('');
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [totalCount, setTotalCount] = useState(0);
  const { showError } = useNotification();

  const itemsPerPage = 10;

  const fetchAnnouncements = async (page: number = 1) => {
    setLoading(true);
    setError('');
    
    try {
      const response: PaginatedResponse<Announcement> = await apiService.getAnnouncements({
        page,
        limit: itemsPerPage,
        status: 'active', // Only fetch active announcements
        sortBy: 'created_at',
        sortOrder: 'desc', // Most recent first
      });

      setAnnouncements(response.data);
      setTotalCount(response.pagination.totalItems);
      setTotalPages(response.pagination.totalPages);
      setCurrentPage(page);
    } catch (err: any) {
      const errorMessage = err.response?.data?.error || 
                          err.response?.data?.message || 
                          'Failed to load announcements. Please try again.';
      setError(errorMessage);
      showError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchAnnouncements(1);
  }, []);

  const handlePageChange = (event: React.ChangeEvent<unknown>, page: number) => {
    fetchAnnouncements(page);
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };


  if (loading) {
    return (
      <Box>
        <Typography variant="h4" gutterBottom>
          Announcements
        </Typography>
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
          <CircularProgress />
        </Box>
      </Box>
    );
  }

  if (error) {
    return (
      <Box>
        <Typography variant="h4" gutterBottom>
          Announcements
        </Typography>
        <Alert severity="error" sx={{ mt: 2 }}>
          {error}
        </Alert>
      </Box>
    );
  }

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Announcements
      </Typography>

      {announcements.length === 0 ? (
        <Box sx={{ textAlign: 'center', mt: 4, py: 8 }}>
          <Typography variant="h6" color="text.secondary" gutterBottom>
            No announcements found
          </Typography>
          <Typography variant="body2" color="text.secondary">
            There are currently no active announcements to display.
          </Typography>
        </Box>
      ) : (
        <>
          <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
            Showing {announcements.length} of {totalCount} announcements
          </Typography>

          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
            {announcements.map((announcement) => (
              <Card key={announcement.id} elevation={2}>
                <CardContent>
                  <Typography variant="h5" component="h2" gutterBottom>
                    {announcement.title}
                  </Typography>

                  <Box sx={{ mb: 2 }}>
                    <Typography variant="body2" color="text.secondary">
                      By {announcement.creator?.name || 'Unknown'}  {formatDate(announcement.created_at)}
                    </Typography>
                  </Box>

                  <Divider sx={{ mb: 2 }} />

                  <Box 
                    sx={{ 
                      '& p': { mb: 1 },
                      '& h1, & h2, & h3, & h4, & h5, & h6': { mb: 1, mt: 2 },
                      '& ul, & ol': { mb: 1, pl: 2 },
                      '& blockquote': { 
                        borderLeft: '4px solid #ccc', 
                        pl: 2, 
                        ml: 0, 
                        fontStyle: 'italic',
                        color: 'text.secondary'
                      }
                    }}
                    dangerouslySetInnerHTML={{ 
                      __html: announcement.content 
                    }}
                  />

                  {announcement.updated_at !== announcement.created_at && (
                    <Box sx={{ mt: 2, pt: 2, borderTop: '1px solid', borderColor: 'divider' }}>
                      <Typography variant="caption" color="text.secondary">
                        Last updated: {formatDate(announcement.updated_at)}
                      </Typography>
                    </Box>
                  )}
                </CardContent>
              </Card>
            ))}
          </Box>

          {totalPages > 1 && (
            <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
              <Pagination
                count={totalPages}
                page={currentPage}
                onChange={handlePageChange}
                color="primary"
                size="large"
                showFirstButton
                showLastButton
              />
            </Box>
          )}
        </>
      )}
    </Box>
  );
};

export default AnnouncementsPage;

================
File: frontend/src/pages/member/DashboardPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Grid,
  Card,
  CardContent,
  Typography,
  Alert,
  CircularProgress,
  Button,
  Chip,
} from '@mui/material';
import {
  Announcement as AnnouncementIcon,
  Event as EventIcon,
  Description as DocumentIcon,
  Forum as ForumIcon,
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import type { Announcement, Event } from '../../types/api';
import { apiService } from '../../services/api';
import { useAuth } from '../../contexts/AuthContext';

const DashboardPage: React.FC = () => {
  const [announcements, setAnnouncements] = useState<Announcement[]>([]);
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string>('');
  const navigate = useNavigate();
  const { user } = useAuth();

  useEffect(() => {
    const fetchDashboardData = async () => {
      try {
        setLoading(true);
        
        // Fetch recent announcements
        const announcementsResponse = await apiService.getAnnouncements({
          limit: 5,
          status: 'active',
          sortBy: 'created_at',
          sortOrder: 'desc',
        });
        
        // Fetch upcoming events
        const eventsResponse = await apiService.getEvents({
          status: 'upcoming',
          limit: 5,
          sortBy: 'event_date',
          sortOrder: 'asc',
        });

        setAnnouncements(announcementsResponse.data);
        setEvents(eventsResponse.data);
      } catch (err: any) {
        setError('Failed to load dashboard data');
        console.error('Dashboard error:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchDashboardData();
  }, []);

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="400px">
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Welcome back, {user?.name}!
      </Typography>
      
      <Typography variant="body1" color="text.secondary" sx={{ mb: 4 }}>
        Here's what's happening in your community.
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}

      <Grid container spacing={3}>
        {/* Quick Actions */}
        <Grid size={12}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                Quick Actions
              </Typography>
              <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
                <Button
                  variant="outlined"
                  startIcon={<AnnouncementIcon />}
                  onClick={() => navigate('/announcements')}
                >
                  View Announcements
                </Button>
                <Button
                  variant="outlined"
                  startIcon={<EventIcon />}
                  onClick={() => navigate('/events')}
                >
                  View Events
                </Button>
                <Button
                  variant="outlined"
                  startIcon={<DocumentIcon />}
                  onClick={() => navigate('/documents')}
                >
                  Browse Documents
                </Button>
                <Button
                  variant="outlined"
                  startIcon={<ForumIcon />}
                  onClick={() => navigate('/discussions')}
                >
                  Join Discussions
                </Button>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Recent Announcements */}
        <Grid size={{ xs: 12, md: 6 }}>
          <Card>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h6">
                  Recent Announcements
                </Typography>
                <Button size="small" onClick={() => navigate('/announcements')}>
                  View All
                </Button>
              </Box>
              
              {announcements.length === 0 ? (
                <Typography color="text.secondary">
                  No recent announcements
                </Typography>
              ) : (
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                  {announcements.map((announcement) => (
                    <Box key={announcement.id} sx={{ p: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
                      <Typography variant="subtitle2" gutterBottom>
                        {announcement.title}
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                        {announcement.content.replace(/<[^>]*>/g, '').substring(0, 100)}...
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        {new Date(announcement.created_at).toLocaleDateString()}
                      </Typography>
                    </Box>
                  ))}
                </Box>
              )}
            </CardContent>
          </Card>
        </Grid>

        {/* Upcoming Events */}
        <Grid size={{ xs: 12, md: 6 }}>
          <Card>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h6">
                  Upcoming Events
                </Typography>
                <Button size="small" onClick={() => navigate('/events')}>
                  View All
                </Button>
              </Box>
              
              {events.length === 0 ? (
                <Typography color="text.secondary">
                  No upcoming events
                </Typography>
              ) : (
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                  {events.map((event) => (
                    <Box key={event.id} sx={{ p: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
                      <Typography variant="subtitle2" gutterBottom>
                        {event.title}
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                        {event.description.substring(0, 100)}...
                      </Typography>
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <Typography variant="caption" color="text.secondary">
                          {event.location}
                        </Typography>
                        <Chip 
                          label={new Date(event.start_date).toLocaleDateString()} 
                          size="small" 
                          color="primary" 
                          variant="outlined"
                        />
                      </Box>
                    </Box>
                  ))}
                </Box>
              )}
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    </Box>
  );
};

export default DashboardPage;

================
File: frontend/src/pages/member/DiscussionsPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  Card,
  CardContent,
  Chip,
  Pagination,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Alert,
} from '@mui/material';
import {
  Add as AddIcon,
  Forum as ForumIcon,
  Person as PersonIcon,
  Schedule as ScheduleIcon,
  Reply as ReplyIcon,
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { apiService } from '../../services/api';
import { useNotification } from '../../contexts/NotificationContext';
import { useApiNotifications } from '../../hooks/useApiNotifications';
import type { Discussion, PaginatedResponse } from '../../types/api';

const DiscussionsPage: React.FC = () => {
  const navigate = useNavigate();
  const { showSuccess, showError } = useNotification();
  useApiNotifications(); // Set up API error handling
  
  const [discussions, setDiscussions] = useState<Discussion[]>([]);
  const [loading, setLoading] = useState(true);
  const [pagination, setPagination] = useState({
    totalItems: 0,
    totalPages: 0,
    currentPage: 1,
    limit: 10,
  });
  
  // New Discussion Dialog
  const [dialogOpen, setDialogOpen] = useState(false);
  const [newDiscussion, setNewDiscussion] = useState({
    title: '',
    content: '',
  });
  const [submitting, setSubmitting] = useState(false);
  const [errors, setErrors] = useState<{ title?: string; content?: string }>({});

  const fetchDiscussions = async (page: number = 1) => {
    try {
      setLoading(true);
      const response: PaginatedResponse<Discussion> = await apiService.getDiscussions({
        page,
        limit: 10,
      });
      
      setDiscussions(response.data);
      setPagination(response.pagination);
    } catch (err: any) {
      const errorMessage = err.response?.data?.error ||
                          err.response?.data?.message ||
                          'Failed to load discussions. Please try again.';
      showError(errorMessage);
      // Ensure discussions is always an array even on error
      setDiscussions([]);
      setPagination({
        totalItems: 0,
        totalPages: 0,
        currentPage: 1,
        limit: 10,
      });
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchDiscussions();
  }, []);

  const handlePageChange = (_: React.ChangeEvent<unknown>, page: number) => {
    fetchDiscussions(page);
  };

  const handleOpenDialog = () => {
    setDialogOpen(true);
    setNewDiscussion({ title: '', content: '' });
    setErrors({});
  };

  const handleCloseDialog = () => {
    setDialogOpen(false);
    setNewDiscussion({ title: '', content: '' });
    setErrors({});
  };

  const validateForm = () => {
    const newErrors: { title?: string; content?: string } = {};
    
    if (!newDiscussion.title.trim()) {
      newErrors.title = 'Title is required';
    } else if (newDiscussion.title.length > 200) {
      newErrors.title = 'Title must be less than 200 characters';
    }
    
    if (!newDiscussion.content.trim()) {
      newErrors.content = 'Content is required';
    } else if (newDiscussion.content.length > 5000) {
      newErrors.content = 'Content must be less than 5000 characters';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmitDiscussion = async () => {
    if (!validateForm()) return;
    
    try {
      setSubmitting(true);
      await apiService.createDiscussion({
        title: newDiscussion.title.trim(),
        content: newDiscussion.content.trim(),
      });
      
      showSuccess('Discussion thread created successfully!');
      handleCloseDialog();
      fetchDiscussions(1); // Refresh to show new discussion
    } catch (err: any) {
      const errorMessage = err.response?.data?.error || 
                          err.response?.data?.message || 
                          'Failed to create discussion. Please try again.';
      showError(errorMessage);
    } finally {
      setSubmitting(false);
    }
  };

  const handleDiscussionClick = (discussionId: number) => {
    navigate(`/discussions/${discussionId}`);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffInHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);
    
    if (diffInHours < 24) {
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } else if (diffInHours < 24 * 7) {
      return date.toLocaleDateString([], { weekday: 'short', hour: '2-digit', minute: '2-digit' });
    } else {
      return date.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
    }
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="400px">
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      {/* Header */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Box display="flex" alignItems="center" gap={1}>
          <ForumIcon color="primary" />
          <Typography variant="h4" component="h1">
            Community Discussions
          </Typography>
        </Box>
        <Button
          variant="contained"
          startIcon={<AddIcon />}
          onClick={handleOpenDialog}
        >
          Start New Discussion
        </Button>
      </Box>

      {/* Discussions List */}
      {!discussions || discussions.length === 0 ? (
        <Card>
          <CardContent>
            <Box textAlign="center" py={4}>
              <ForumIcon sx={{ fontSize: 64, color: 'text.secondary', mb: 2 }} />
              <Typography variant="h6" color="text.secondary" gutterBottom>
                No discussions yet
              </Typography>
              <Typography variant="body2" color="text.secondary" mb={3}>
                Be the first to start a community discussion!
              </Typography>
              <Button
                variant="contained"
                startIcon={<AddIcon />}
                onClick={handleOpenDialog}
              >
                Start New Discussion
              </Button>
            </Box>
          </CardContent>
        </Card>
      ) : (
        <Box display="flex" flexDirection="column" gap={2}>
          {discussions && discussions.map((discussion) => (
            <Card
              key={discussion.id}
              sx={{
                cursor: 'pointer',
                transition: 'all 0.2s ease-in-out',
                '&:hover': {
                  transform: 'translateY(-2px)',
                  boxShadow: 4,
                },
              }}
              onClick={() => handleDiscussionClick(discussion.id)}
            >
              <CardContent>
                <Box display="flex" justifyContent="space-between" alignItems="flex-start" mb={2}>
                  <Typography variant="h6" component="h2" sx={{ fontWeight: 600 }}>
                    {discussion.title}
                  </Typography>
                  <Box display="flex" alignItems="center" gap={1}>
                    {discussion.reply_count !== undefined && discussion.reply_count > 0 && (
                      <Chip
                        icon={<ReplyIcon />}
                        label={`${discussion.reply_count} ${discussion.reply_count === 1 ? 'reply' : 'replies'}`}
                        size="small"
                        color="primary"
                        variant="outlined"
                      />
                    )}
                  </Box>
                </Box>
                
                <Typography
                  variant="body2"
                  color="text.secondary"
                  sx={{
                    mb: 2,
                    display: '-webkit-box',
                    WebkitLineClamp: 2,
                    WebkitBoxOrient: 'vertical',
                    overflow: 'hidden',
                  }}
                  dangerouslySetInnerHTML={{ __html: discussion.content }}
                />
                
                <Box display="flex" justifyContent="space-between" alignItems="center">
                  <Box display="flex" alignItems="center" gap={2}>
                    <Box display="flex" alignItems="center" gap={0.5}>
                      <PersonIcon fontSize="small" color="action" />
                      <Typography variant="body2" color="text.secondary">
                        {discussion.author?.name || 'Unknown User'}
                      </Typography>
                    </Box>
                    <Box display="flex" alignItems="center" gap={0.5}>
                      <ScheduleIcon fontSize="small" color="action" />
                      <Typography variant="body2" color="text.secondary">
                        {formatDate(discussion.created_at)}
                      </Typography>
                    </Box>
                  </Box>
                </Box>
              </CardContent>
            </Card>
          ))}
        </Box>
      )}

      {/* Pagination */}
      {pagination.totalPages > 1 && (
        <Box display="flex" justifyContent="center" mt={4}>
          <Pagination
            count={pagination.totalPages}
            page={pagination.currentPage}
            onChange={handlePageChange}
            color="primary"
            size="large"
          />
        </Box>
      )}

      {/* New Discussion Dialog */}
      <Dialog
        open={dialogOpen}
        onClose={handleCloseDialog}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Start New Discussion</DialogTitle>
        <DialogContent>
          <Box display="flex" flexDirection="column" gap={2} pt={1}>
            <TextField
              label="Discussion Title"
              value={newDiscussion.title}
              onChange={(e) => setNewDiscussion(prev => ({ ...prev, title: e.target.value }))}
              error={!!errors.title}
              helperText={errors.title || `${newDiscussion.title.length}/200 characters`}
              fullWidth
              inputProps={{ maxLength: 200 }}
            />
            <TextField
              label="Content"
              value={newDiscussion.content}
              onChange={(e) => setNewDiscussion(prev => ({ ...prev, content: e.target.value }))}
              error={!!errors.content}
              helperText={errors.content || `${newDiscussion.content.length}/5000 characters`}
              multiline
              rows={6}
              fullWidth
              inputProps={{ maxLength: 5000 }}
            />
            <Alert severity="info">
              You can use basic HTML formatting in your content (e.g., &lt;b&gt;bold&lt;/b&gt;, &lt;i&gt;italic&lt;/i&gt;, &lt;br&gt; for line breaks).
            </Alert>
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog} disabled={submitting}>
            Cancel
          </Button>
          <Button
            onClick={handleSubmitDiscussion}
            variant="contained"
            disabled={submitting || !newDiscussion.title.trim() || !newDiscussion.content.trim()}
          >
            {submitting ? <CircularProgress size={20} /> : 'Create Discussion'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default DiscussionsPage;

================
File: frontend/src/pages/member/DiscussionThreadPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  Card,
  CardContent,
  TextField,
  CircularProgress,
  Alert,
  Divider,
  Avatar,
  Chip,
} from '@mui/material';
import {
  ArrowBack as ArrowBackIcon,
  Reply as ReplyIcon,
  Person as PersonIcon,
  Schedule as ScheduleIcon,
  Send as SendIcon,
} from '@mui/icons-material';
import { useParams, useNavigate } from 'react-router-dom';
import { apiService } from '../../services/api';
import { useNotification } from '../../contexts/NotificationContext';
import { useApiNotifications } from '../../hooks/useApiNotifications';
import type { Discussion, DiscussionThreadResponse } from '../../types/api';

const DiscussionThreadPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { showSuccess, showError } = useNotification();
  useApiNotifications(); // Set up API error handling
  
  const [threadData, setThreadData] = useState<DiscussionThreadResponse | null>(null);
  const [loading, setLoading] = useState(true);
  const [replyContent, setReplyContent] = useState('');
  const [submittingReply, setSubmittingReply] = useState(false);
  const [replyError, setReplyError] = useState('');

  const fetchThread = async () => {
    if (!id) return;
    
    try {
      setLoading(true);
      const response = await apiService.getDiscussionThread(parseInt(id));
      
      // Ensure we have valid data structure
      if (response && response.mainThread && response.replies) {
        setThreadData(response);
      } else {
        // Handle unexpected response structure
        setThreadData(null);
        showError('Invalid discussion thread data received.');
      }
    } catch (err: any) {
      const errorMessage = err.response?.data?.error ||
                          err.response?.data?.message ||
                          'Failed to load discussion thread. Please try again.';
      showError(errorMessage);
      
      // If thread not found, redirect back to discussions
      if (err.response?.status === 404) {
        setTimeout(() => navigate('/discussions'), 2000);
      }
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchThread();
  }, [id]);

  const handleBackClick = () => {
    navigate('/discussions');
  };

  const validateReply = () => {
    if (!replyContent.trim()) {
      setReplyError('Reply content is required');
      return false;
    }
    if (replyContent.length > 5000) {
      setReplyError('Reply must be less than 5000 characters');
      return false;
    }
    setReplyError('');
    return true;
  };

  const handleSubmitReply = async () => {
    if (!validateReply() || !id) return;
    
    try {
      setSubmittingReply(true);
      await apiService.createReply(parseInt(id), {
        content: replyContent.trim(),
      });
      
      showSuccess('Reply posted successfully!');
      setReplyContent('');
      fetchThread(); // Refresh to show new reply
    } catch (err: any) {
      const errorMessage = err.response?.data?.error || 
                          err.response?.data?.message || 
                          'Failed to post reply. Please try again.';
      showError(errorMessage);
    } finally {
      setSubmittingReply(false);
    }
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffInHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);
    
    if (diffInHours < 1) {
      const diffInMinutes = Math.floor((now.getTime() - date.getTime()) / (1000 * 60));
      return diffInMinutes <= 1 ? 'Just now' : `${diffInMinutes} minutes ago`;
    } else if (diffInHours < 24) {
      return `${Math.floor(diffInHours)} hours ago`;
    } else if (diffInHours < 24 * 7) {
      return date.toLocaleDateString([], { weekday: 'short', hour: '2-digit', minute: '2-digit' });
    } else {
      return date.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' });
    }
  };

  const getInitials = (name: string) => {
    return name
      .split(' ')
      .map(word => word.charAt(0))
      .join('')
      .toUpperCase()
      .slice(0, 2);
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="400px">
        <CircularProgress />
      </Box>
    );
  }

  if (!threadData) {
    return (
      <Box>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={handleBackClick}
          sx={{ mb: 2 }}
        >
          Back to Discussions
        </Button>
        <Alert severity="error">
          Discussion thread not found or could not be loaded.
        </Alert>
      </Box>
    );
  }

  const { mainThread, replies } = threadData;

  return (
    <Box>
      {/* Header */}
      <Box display="flex" alignItems="center" gap={2} mb={3}>
        <Button
          startIcon={<ArrowBackIcon />}
          onClick={handleBackClick}
          variant="outlined"
        >
          Back to Discussions
        </Button>
        <Box display="flex" alignItems="center" gap={1}>
          <Chip
            icon={<ReplyIcon />}
            label={`${replies?.length || 0} ${(replies?.length || 0) === 1 ? 'reply' : 'replies'}`}
            size="small"
            color="primary"
            variant="outlined"
          />
        </Box>
      </Box>

      {/* Main Thread */}
      <Card sx={{ mb: 3 }}>
        <CardContent>
          <Typography variant="h4" component="h1" gutterBottom sx={{ fontWeight: 600 }}>
            {mainThread.title}
          </Typography>
          
          <Box display="flex" alignItems="center" gap={2} mb={3}>
            <Avatar sx={{ bgcolor: 'primary.main', width: 40, height: 40 }}>
              {getInitials(mainThread.author?.name || 'Unknown User')}
            </Avatar>
            <Box>
              <Typography variant="subtitle1" sx={{ fontWeight: 500 }}>
                {mainThread.author?.name || 'Unknown User'}
              </Typography>
              <Box display="flex" alignItems="center" gap={0.5}>
                <ScheduleIcon fontSize="small" color="action" />
                <Typography variant="body2" color="text.secondary">
                  {formatDate(mainThread.created_at)}
                </Typography>
              </Box>
            </Box>
          </Box>
          
          <Typography
            variant="body1"
            sx={{ lineHeight: 1.7 }}
            dangerouslySetInnerHTML={{ __html: mainThread.content }}
          />
        </CardContent>
      </Card>

      {/* Replies Section */}
      <Typography variant="h5" component="h2" gutterBottom sx={{ fontWeight: 600 }}>
        Replies ({replies?.length || 0})
      </Typography>

      {!replies || replies.length === 0 ? (
        <Card sx={{ mb: 3 }}>
          <CardContent>
            <Box textAlign="center" py={3}>
              <ReplyIcon sx={{ fontSize: 48, color: 'text.secondary', mb: 2 }} />
              <Typography variant="h6" color="text.secondary" gutterBottom>
                No replies yet
              </Typography>
              <Typography variant="body2" color="text.secondary">
                Be the first to reply to this discussion!
              </Typography>
            </Box>
          </CardContent>
        </Card>
      ) : (
        <Box display="flex" flexDirection="column" gap={2} mb={3}>
          {replies && replies.map((reply, index) => (
            <Card key={reply.id}>
              <CardContent>
                <Box display="flex" alignItems="flex-start" gap={2}>
                  <Avatar sx={{ bgcolor: 'secondary.main', width: 36, height: 36 }}>
                    {getInitials(reply.author?.name || 'Unknown User')}
                  </Avatar>
                  <Box flex={1}>
                    <Box display="flex" alignItems="center" gap={2} mb={1}>
                      <Typography variant="subtitle2" sx={{ fontWeight: 500 }}>
                        {reply.author?.name || 'Unknown User'}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        {formatDate(reply.created_at)}
                      </Typography>
                    </Box>
                    <Typography
                      variant="body2"
                      sx={{ lineHeight: 1.6 }}
                      dangerouslySetInnerHTML={{ __html: reply.content }}
                    />
                  </Box>
                </Box>
              </CardContent>
            </Card>
          ))}
        </Box>
      )}

      <Divider sx={{ my: 3 }} />

      {/* Reply Form */}
      <Card>
        <CardContent>
          <Typography variant="h6" component="h3" gutterBottom sx={{ fontWeight: 600 }}>
            Post a Reply
          </Typography>
          
          <Box display="flex" flexDirection="column" gap={2}>
            <TextField
              label="Your Reply"
              value={replyContent}
              onChange={(e) => setReplyContent(e.target.value)}
              error={!!replyError}
              helperText={replyError || `${replyContent.length}/5000 characters`}
              multiline
              rows={4}
              fullWidth
              inputProps={{ maxLength: 5000 }}
              placeholder="Share your thoughts..."
            />
            
            <Alert severity="info" sx={{ mb: 2 }}>
              You can use basic HTML formatting in your reply (e.g., &lt;b&gt;bold&lt;/b&gt;, &lt;i&gt;italic&lt;/i&gt;, &lt;br&gt; for line breaks).
            </Alert>
            
            <Box display="flex" justifyContent="flex-end">
              <Button
                variant="contained"
                startIcon={submittingReply ? <CircularProgress size={16} /> : <SendIcon />}
                onClick={handleSubmitReply}
                disabled={submittingReply || !replyContent.trim()}
              >
                {submittingReply ? 'Posting...' : 'Post Reply'}
              </Button>
            </Box>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
};

export default DiscussionThreadPage;

================
File: frontend/src/pages/member/DocumentsPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Typography,
  Box,
  Card,
  CardContent,
  Button,
  Alert,
  CircularProgress,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  TextField,
  InputAdornment,
  Pagination,
  Chip,
} from '@mui/material';
import { Download, Search, Description, Person, CalendarToday } from '@mui/icons-material';
import { useNotification } from '../../contexts/NotificationContext';
import { apiService } from '../../services/api';
import type { Document, DocumentsResponse } from '../../types/api';

const DocumentsPage: React.FC = () => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string>('');
  const [searchTerm, setSearchTerm] = useState('');
  const [filteredDocuments, setFilteredDocuments] = useState<Document[]>([]);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalCount, setTotalCount] = useState(0);
  const [downloadingIds, setDownloadingIds] = useState<Set<number>>(new Set());
  const { showError, showSuccess } = useNotification();

  const itemsPerPage = 10;

  const fetchDocuments = async (offset: number = 0) => {
    setLoading(true);
    setError('');
    
    try {
      const response: DocumentsResponse = await apiService.getDocuments({
        limit: itemsPerPage,
        offset,
      });

      setDocuments(response.documents);
      setTotalCount(response.count);
      setFilteredDocuments(response.documents);
    } catch (err: any) {
      const errorMessage = err.response?.data?.error || 
                          err.response?.data?.message || 
                          'Failed to load documents. Please try again.';
      setError(errorMessage);
      showError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchDocuments(0);
  }, []);

  // Filter documents based on search term
  useEffect(() => {
    if (!searchTerm.trim()) {
      setFilteredDocuments(documents);
    } else {
      const filtered = documents.filter(doc =>
        doc.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
        doc.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        doc.uploader?.name.toLowerCase().includes(searchTerm.toLowerCase())
      );
      setFilteredDocuments(filtered);
    }
    setCurrentPage(1); // Reset to first page when searching
  }, [searchTerm, documents]);

  const handlePageChange = (event: React.ChangeEvent<unknown>, page: number) => {
    const offset = (page - 1) * itemsPerPage;
    setCurrentPage(page);
    fetchDocuments(offset);
  };

  const handleDownload = async (doc: Document) => {
    setDownloadingIds(prev => new Set(prev).add(doc.id));
    
    try {
      const blob = await apiService.downloadDocument(doc.id);
      
      // Create download link
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = doc.original_file_name;
      document.body.appendChild(link);
      link.click();
      
      // Cleanup
      window.URL.revokeObjectURL(url);
      document.body.removeChild(link);
      
      showSuccess(`Downloaded ${doc.title} successfully!`);
    } catch (err: any) {
      const errorMessage = err.response?.data?.error ||
                          err.response?.data?.message ||
                          'Failed to download document. Please try again.';
      showError(errorMessage);
    } finally {
      setDownloadingIds(prev => {
        const newSet = new Set(prev);
        newSet.delete(doc.id);
        return newSet;
      });
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  const getFileExtension = (filename: string) => {
    return filename.split('.').pop()?.toUpperCase() || 'FILE';
  };

  const totalPages = Math.ceil(totalCount / itemsPerPage);

  if (loading) {
    return (
      <Box>
        <Typography variant="h4" gutterBottom>
          Documents
        </Typography>
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
          <CircularProgress />
        </Box>
      </Box>
    );
  }

  if (error) {
    return (
      <Box>
        <Typography variant="h4" gutterBottom>
          Documents
        </Typography>
        <Alert severity="error" sx={{ mt: 2 }}>
          {error}
        </Alert>
      </Box>
    );
  }

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Documents
      </Typography>

      {/* Search Bar */}
      <Box sx={{ mb: 3 }}>
        <TextField
          fullWidth
          placeholder="Search documents by title, description, or uploader..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <Search />
              </InputAdornment>
            ),
          }}
          sx={{ maxWidth: 500 }}
        />
      </Box>

      {filteredDocuments.length === 0 ? (
        <Box sx={{ textAlign: 'center', mt: 4, py: 8 }}>
          <Typography variant="h6" color="text.secondary" gutterBottom>
            {searchTerm ? 'No documents found' : 'No documents available'}
          </Typography>
          <Typography variant="body2" color="text.secondary">
            {searchTerm 
              ? 'Try adjusting your search terms or clear the search to see all documents.'
              : 'There are currently no documents available for download.'
            }
          </Typography>
        </Box>
      ) : (
        <>
          <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
            {searchTerm 
              ? `Found ${filteredDocuments.length} documents matching "${searchTerm}"`
              : `Showing ${documents.length} of ${totalCount} documents`
            }
          </Typography>

          <TableContainer component={Paper} elevation={2}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Document</TableCell>
                  <TableCell>Description</TableCell>
                  <TableCell>Uploader</TableCell>
                  <TableCell>Upload Date</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell align="center">Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {filteredDocuments.map((document) => (
                  <TableRow key={document.id} hover>
                    <TableCell>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Description color="action" />
                        <Box>
                          <Typography variant="subtitle2" fontWeight="medium">
                            {document.title}
                          </Typography>
                          <Typography variant="caption" color="text.secondary">
                            {getFileExtension(document.original_file_name)}  {document.original_file_name}
                          </Typography>
                        </Box>
                      </Box>
                    </TableCell>
                    
                    <TableCell>
                      <Typography variant="body2" color="text.secondary">
                        {document.description || 'No description provided'}
                      </Typography>
                    </TableCell>
                    
                    <TableCell>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Person fontSize="small" color="action" />
                        <Typography variant="body2">
                          {document.uploader?.name || 'Unknown'}
                        </Typography>
                      </Box>
                    </TableCell>
                    
                    <TableCell>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <CalendarToday fontSize="small" color="action" />
                        <Typography variant="body2">
                          {formatDate(document.uploaded_at)}
                        </Typography>
                      </Box>
                    </TableCell>
                    
                    <TableCell>
                      <Box sx={{ display: 'flex', gap: 1 }}>
                        <Chip 
                          label={document.approved ? 'Approved' : 'Pending'}
                          color={document.approved ? 'success' : 'warning'}
                          size="small"
                        />
                        {document.is_public && (
                          <Chip 
                            label="Public"
                            color="info"
                            size="small"
                          />
                        )}
                      </Box>
                    </TableCell>
                    
                    <TableCell align="center">
                      <Button
                        variant="outlined"
                        size="small"
                        startIcon={<Download />}
                        onClick={() => handleDownload(document)}
                        disabled={downloadingIds.has(document.id)}
                      >
                        {downloadingIds.has(document.id) ? 'Downloading...' : 'Download'}
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>

          {!searchTerm && totalPages > 1 && (
            <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
              <Pagination
                count={totalPages}
                page={currentPage}
                onChange={handlePageChange}
                color="primary"
                size="large"
                showFirstButton
                showLastButton
              />
            </Box>
          )}
        </>
      )}
    </Box>
  );
};

export default DocumentsPage;

================
File: frontend/src/pages/member/EventsPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Typography,
  Box,
  Card,
  CardContent,
  Pagination,
  Alert,
  CircularProgress,
  Tabs,
  Tab,
  Chip,
  Divider,
} from '@mui/material';
import { CalendarToday, LocationOn, Person } from '@mui/icons-material';
import { useNotification } from '../../contexts/NotificationContext';
import { apiService } from '../../services/api';
import type { Event, PaginatedResponse } from '../../types/api';

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`events-tabpanel-${index}`}
      aria-labelledby={`events-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ pt: 3 }}>{children}</Box>}
    </div>
  );
}

const EventsPage: React.FC = () => {
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string>('');
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [totalCount, setTotalCount] = useState(0);
  const [tabValue, setTabValue] = useState(0); // 0 = Upcoming, 1 = Past
  const { showError } = useNotification();

  const itemsPerPage = 10;

  const fetchEvents = async (page: number = 1, isUpcoming: boolean = true) => {
    setLoading(true);
    setError('');
    
    try {
      const response: PaginatedResponse<Event> = await apiService.getEvents({
        status: isUpcoming ? 'upcoming' : 'past',
        page,
        limit: itemsPerPage,
        sortBy: 'event_date',
        sortOrder: isUpcoming ? 'asc' : 'desc', // Upcoming: earliest first, Past: latest first
      });

      setEvents(response.data);
      setTotalCount(response.pagination.totalItems);
      setTotalPages(response.pagination.totalPages);
      setCurrentPage(page);
    } catch (err: any) {
      const errorMessage = err.response?.data?.error || 
                          err.response?.data?.message || 
                          'Failed to load events. Please try again.';
      setError(errorMessage);
      showError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchEvents(1, tabValue === 0);
  }, [tabValue]);

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
    setCurrentPage(1);
  };

  const handlePageChange = (event: React.ChangeEvent<unknown>, page: number) => {
    fetchEvents(page, tabValue === 0);
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  };

  const formatTime = (dateString: string) => {
    return new Date(dateString).toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const formatDateRange = (startDate: string, endDate: string) => {
    const start = new Date(startDate);
    const end = new Date(endDate);
    
    // Same day event
    if (start.toDateString() === end.toDateString()) {
      return `${formatDate(startDate)}  ${formatTime(startDate)} - ${formatTime(endDate)}`;
    }
    
    // Multi-day event
    return `${formatDate(startDate)} - ${formatDate(endDate)}`;
  };

  const isEventPast = (endDate: string) => {
    return new Date(endDate) < new Date();
  };

  if (loading) {
    return (
      <Box>
        <Typography variant="h4" gutterBottom>
          Events
        </Typography>
        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
          <CircularProgress />
        </Box>
      </Box>
    );
  }

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Events
      </Typography>

      <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 3 }}>
        <Tabs value={tabValue} onChange={handleTabChange} aria-label="event filter tabs">
          <Tab label="Upcoming Events" id="events-tab-0" aria-controls="events-tabpanel-0" />
          <Tab label="Past Events" id="events-tab-1" aria-controls="events-tabpanel-1" />
        </Tabs>
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}

      <TabPanel value={tabValue} index={0}>
        {events.length === 0 ? (
          <Box sx={{ textAlign: 'center', mt: 4, py: 8 }}>
            <Typography variant="h6" color="text.secondary" gutterBottom>
              No upcoming events found
            </Typography>
            <Typography variant="body2" color="text.secondary">
              There are currently no upcoming events scheduled.
            </Typography>
          </Box>
        ) : (
          <>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
              Showing {events.length} of {totalCount} upcoming events
            </Typography>

            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              {events.map((event) => (
                <Card key={event.id} elevation={2}>
                  <CardContent>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
                      <Typography variant="h5" component="h2" gutterBottom>
                        {event.title}
                      </Typography>
                      <Chip 
                        label="Upcoming"
                        color="primary"
                        size="small"
                      />
                    </Box>

                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1, mb: 2 }}>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <CalendarToday fontSize="small" color="action" />
                        <Typography variant="body2" color="text.secondary">
                          {formatDateRange(event.start_date, event.end_date)}
                        </Typography>
                      </Box>
                      
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <LocationOn fontSize="small" color="action" />
                        <Typography variant="body2" color="text.secondary">
                          {event.location}
                        </Typography>
                      </Box>
                      
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Person fontSize="small" color="action" />
                        <Typography variant="body2" color="text.secondary">
                          Organized by {event.creator?.name || 'Unknown'}
                        </Typography>
                      </Box>
                    </Box>

                    <Divider sx={{ mb: 2 }} />

                    <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>
                      {event.description}
                    </Typography>

                    {event.updated_at !== event.created_at && (
                      <Box sx={{ mt: 2, pt: 2, borderTop: '1px solid', borderColor: 'divider' }}>
                        <Typography variant="caption" color="text.secondary">
                          Last updated: {formatDate(event.updated_at)}
                        </Typography>
                      </Box>
                    )}
                  </CardContent>
                </Card>
              ))}
            </Box>

            {totalPages > 1 && (
              <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
                <Pagination
                  count={totalPages}
                  page={currentPage}
                  onChange={handlePageChange}
                  color="primary"
                  size="large"
                  showFirstButton
                  showLastButton
                />
              </Box>
            )}
          </>
        )}
      </TabPanel>

      <TabPanel value={tabValue} index={1}>
        {events.length === 0 ? (
          <Box sx={{ textAlign: 'center', mt: 4, py: 8 }}>
            <Typography variant="h6" color="text.secondary" gutterBottom>
              No past events found
            </Typography>
            <Typography variant="body2" color="text.secondary">
              There are no past events to display.
            </Typography>
          </Box>
        ) : (
          <>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
              Showing {events.length} of {totalCount} past events
            </Typography>

            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              {events.map((event) => (
                <Card key={event.id} elevation={2} sx={{ opacity: 0.8 }}>
                  <CardContent>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
                      <Typography variant="h5" component="h2" gutterBottom>
                        {event.title}
                      </Typography>
                      <Chip 
                        label="Past"
                        color="default"
                        size="small"
                      />
                    </Box>

                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1, mb: 2 }}>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <CalendarToday fontSize="small" color="action" />
                        <Typography variant="body2" color="text.secondary">
                          {formatDateRange(event.start_date, event.end_date)}
                        </Typography>
                      </Box>
                      
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <LocationOn fontSize="small" color="action" />
                        <Typography variant="body2" color="text.secondary">
                          {event.location}
                        </Typography>
                      </Box>
                      
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                        <Person fontSize="small" color="action" />
                        <Typography variant="body2" color="text.secondary">
                          Organized by {event.creator?.name || 'Unknown'}
                        </Typography>
                      </Box>
                    </Box>

                    <Divider sx={{ mb: 2 }} />

                    <Typography variant="body1" sx={{ whiteSpace: 'pre-wrap' }}>
                      {event.description}
                    </Typography>

                    {event.updated_at !== event.created_at && (
                      <Box sx={{ mt: 2, pt: 2, borderTop: '1px solid', borderColor: 'divider' }}>
                        <Typography variant="caption" color="text.secondary">
                          Last updated: {formatDate(event.updated_at)}
                        </Typography>
                      </Box>
                    )}
                  </CardContent>
                </Card>
              ))}
            </Box>

            {totalPages > 1 && (
              <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
                <Pagination
                  count={totalPages}
                  page={currentPage}
                  onChange={handlePageChange}
                  color="primary"
                  size="large"
                  showFirstButton
                  showLastButton
                />
              </Box>
            )}
          </>
        )}
      </TabPanel>
    </Box>
  );
};

export default EventsPage;

================
File: frontend/src/pages/member/ProfilePage.tsx
================
import React, { useState } from 'react';
import {
  Typography,
  Box,
  Card,
  CardContent,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Chip,
  Divider,
  Alert,
} from '@mui/material';
import { Formik, Form, Field } from 'formik';
import * as Yup from 'yup';
import { useAuth } from '../../contexts/AuthContext';
import { useNotification } from '../../contexts/NotificationContext';
import { apiService } from '../../services/api';
import type { UpdateProfileRequest, ChangePasswordRequest } from '../../types/api';

// Validation schemas
const editProfileSchema = Yup.object({
  name: Yup.string()
    .required('Name is required')
    .min(2, 'Name must be at least 2 characters')
    .max(100, 'Name must be less than 100 characters'),
});

const changePasswordSchema = Yup.object({
  currentPassword: Yup.string()
    .required('Current password is required'),
  newPassword: Yup.string()
    .required('New password is required')
    .min(8, 'Password must be at least 8 characters')
    .matches(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
      'Password must contain uppercase, lowercase, number, and special character'
    ),
  confirmPassword: Yup.string()
    .required('Please confirm your password')
    .oneOf([Yup.ref('newPassword')], 'Passwords must match'),
});

const ProfilePage: React.FC = () => {
  const { user, updateUser } = useAuth();
  const { showSuccess, showError } = useNotification();
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [passwordDialogOpen, setPasswordDialogOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const handleEditProfile = async (values: UpdateProfileRequest) => {
    setIsLoading(true);
    try {
      const updatedUser = await apiService.updateProfile(values);
      updateUser(updatedUser);
      showSuccess('Profile updated successfully!');
      setEditDialogOpen(false);
    } catch (error: any) {
      const errorMessage = error.response?.data?.error || 
                          error.response?.data?.message || 
                          'Failed to update profile. Please try again.';
      showError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  const handleChangePassword = async (values: ChangePasswordRequest) => {
    setIsLoading(true);
    try {
      await apiService.changePassword(values);
      showSuccess('Password changed successfully!');
      setPasswordDialogOpen(false);
    } catch (error: any) {
      const errorMessage = error.response?.data?.error || 
                          error.response?.data?.message || 
                          'Failed to change password. Please try again.';
      showError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'approved':
        return 'success';
      case 'pending':
        return 'warning';
      case 'rejected':
        return 'error';
      default:
        return 'default';
    }
  };

  const getRoleColor = (role: string) => {
    switch (role) {
      case 'admin':
        return 'error';
      case 'member':
        return 'primary';
      default:
        return 'default';
    }
  };

  if (!user) {
    return (
      <Box>
        <Alert severity="error">
          Unable to load user information. Please try refreshing the page.
        </Alert>
      </Box>
    );
  }

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        My Profile
      </Typography>

      <Box sx={{ display: 'flex', flexDirection: { xs: 'column', md: 'row' }, gap: 3 }}>
        {/* User Information Card */}
        <Box sx={{ flex: 2 }}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                Personal Information
              </Typography>
              <Divider sx={{ mb: 3 }} />
              
              <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                <Box sx={{ display: 'flex', flexDirection: { xs: 'column', sm: 'row' }, gap: 3 }}>
                  <Box sx={{ flex: 1 }}>
                    <Typography variant="subtitle2" color="text.secondary">
                      Name
                    </Typography>
                    <Typography variant="body1">
                      {user.name}
                    </Typography>
                  </Box>
                  
                  <Box sx={{ flex: 1 }}>
                    <Typography variant="subtitle2" color="text.secondary">
                      Email
                    </Typography>
                    <Typography variant="body1">
                      {user.email}
                    </Typography>
                  </Box>
                </Box>
                
                <Box sx={{ display: 'flex', flexDirection: { xs: 'column', sm: 'row' }, gap: 3 }}>
                  <Box sx={{ flex: 1 }}>
                    <Typography variant="subtitle2" color="text.secondary">
                      Role
                    </Typography>
                    <Box sx={{ mt: 0.5 }}>
                      <Chip 
                        label={user.role.charAt(0).toUpperCase() + user.role.slice(1)} 
                        color={getRoleColor(user.role) as any}
                        size="small"
                      />
                    </Box>
                  </Box>
                  
                  <Box sx={{ flex: 1 }}>
                    <Typography variant="subtitle2" color="text.secondary">
                      Account Status
                    </Typography>
                    <Box sx={{ mt: 0.5 }}>
                      <Chip 
                        label={user.status.charAt(0).toUpperCase() + user.status.slice(1)} 
                        color={getStatusColor(user.status) as any}
                        size="small"
                      />
                    </Box>
                  </Box>
                </Box>
                
                {user.created_at && (
                  <Box>
                    <Typography variant="subtitle2" color="text.secondary">
                      Member Since
                    </Typography>
                    <Typography variant="body1">
                      {new Date(user.created_at).toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                      })}
                    </Typography>
                  </Box>
                )}
              </Box>
            </CardContent>
          </Card>
        </Box>

        {/* Actions Card */}
        <Box sx={{ flex: 1 }}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                Account Actions
              </Typography>
              <Divider sx={{ mb: 3 }} />
              
              <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                <Button
                  variant="outlined"
                  fullWidth
                  onClick={() => setEditDialogOpen(true)}
                >
                  Edit Profile
                </Button>
                
                <Button
                  variant="outlined"
                  fullWidth
                  onClick={() => setPasswordDialogOpen(true)}
                >
                  Change Password
                </Button>
              </Box>
            </CardContent>
          </Card>
        </Box>
      </Box>

      {/* Edit Profile Dialog */}
      <Dialog 
        open={editDialogOpen} 
        onClose={() => setEditDialogOpen(false)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>Edit Profile</DialogTitle>
        <Formik
          initialValues={{
            name: user.name,
          }}
          validationSchema={editProfileSchema}
          onSubmit={handleEditProfile}
        >
          {({ errors, touched, isSubmitting }) => (
            <Form>
              <DialogContent>
                <Field
                  as={TextField}
                  name="name"
                  label="Name"
                  fullWidth
                  margin="normal"
                  error={touched.name && !!errors.name}
                  helperText={touched.name && errors.name}
                />
              </DialogContent>
              <DialogActions>
                <Button 
                  onClick={() => setEditDialogOpen(false)}
                  disabled={isLoading}
                >
                  Cancel
                </Button>
                <Button 
                  type="submit" 
                  variant="contained"
                  disabled={isLoading || isSubmitting}
                >
                  {isLoading ? 'Saving...' : 'Save Changes'}
                </Button>
              </DialogActions>
            </Form>
          )}
        </Formik>
      </Dialog>

      {/* Change Password Dialog */}
      <Dialog 
        open={passwordDialogOpen} 
        onClose={() => setPasswordDialogOpen(false)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>Change Password</DialogTitle>
        <Formik
          initialValues={{
            currentPassword: '',
            newPassword: '',
            confirmPassword: '',
          }}
          validationSchema={changePasswordSchema}
          onSubmit={handleChangePassword}
        >
          {({ errors, touched, isSubmitting }) => (
            <Form>
              <DialogContent>
                <Field
                  as={TextField}
                  name="currentPassword"
                  type="password"
                  label="Current Password"
                  fullWidth
                  margin="normal"
                  error={touched.currentPassword && !!errors.currentPassword}
                  helperText={touched.currentPassword && errors.currentPassword}
                />
                
                <Field
                  as={TextField}
                  name="newPassword"
                  type="password"
                  label="New Password"
                  fullWidth
                  margin="normal"
                  error={touched.newPassword && !!errors.newPassword}
                  helperText={touched.newPassword && errors.newPassword}
                />
                
                <Field
                  as={TextField}
                  name="confirmPassword"
                  type="password"
                  label="Confirm New Password"
                  fullWidth
                  margin="normal"
                  error={touched.confirmPassword && !!errors.confirmPassword}
                  helperText={touched.confirmPassword && errors.confirmPassword}
                />
              </DialogContent>
              <DialogActions>
                <Button 
                  onClick={() => setPasswordDialogOpen(false)}
                  disabled={isLoading}
                >
                  Cancel
                </Button>
                <Button 
                  type="submit" 
                  variant="contained"
                  disabled={isLoading || isSubmitting}
                >
                  {isLoading ? 'Changing...' : 'Change Password'}
                </Button>
              </DialogActions>
            </Form>
          )}
        </Formik>
      </Dialog>
    </Box>
  );
};

export default ProfilePage;

================
File: frontend/src/pages/public/PublicHomePage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Container,
  Typography,
  Box,
  Card,
  CardContent,
  Button,
  Chip,
  CircularProgress,
  Alert,
  Paper,
  Divider,
} from '@mui/material';
import {
  GetApp as DownloadIcon,
  Description as DocumentIcon,
  Home as HomeIcon,
} from '@mui/icons-material';
import { apiService } from '../../services/api';
import type { Document, DocumentsResponse } from '../../types/api';

const PublicHomePage: React.FC = () => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Load public documents
  const loadPublicDocuments = async () => {
    try {
      setLoading(true);
      setError(null);
      
      // Call the documents API without authentication to get public documents
      const response: DocumentsResponse = await apiService.getDocuments({
        limit: 20, // Show up to 20 public documents
        offset: 0,
      });
      
      setDocuments(response.documents);
    } catch (err: any) {
      setError('Failed to load public documents');
      console.error('Error loading public documents:', err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadPublicDocuments();
  }, []);

  // Handle document download
  const handleDownloadDocument = async (document: Document) => {
    try {
      const blob = await apiService.downloadDocument(document.id);
      
      // Create download link
      const url = window.URL.createObjectURL(blob);
      const link = window.document.createElement('a');
      link.href = url;
      link.download = document.original_file_name;
      window.document.body.appendChild(link);
      link.click();
      window.document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (err: any) {
      console.error('Failed to download document:', err);
    }
  };

  return (
    <Container component="main" maxWidth="lg">
      <Box sx={{ py: 4 }}>
        {/* Header Section */}
        <Paper elevation={2} sx={{ p: 4, mb: 4, textAlign: 'center' }}>
          <HomeIcon sx={{ fontSize: 48, color: 'primary.main', mb: 2 }} />
          <Typography variant="h3" gutterBottom color="primary">
            Welcome to Our Community
          </Typography>
          <Typography variant="h6" color="text.secondary" sx={{ mb: 2 }}>
            Homeowners Association Information Portal
          </Typography>
          <Typography variant="body1" color="text.secondary">
            Access public documents and information about our community. 
            For full access to announcements, events, and discussions, please log in to your member account.
          </Typography>
          <Box sx={{ mt: 3 }}>
            <Button 
              variant="contained" 
              color="primary" 
              href="/login"
              sx={{ mr: 2 }}
            >
              Member Login
            </Button>
            <Button 
              variant="outlined" 
              color="primary" 
              href="/register"
            >
              Register
            </Button>
          </Box>
        </Paper>

        {/* Public Documents Section */}
        <Box sx={{ mb: 4 }}>
          <Box display="flex" alignItems="center" mb={3}>
            <DocumentIcon sx={{ mr: 1, color: 'primary.main' }} />
            <Typography variant="h4" color="primary">
              Public Documents
            </Typography>
          </Box>
          
          <Typography variant="body1" color="text.secondary" sx={{ mb: 3 }}>
            The following documents are available for public access:
          </Typography>

          {loading && (
            <Box display="flex" justifyContent="center" py={4}>
              <CircularProgress />
            </Box>
          )}

          {error && (
            <Alert severity="error" sx={{ mb: 3 }}>
              {error}
            </Alert>
          )}

          {!loading && !error && documents.length === 0 && (
            <Alert severity="info">
              No public documents are currently available.
            </Alert>
          )}

          {!loading && !error && documents.length > 0 && (
            <Box sx={{ display: 'grid', gridTemplateColumns: { xs: '1fr', md: 'repeat(2, 1fr)', lg: 'repeat(3, 1fr)' }, gap: 3 }}>
              {documents.map((document) => (
                <Card elevation={2} sx={{ height: '100%', display: 'flex', flexDirection: 'column' }} key={document.id}>
                  <CardContent sx={{ flexGrow: 1 }}>
                    <Box display="flex" alignItems="flex-start" mb={2}>
                      <DocumentIcon sx={{ mr: 1, color: 'primary.main', mt: 0.5 }} />
                      <Box flexGrow={1}>
                        <Typography variant="h6" gutterBottom>
                          {document.title}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          {document.original_file_name}
                        </Typography>
                      </Box>
                    </Box>

                    {document.description && (
                      <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                        {document.description.length > 150 
                          ? `${document.description.substring(0, 150)}...` 
                          : document.description
                        }
                      </Typography>
                    )}

                    <Box display="flex" gap={1} mb={2} flexWrap="wrap">
                      <Chip 
                        label="Public" 
                        color="primary" 
                        size="small" 
                      />
                      {document.approved && (
                        <Chip 
                          label="Approved" 
                          color="success" 
                          size="small" 
                        />
                      )}
                    </Box>

                    <Divider sx={{ my: 2 }} />

                    <Box display="flex" justifyContent="space-between" alignItems="center">
                      <Typography variant="caption" color="text.secondary">
                        Uploaded: {new Date(document.uploaded_at).toLocaleDateString()}
                      </Typography>
                      <Button
                        variant="contained"
                        size="small"
                        startIcon={<DownloadIcon />}
                        onClick={() => handleDownloadDocument(document)}
                      >
                        Download
                      </Button>
                    </Box>
                  </CardContent>
                </Card>
              ))}
            </Box>
          )}
        </Box>

        {/* Footer Information */}
        <Paper elevation={1} sx={{ p: 3, mt: 4, textAlign: 'center', bgcolor: 'grey.50' }}>
          <Typography variant="body2" color="text.secondary">
            For questions about these documents or to access additional community resources, 
            please contact your HOA administrator or log in to your member account.
          </Typography>
        </Paper>
      </Box>
    </Container>
  );
};

export default PublicHomePage;

================
File: frontend/src/pages/create_pages.sh
================
#!/bin/bash

# Create member pages
cat > member/DiscussionsPage.tsx << 'MEMBER_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const DiscussionsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Discussions
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Discussions page coming soon...
      </Typography>
    </Box>
  );
};

export default DiscussionsPage;
MEMBER_EOF

cat > member/DiscussionThreadPage.tsx << 'MEMBER_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const DiscussionThreadPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Discussion Thread
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Discussion thread page coming soon...
      </Typography>
    </Box>
  );
};

export default DiscussionThreadPage;
MEMBER_EOF

cat > member/ProfilePage.tsx << 'MEMBER_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const ProfilePage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Profile
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Profile page coming soon...
      </Typography>
    </Box>
  );
};

export default ProfilePage;
MEMBER_EOF

# Create admin pages
cat > admin/AdminDashboardPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminDashboardPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Admin Dashboard
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Admin dashboard coming soon...
      </Typography>
    </Box>
  );
};

export default AdminDashboardPage;
ADMIN_EOF

cat > admin/AdminUsersPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminUsersPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        User Management
      </Typography>
      <Typography variant="body1" color="text.secondary">
        User management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminUsersPage;
ADMIN_EOF

cat > admin/AdminAnnouncementsPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminAnnouncementsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Manage Announcements
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Announcement management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminAnnouncementsPage;
ADMIN_EOF

cat > admin/AdminEventsPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminEventsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Manage Events
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Event management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminEventsPage;
ADMIN_EOF

cat > admin/AdminDocumentsPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminDocumentsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Manage Documents
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Document management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminDocumentsPage;
ADMIN_EOF

cat > admin/AdminConfigPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminConfigPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Site Configuration
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Site configuration page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminConfigPage;
ADMIN_EOF

cat > admin/AdminAuditPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminAuditPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Audit Logs
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Audit logs page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminAuditPage;
ADMIN_EOF

echo "All pages created successfully!"

================
File: frontend/src/services/api.ts
================
import axios from 'axios';
import type { AxiosInstance, AxiosResponse } from 'axios';
import type {
  User,
  Announcement,
  Event,
  Document,
  Discussion,
  Config,
  AuditLog,
  PaginatedResponse,
  DocumentsResponse,
  DiscussionThreadResponse,
  LoginRequest,
  LoginResponse,
  RegisterRequest,
  RegisterResponse,
  ForgotPasswordRequest,
  ResetPasswordRequest,
  CreateAnnouncementRequest,
  CreateEventRequest,
  UpdateEventRequest,
  CreateDiscussionRequest,
  CreateReplyRequest,
  UpdateProfileRequest,
  ChangePasswordRequest,
  UpdateUserStatusRequest,
  UpdateUserRoleRequest,
  UpdateConfigRequest,
} from '../types/api';

class ApiService {
  private api: AxiosInstance;
  private showError?: (message: string) => void;

  constructor() {
    this.api = axios.create({
      baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001/api',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Add request interceptor to include auth token
    this.api.interceptors.request.use((config) => {
      const token = localStorage.getItem('token');
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });

    // Add response interceptor to handle auth errors
    this.api.interceptors.response.use(
      (response) => response,
      (error) => {
        // Don't auto-redirect on login endpoint 401 errors - let the login page handle them
        const isLoginEndpoint = error.config?.url?.includes('/auth/login');
        
        if (error.response?.status === 401 && !isLoginEndpoint) {
          localStorage.removeItem('token');
          localStorage.removeItem('user');
          window.location.href = '/login';
        } else if (error.response?.status >= 500) {
          // Show generic error for server errors
          this.showError?.('An unexpected error occurred. Please try again.');
        }
        return Promise.reject(error);
      }
    );
  }

  // Method to set the error notification handler
  setErrorHandler(showError: (message: string) => void) {
    this.showError = showError;
  }

  // Authentication
  async login(data: LoginRequest): Promise<LoginResponse> {
    const response: AxiosResponse<LoginResponse> = await this.api.post('/auth/login', data);
    return response.data;
  }

  async register(data: RegisterRequest): Promise<RegisterResponse> {
    const response: AxiosResponse<RegisterResponse> = await this.api.post('/auth/register', data);
    return response.data;
  }

  async forgotPassword(data: ForgotPasswordRequest): Promise<{ message: string }> {
    const response = await this.api.post('/auth/forgot-password', data);
    return response.data;
  }

  async resetPassword(data: ResetPasswordRequest): Promise<{ message: string }> {
    const response = await this.api.post('/auth/reset-password', data);
    return response.data;
  }

  // User Profile
  async getProfile(): Promise<User> {
    const response: AxiosResponse<User> = await this.api.get('/users/me');
    return response.data;
  }

  async updateProfile(data: UpdateProfileRequest): Promise<User> {
    const response: AxiosResponse<User> = await this.api.put('/users/me', data);
    return response.data;
  }

  async changePassword(data: ChangePasswordRequest): Promise<{ message: string }> {
    const response = await this.api.put('/users/me/password', data);
    return response.data;
  }

  // Announcements
  async getAnnouncements(params?: {
    page?: number;
    limit?: number;
    status?: string;
    sortBy?: string;
    sortOrder?: string;
  }): Promise<PaginatedResponse<Announcement>> {
    const response: AxiosResponse<PaginatedResponse<Announcement>> = await this.api.get('/announcements', { params });
    return response.data;
  }

  async createAnnouncement(data: CreateAnnouncementRequest): Promise<Announcement> {
    const response: AxiosResponse<Announcement> = await this.api.post('/announcements', data);
    return response.data;
  }

  async updateAnnouncement(id: number, data: Partial<CreateAnnouncementRequest>): Promise<Announcement> {
    const response: AxiosResponse<Announcement> = await this.api.put(`/announcements/${id}`, data);
    return response.data;
  }

  async deleteAnnouncement(id: number): Promise<void> {
    await this.api.delete(`/announcements/${id}`);
  }

  // Events
  async getEvents(params?: {
    status?: string;
    page?: number;
    limit?: number;
    sortBy?: string;
    sortOrder?: string;
  }): Promise<PaginatedResponse<Event>> {
    const response: AxiosResponse<PaginatedResponse<Event>> = await this.api.get('/events', { params });
    
    // Backend returns event_date, but we need start_date for consistency
    const transformedData = response.data.data.map(event => ({
      ...event,
      start_date: event.event_date, // Map event_date to start_date
    }));
    
    return {
      ...response.data,
      data: transformedData,
    };
  }

  async createEvent(data: CreateEventRequest): Promise<Event> {
    const response: AxiosResponse<Event> = await this.api.post('/events', data);
    // Backend returns event_date, map it to start_date for consistency
    return {
      ...response.data,
      start_date: response.data.event_date,
    };
  }

  async updateEvent(id: number, data: UpdateEventRequest): Promise<Event> {
    const response: AxiosResponse<Event> = await this.api.put(`/events/${id}`, data);
    // Backend returns event_date, map it to start_date for consistency
    return {
      ...response.data,
      start_date: response.data.event_date,
    };
  }

  async deleteEvent(id: number): Promise<void> {
    await this.api.delete(`/events/${id}`);
  }

  // Documents
  async getDocuments(params?: { limit?: number; offset?: number }): Promise<DocumentsResponse> {
    const response: AxiosResponse<DocumentsResponse> = await this.api.get('/documents', { params });
    return response.data;
  }

  async getDocument(id: number): Promise<Document> {
    const response: AxiosResponse<Document> = await this.api.get(`/documents/${id}`);
    return response.data;
  }

  async downloadDocument(id: number): Promise<Blob> {
    const response: AxiosResponse<Blob> = await this.api.get(`/documents/${id}/download`, {
      responseType: 'blob',
    });
    return response.data;
  }

  async uploadDocument(formData: FormData): Promise<{ message: string; document: Document }> {
    const response = await this.api.post('/admin/documents', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    return response.data;
  }

  async approveDocument(id: number): Promise<Document> {
    const response: AxiosResponse<Document> = await this.api.put(`/admin/documents/${id}/approve`);
    return response.data;
  }

  async deleteDocument(id: number): Promise<void> {
    await this.api.delete(`/admin/documents/${id}`);
  }

  // Discussions
  async getDiscussions(params?: { page?: number; limit?: number }): Promise<PaginatedResponse<Discussion>> {
    const response = await this.api.get('/discussions', { params });
    
    // Backend returns { totalItems, totalPages, currentPage, threads }
    // Convert to expected PaginatedResponse format
    return {
      data: response.data.threads || [],
      pagination: {
        totalItems: response.data.totalItems || 0,
        totalPages: response.data.totalPages || 0,
        currentPage: response.data.currentPage || 1,
        limit: params?.limit || 10,
      }
    };
  }

  async createDiscussion(data: CreateDiscussionRequest): Promise<Discussion> {
    const response: AxiosResponse<Discussion> = await this.api.post('/discussions', data);
    return response.data;
  }

  async getDiscussionThread(id: number): Promise<DiscussionThreadResponse> {
    const response: AxiosResponse<DiscussionThreadResponse> = await this.api.get(`/discussions/${id}`);
    return response.data;
  }

  async createReply(threadId: number, data: CreateReplyRequest): Promise<Discussion> {
    const response: AxiosResponse<Discussion> = await this.api.post(`/discussions/${threadId}/replies`, data);
    return response.data;
  }

  async deleteDiscussion(id: number): Promise<void> {
    await this.api.delete(`/discussions/${id}`);
  }

  async deleteReply(id: number): Promise<void> {
    await this.api.delete(`/discussions/replies/${id}`);
  }

  // Admin - User Management
  async getUsers(params?: { limit?: number; offset?: number }): Promise<{ count: number; users: User[] }> {
    const response = await this.api.get('/admin/users', { params });
    return response.data;
  }

  async getUser(id: number): Promise<User> {
    const response: AxiosResponse<User> = await this.api.get(`/admin/users/${id}`);
    return response.data;
  }

  async updateUserStatus(id: number, data: UpdateUserStatusRequest): Promise<User> {
    const response: AxiosResponse<User> = await this.api.put(`/admin/users/${id}/status`, data);
    return response.data;
  }

  async updateUserRole(id: number, data: UpdateUserRoleRequest): Promise<User> {
    const response: AxiosResponse<User> = await this.api.put(`/admin/users/${id}/role`, data);
    return response.data;
  }

  async updateUserPassword(id: number, data: { newPassword: string }): Promise<{ message: string }> {
    const response = await this.api.put(`/admin/users/${id}/password`, data);
    return response.data;
  }

  async deleteUser(id: number): Promise<void> {
    await this.api.delete(`/admin/users/${id}`);
  }

  // Admin - Site Configuration
  async getConfig(): Promise<Config> {
    const response: AxiosResponse<Config> = await this.api.get('/admin/config');
    return response.data;
  }

  async updateConfig(key: string, data: UpdateConfigRequest): Promise<{ message: string }> {
    const response = await this.api.put(`/admin/config/${key}`, data);
    return response.data;
  }

  // Admin - Audit Logs
  async getAuditLogs(params?: { page?: number; limit?: number }): Promise<PaginatedResponse<AuditLog>> {
    const response: AxiosResponse<PaginatedResponse<AuditLog>> = await this.api.get('/admin/audit-logs', { params });
    return response.data;
  }
}

export const apiService = new ApiService();

================
File: frontend/src/theme/theme.ts
================
import { createTheme } from '@mui/material/styles';

// Define custom color palette
const palette = {
  primary: {
    main: '#1976d2', // Professional blue
    light: '#42a5f5',
    dark: '#1565c0',
    contrastText: '#ffffff',
  },
  secondary: {
    main: '#dc004e', // Accent red
    light: '#ff5983',
    dark: '#9a0036',
    contrastText: '#ffffff',
  },
  background: {
    default: '#f5f5f5',
    paper: '#ffffff',
  },
  text: {
    primary: '#212121',
    secondary: '#757575',
  },
  success: {
    main: '#4caf50',
    light: '#81c784',
    dark: '#388e3c',
  },
  warning: {
    main: '#ff9800',
    light: '#ffb74d',
    dark: '#f57c00',
  },
  error: {
    main: '#f44336',
    light: '#e57373',
    dark: '#d32f2f',
  },
  info: {
    main: '#2196f3',
    light: '#64b5f6',
    dark: '#1976d2',
  },
};

// Create the theme
export const theme = createTheme({
  palette,
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 600,
      lineHeight: 1.3,
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 600,
      lineHeight: 1.4,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 600,
      lineHeight: 1.4,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 600,
      lineHeight: 1.5,
    },
    h6: {
      fontSize: '1rem',
      fontWeight: 600,
      lineHeight: 1.6,
    },
    body1: {
      fontSize: '1rem',
      lineHeight: 1.6,
    },
    body2: {
      fontSize: '0.875rem',
      lineHeight: 1.6,
    },
    button: {
      textTransform: 'none',
      fontWeight: 500,
    },
  },
  shape: {
    borderRadius: 8,
  },
  spacing: 8,
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          padding: '8px 16px',
          fontSize: '0.875rem',
          fontWeight: 500,
          textTransform: 'none',
          boxShadow: 'none',
          '&:hover': {
            boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
          },
        },
        contained: {
          '&:hover': {
            boxShadow: '0 4px 8px rgba(0,0,0,0.15)',
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
          '&:hover': {
            boxShadow: '0 4px 16px rgba(0,0,0,0.15)',
          },
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
        elevation1: {
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        },
        elevation2: {
          boxShadow: '0 4px 8px rgba(0,0,0,0.12)',
        },
        elevation3: {
          boxShadow: '0 6px 12px rgba(0,0,0,0.15)',
        },
      },
    },
    MuiTextField: {
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-root': {
            borderRadius: 8,
          },
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          borderRadius: 0,
          borderRight: '1px solid rgba(0,0,0,0.12)',
        },
      },
    },
    MuiListItemButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          margin: '2px 8px',
          '&:hover': {
            backgroundColor: 'rgba(25, 118, 210, 0.08)',
          },
          '&.Mui-selected': {
            backgroundColor: 'rgba(25, 118, 210, 0.12)',
            '&:hover': {
              backgroundColor: 'rgba(25, 118, 210, 0.16)',
            },
          },
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 16,
        },
      },
    },
    MuiAlert: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
      },
    },
  },
});

// Status color mappings for consistent UI
export const statusColors = {
  pending: '#ff9800', // Orange
  approved: '#4caf50', // Green
  rejected: '#f44336', // Red
  active: '#4caf50', // Green
  expired: '#757575', // Gray
} as const;

// Role color mappings
export const roleColors = {
  admin: '#dc004e', // Secondary color
  member: '#1976d2', // Primary color
} as const;

export default theme;

================
File: frontend/src/types/api.ts
================
// API Data Models based on the HOA Management API

export interface User {
  id: number;
  name: string;
  email: string;
  role: 'member' | 'admin';
  status: 'pending' | 'approved' | 'rejected';
  email_verified: boolean;
  is_system_user: boolean;
  created_at: string;
  updated_at: string;
}

export interface Announcement {
  id: number;
  title: string;
  content: string;
  created_by: number;
  expires_at: string | null;
  created_at: string;
  updated_at: string;
  creator?: {
    id: number;
    name: string;
  };
}

export interface Event {
  id: number;
  title: string;
  description: string;
  event_date: string;
  end_date: string;
  location: string;
  created_by: number;
  created_at: string;
  updated_at: string;
  creator?: {
    id: number;
    name: string;
  };
  // Backend returns event_date but we also need start_date for consistency
  start_date: string;
}

export interface Document {
  id: number;
  title: string;
  description: string | null;
  file_name: string;
  original_file_name: string;
  file_path: string;
  uploaded_by: number;
  approved: boolean;
  is_public: boolean;
  uploaded_at: string;
  updated_at: string;
  uploader?: {
    id: number;
    name: string;
  };
}

export interface Discussion {
  id: number;
  title: string | null;
  content: string;
  user_id: number;
  parent_id: number | null;
  created_at: string;
  updated_at: string;
  author?: {
    id: number;
    name: string;
  };
  reply_count?: number;
}

export interface Config {
  [key: string]: string;
}

export interface AuditLog {
  id: number;
  admin_name: string;
  action: string;
  details: object;
  created_at: string;
}

// API Response Types
export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    totalItems: number;
    totalPages: number;
    currentPage: number;
    limit: number;
  };
}

export interface DocumentsResponse {
  count: number;
  documents: Document[];
}

export interface DiscussionThreadResponse {
  mainThread: Discussion;
  replies: Discussion[];
}

// Auth Types
export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  message: string;
  token: string;
  user: User;
}

export interface RegisterRequest {
  name: string;
  email: string;
  password: string;
}

export interface RegisterResponse {
  message: string;
  user: User;
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ResetPasswordRequest {
  token: string;
  newPassword: string;
}

// Form Types
export interface CreateAnnouncementRequest {
  title: string;
  content: string;
  expiresAt?: string;
}

export interface CreateEventRequest {
  title: string;
  description: string;
  event_date: string;
  location: string;
}

export interface UpdateEventRequest {
  title?: string;
  description?: string;
  start_date?: string;
  end_date?: string;
  location?: string;
}

export interface CreateDiscussionRequest {
  title: string;
  content: string;
}

export interface CreateReplyRequest {
  content: string;
}

export interface UpdateProfileRequest {
  name: string;
}

export interface ChangePasswordRequest {
  currentPassword: string;
  newPassword: string;
}

export interface UpdateUserStatusRequest {
  status: 'approved' | 'pending' | 'rejected';
}

export interface UpdateUserRoleRequest {
  role: 'admin' | 'member';
}

export interface UpdateConfigRequest {
  value: string;
}

// Error Response
export interface ApiError {
  message: string;
  error?: string;
}

================
File: frontend/src/App.css
================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: frontend/src/App.tsx
================
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider } from '@mui/material/styles';
import { CssBaseline } from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';

import { AuthProvider } from './contexts/AuthContext';
import { NotificationProvider } from './contexts/NotificationContext';
import { theme } from './theme/theme';
import ProtectedRoute from './components/common/ProtectedRoute';
import PublicRoute from './components/common/PublicRoute';
import Layout from './components/layout/Layout';

// Public Pages
import LoginPage from './pages/auth/LoginPage';
import RegisterPage from './pages/auth/RegisterPage';
import ForgotPasswordPage from './pages/auth/ForgotPasswordPage';
import ResetPasswordPage from './pages/auth/ResetPasswordPage';
import PublicHomePage from './pages/public/PublicHomePage';

// Member Pages
import DashboardPage from './pages/member/DashboardPage';
import AnnouncementsPage from './pages/member/AnnouncementsPage';
import EventsPage from './pages/member/EventsPage';
import DocumentsPage from './pages/member/DocumentsPage';
import DiscussionsPage from './pages/member/DiscussionsPage';
import DiscussionThreadPage from './pages/member/DiscussionThreadPage';
import ProfilePage from './pages/member/ProfilePage';

// Admin Pages
import AdminDashboardPage from './pages/admin/AdminDashboardPage';
import AdminUsersPage from './pages/admin/AdminUsersPage';
import AdminAnnouncementsPage from './pages/admin/AdminAnnouncementsPage';
import AdminEventsPage from './pages/admin/AdminEventsPage';
import AdminDocumentsPage from './pages/admin/AdminDocumentsPage';
import AdminConfigPage from './pages/admin/AdminConfigPage';
import AdminAuditPage from './pages/admin/AdminAuditPage';

const App: React.FC = () => {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <LocalizationProvider dateAdapter={AdapterDayjs}>
        <NotificationProvider>
          <AuthProvider>
            <Router>
            <Routes>
              {/* Public Routes */}
              <Route
                path="/login"
                element={
                  <PublicRoute>
                    <LoginPage />
                  </PublicRoute>
                }
              />
              <Route
                path="/register"
                element={
                  <PublicRoute>
                    <RegisterPage />
                  </PublicRoute>
                }
              />
              <Route
                path="/forgot-password"
                element={
                  <PublicRoute>
                    <ForgotPasswordPage />
                  </PublicRoute>
                }
              />
              <Route
                path="/reset-password"
                element={
                  <PublicRoute>
                    <ResetPasswordPage />
                  </PublicRoute>
                }
              />
              <Route
                path="/public"
                element={
                  <PublicRoute>
                    <PublicHomePage />
                  </PublicRoute>
                }
              />

              {/* Protected Member Routes */}
              <Route
                path="/"
                element={
                  <ProtectedRoute>
                    <Layout />
                  </ProtectedRoute>
                }
              >
                <Route index element={<Navigate to="/dashboard" replace />} />
                <Route path="dashboard" element={<DashboardPage />} />
                <Route path="announcements" element={<AnnouncementsPage />} />
                <Route path="events" element={<EventsPage />} />
                <Route path="documents" element={<DocumentsPage />} />
                <Route path="discussions" element={<DiscussionsPage />} />
                <Route path="discussions/:id" element={<DiscussionThreadPage />} />
                <Route path="profile" element={<ProfilePage />} />

                {/* Admin Routes */}
                <Route
                  path="admin"
                  element={
                    <ProtectedRoute requireAdmin>
                      <Navigate to="/admin/dashboard" replace />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/dashboard"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminDashboardPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/users"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminUsersPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/announcements"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminAnnouncementsPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/events"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminEventsPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/documents"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminDocumentsPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/config"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminConfigPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/audit"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminAuditPage />
                    </ProtectedRoute>
                  }
                />
              </Route>

              {/* Fallback route */}
              <Route path="*" element={<Navigate to="/" replace />} />
            </Routes>
            </Router>
          </AuthProvider>
        </NotificationProvider>
      </LocalizationProvider>
    </ThemeProvider>
  );
};

export default App;

================
File: frontend/src/index.css
================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

================
File: frontend/src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: frontend/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: frontend/.dockerignore
================
# Dependencies
node_modules
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Production build
dist
build

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.vscode
.idea
*.swp
*.swo

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Git
.git
.gitignore

# Testing
coverage
.nyc_output

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

================
File: frontend/.env.example
================
# API Configuration
VITE_API_BASE_URL=http://localhost:3001/api

================
File: frontend/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: frontend/Dockerfile
================
# Multi-stage build for React/Vite frontend
# Stage 1: Build the application
FROM node:18-alpine AS build

# Set working directory
WORKDIR /usr/src/app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY . .

# Build the application
RUN npm run build

# Stage 2: Serve the application with nginx
FROM nginx:alpine AS production

# Copy built assets from build stage
COPY --from=build /usr/src/app/dist /usr/share/nginx/html

# Copy custom nginx configuration
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Expose port 80
EXPOSE 80

# Start nginx
CMD ["nginx", "-g", "daemon off;"]

================
File: frontend/eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: frontend/hoa-management.conf
================
# HOA Management System - Production Nginx Configuration
# Place this file in /etc/nginx/sites-available/ and create symlink in sites-enabled/

# Rate limiting zones
limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
limit_req_zone $binary_remote_addr zone=login:10m rate=5r/m;
limit_req_zone $binary_remote_addr zone=upload:10m rate=2r/m;

# Upstream backend servers
upstream backend_api {
    server 127.0.0.1:3001;
    keepalive 32;
}

upstream frontend_app {
    server 127.0.0.1:3000;
    keepalive 32;
}

# HTTP to HTTPS redirect
server {
    listen 80;
    listen [::]:80;
    server_name sandersoncreekhoa.com www.sandersoncreekhoa.com;
    
    # Let's Encrypt challenge
    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }
    
    # Redirect all HTTP traffic to HTTPS
    location / {
        return 301 https://$server_name$request_uri;
    }
}

# Main HTTPS server
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name sandersoncreekhoa.com www.sandersoncreekhoa.com;
    
    # SSL Configuration (managed by Certbot)
    ssl_certificate /etc/letsencrypt/live/sandersoncreekhoa.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/sandersoncreekhoa.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self'; frame-ancestors 'self';" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;
    
    # Remove server signature
    server_tokens off;
    
    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;
    
    # Client settings
    client_max_body_size 10M;
    client_body_timeout 60s;
    client_header_timeout 60s;
    
    # Logging
    access_log /var/log/nginx/hoa-management-access.log;
    error_log /var/log/nginx/hoa-management-error.log;
    
    # API routes with rate limiting
    location /api/ {
        # Rate limiting
        limit_req zone=api burst=20 nodelay;
        
        # CORS headers
        add_header Access-Control-Allow-Origin "https://sandersoncreekhoa.com" always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept" always;
        add_header Access-Control-Allow-Credentials "true" always;
        
        # Handle preflight requests
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin "https://sandersoncreekhoa.com";
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept";
            add_header Access-Control-Allow-Credentials "true";
            add_header Access-Control-Max-Age 1728000;
            add_header Content-Type "text/plain charset=UTF-8";
            add_header Content-Length 0;
            return 204;
        }
        
        # Proxy to backend
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    
    # Login endpoint with stricter rate limiting
    location /api/auth/login {
        limit_req zone=login burst=3 nodelay;
        
        # CORS headers
        add_header Access-Control-Allow-Origin "https://sandersoncreekhoa.com" always;
        add_header Access-Control-Allow-Methods "POST, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept" always;
        add_header Access-Control-Allow-Credentials "true" always;
        
        # Handle preflight requests
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin "https://sandersoncreekhoa.com";
            add_header Access-Control-Allow-Methods "POST, OPTIONS";
            add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept";
            add_header Access-Control-Allow-Credentials "true";
            add_header Access-Control-Max-Age 1728000;
            add_header Content-Type "text/plain charset=UTF-8";
            add_header Content-Length 0;
            return 204;
        }
        
        # Proxy to backend
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # File upload endpoints with rate limiting
    location ~ ^/api/(admin/documents|documents)/upload {
        limit_req zone=upload burst=1 nodelay;
        
        # Increase body size for file uploads
        client_max_body_size 10M;
        client_body_timeout 300s;
        
        # CORS headers
        add_header Access-Control-Allow-Origin "https://sandersoncreekhoa.com" always;
        add_header Access-Control-Allow-Methods "POST, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept" always;
        add_header Access-Control-Allow-Credentials "true" always;
        
        # Handle preflight requests
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin "https://sandersoncreekhoa.com";
            add_header Access-Control-Allow-Methods "POST, OPTIONS";
            add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept";
            add_header Access-Control-Allow-Credentials "true";
            add_header Access-Control-Max-Age 1728000;
            add_header Content-Type "text/plain charset=UTF-8";
            add_header Content-Length 0;
            return 204;
        }
        
        # Proxy to backend
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Extended timeouts for file uploads
        proxy_connect_timeout 300s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
    }
    
    # Static file downloads with caching
    location /api/documents/download/ {
        # CORS headers
        add_header Access-Control-Allow-Origin "https://sandersoncreekhoa.com" always;
        add_header Access-Control-Allow-Methods "GET, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, Accept" always;
        add_header Access-Control-Allow-Credentials "true" always;
        
        # Caching for downloaded files
        expires 1h;
        add_header Cache-Control "public, immutable";
        
        # Proxy to backend
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # Health check endpoint (no rate limiting)
    location /api/health {
        access_log off;
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # Frontend application
    location / {
        # Try files first, then fallback to index.html for SPA routing
        try_files $uri $uri/ @frontend;
        
        # Static file caching
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            add_header Vary "Accept-Encoding";
            
            # Proxy to frontend
            proxy_pass http://frontend_app;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
    
    # Frontend fallback for SPA routing
    location @frontend {
        proxy_pass http://frontend_app;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # No caching for HTML files
        add_header Cache-Control "no-cache, no-store, must-revalidate";
        add_header Pragma "no-cache";
        add_header Expires "0";
    }
    
    # Security: Block access to sensitive files
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    location ~ ~$ {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    # Block common exploit attempts
    location ~* (wp-admin|wp-login|xmlrpc|phpmyadmin) {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    # Robots.txt
    location = /robots.txt {
        add_header Content-Type text/plain;
        return 200 "User-agent: *\nDisallow: /api/\nDisallow: /admin/\n";
    }
    
    # Favicon
    location = /favicon.ico {
        proxy_pass http://frontend_app;
        expires 1y;
        add_header Cache-Control "public, immutable";
        access_log off;
    }
}

# # Additional security server block to handle non-matching hosts
# server {
#     listen 443 ssl http2 default_server;
#     listen [::]:443 ssl http2 default_server;
#     server_name _;
    
#     # Use a self-signed certificate for default server
#     ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
#     ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
    
#     # Return 444 (connection closed without response)
#     return 444;
# }

================
File: frontend/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: frontend/nginx.conf
================
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # Enable gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;

    # Handle client-side routing (React Router)
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}

================
File: frontend/package.json
================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^7.1.1",
    "@mui/material": "^7.1.1",
    "@mui/x-date-pickers": "^8.5.1",
    "@types/yup": "^0.29.14",
    "axios": "^1.9.0",
    "date-fns": "^4.1.0",
    "dayjs": "^1.11.13",
    "formik": "^2.4.6",
    "notistack": "^3.0.2",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-router-dom": "^7.6.2",
    "yup": "^1.6.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "^6.3.5"
  }
}

================
File: frontend/README.md
================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```

================
File: frontend/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-09T07:17:07.736Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
public/
  vite.svg
src/
  assets/
    react.svg
  components/
    common/
      ProtectedRoute.tsx
      PublicRoute.tsx
    layout/
      Layout.tsx
  contexts/
    AuthContext.tsx
  pages/
    admin/
      AdminAnnouncementsPage.tsx
      AdminAuditPage.tsx
      AdminConfigPage.tsx
      AdminDashboardPage.tsx
      AdminDocumentsPage.tsx
      AdminEventsPage.tsx
      AdminUsersPage.tsx
    auth/
      ForgotPasswordPage.tsx
      LoginPage.tsx
      RegisterPage.tsx
      ResetPasswordPage.tsx
    member/
      AnnouncementsPage.tsx
      DashboardPage.tsx
      DiscussionsPage.tsx
      DiscussionThreadPage.tsx
      DocumentsPage.tsx
      EventsPage.tsx
      ProfilePage.tsx
    public/
      PublicHomePage.tsx
    create_pages.sh
  services/
    api.ts
  theme/
    theme.ts
  types/
    api.ts
  App.css
  App.tsx
  index.css
  main.tsx
  vite-env.d.ts
.gitignore
eslint.config.js
index.html
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Files
================================================================

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/components/common/ProtectedRoute.tsx
================
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { Box, CircularProgress } from '@mui/material';
import type { ReactNode } from 'react';
import { useAuth } from '../../contexts/AuthContext';

interface ProtectedRouteProps {
  children: ReactNode;
  requireAdmin?: boolean;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children, requireAdmin = false }) => {
  const { isAuthenticated, isAdmin, isLoading, user } = useAuth();
  const location = useLocation();

  // Show loading spinner while checking authentication
  if (isLoading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="100vh"
      >
        <CircularProgress />
      </Box>
    );
  }

  // Redirect to login if not authenticated
  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  // Check if user account is approved
  if (user?.status !== 'approved') {
    return <Navigate to="/login" replace />;
  }

  // Check admin requirement
  if (requireAdmin && !isAdmin) {
    return <Navigate to="/dashboard" replace />;
  }

  return <>{children}</>;
};

export default ProtectedRoute;

================
File: src/components/common/PublicRoute.tsx
================
import React from 'react';
import { Navigate } from 'react-router-dom';
import { Box, CircularProgress } from '@mui/material';
import type { ReactNode } from 'react';
import { useAuth } from '../../contexts/AuthContext';

interface PublicRouteProps {
  children: ReactNode;
}

const PublicRoute: React.FC<PublicRouteProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();

  // Show loading spinner while checking authentication
  if (isLoading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="100vh"
      >
        <CircularProgress />
      </Box>
    );
  }

  // Redirect to dashboard if already authenticated
  if (isAuthenticated) {
    return <Navigate to="/dashboard" replace />;
  }

  return <>{children}</>;
};

export default PublicRoute;

================
File: src/components/layout/Layout.tsx
================
import React, { useState } from 'react';
import { Outlet, useNavigate, useLocation } from 'react-router-dom';
import {
  Box,
  Drawer,
  AppBar,
  Toolbar,
  List,
  Typography,
  Divider,
  IconButton,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Avatar,
  Menu,
  MenuItem,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import {
  Menu as MenuIcon,
  Dashboard,
  Announcement,
  Event,
  Description,
  Forum,
  Person,
  AdminPanelSettings,
  People,
  Settings,
  History,
  Logout,
} from '@mui/icons-material';
import { useAuth } from '../../contexts/AuthContext';

const drawerWidth = 240;

interface NavigationItem {
  text: string;
  icon: React.ReactElement;
  path: string;
  adminOnly?: boolean;
}

const navigationItems: NavigationItem[] = [
  { text: 'Dashboard', icon: <Dashboard />, path: '/dashboard' },
  { text: 'Announcements', icon: <Announcement />, path: '/announcements' },
  { text: 'Events', icon: <Event />, path: '/events' },
  { text: 'Documents', icon: <Description />, path: '/documents' },
  { text: 'Discussions', icon: <Forum />, path: '/discussions' },
  { text: 'Profile', icon: <Person />, path: '/profile' },
];

const adminNavigationItems: NavigationItem[] = [
  { text: 'Admin Dashboard', icon: <AdminPanelSettings />, path: '/admin/dashboard', adminOnly: true },
  { text: 'User Management', icon: <People />, path: '/admin/users', adminOnly: true },
  { text: 'Manage Announcements', icon: <Announcement />, path: '/admin/announcements', adminOnly: true },
  { text: 'Manage Events', icon: <Event />, path: '/admin/events', adminOnly: true },
  { text: 'Manage Documents', icon: <Description />, path: '/admin/documents', adminOnly: true },
  { text: 'Site Configuration', icon: <Settings />, path: '/admin/config', adminOnly: true },
  { text: 'Audit Logs', icon: <History />, path: '/admin/audit', adminOnly: true },
];

const Layout: React.FC = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const [mobileOpen, setMobileOpen] = useState(false);
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const navigate = useNavigate();
  const location = useLocation();
  const { user, logout, isAdmin } = useAuth();

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleProfileMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleProfileMenuClose = () => {
    setAnchorEl(null);
  };

  const handleLogout = () => {
    logout();
    handleProfileMenuClose();
    navigate('/login');
  };

  const handleNavigate = (path: string) => {
    navigate(path);
    if (isMobile) {
      setMobileOpen(false);
    }
  };

  const drawer = (
    <Box>
      <Toolbar>
        <Typography variant="h6" noWrap component="div">
          HOA Community Hub
        </Typography>
      </Toolbar>
      <Divider />
      
      {/* Member Navigation */}
      <List>
        {navigationItems.map((item) => (
          <ListItem key={item.text} disablePadding>
            <ListItemButton
              selected={location.pathname === item.path}
              onClick={() => handleNavigate(item.path)}
            >
              <ListItemIcon>{item.icon}</ListItemIcon>
              <ListItemText primary={item.text} />
            </ListItemButton>
          </ListItem>
        ))}
      </List>

      {/* Admin Navigation */}
      {isAdmin && (
        <>
          <Divider />
          <List>
            <ListItem>
              <ListItemText 
                primary="Administration" 
                primaryTypographyProps={{ 
                  variant: 'overline', 
                  color: 'text.secondary',
                  fontWeight: 'bold'
                }} 
              />
            </ListItem>
            {adminNavigationItems.map((item) => (
              <ListItem key={item.text} disablePadding>
                <ListItemButton
                  selected={location.pathname === item.path}
                  onClick={() => handleNavigate(item.path)}
                >
                  <ListItemIcon>{item.icon}</ListItemIcon>
                  <ListItemText primary={item.text} />
                </ListItemButton>
              </ListItem>
            ))}
          </List>
        </>
      )}
    </Box>
  );

  return (
    <Box sx={{ display: 'flex' }}>
      <AppBar
        position="fixed"
        sx={{
          width: { md: `calc(100% - ${drawerWidth}px)` },
          ml: { md: `${drawerWidth}px` },
        }}
      >
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="open drawer"
            edge="start"
            onClick={handleDrawerToggle}
            sx={{ mr: 2, display: { md: 'none' } }}
          >
            <MenuIcon />
          </IconButton>
          
          <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
            {/* Page title could be dynamic based on current route */}
          </Typography>

          {/* User Profile Menu */}
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <Typography variant="body2" sx={{ display: { xs: 'none', sm: 'block' } }}>
              {user?.name}
            </Typography>
            <IconButton
              size="large"
              aria-label="account of current user"
              aria-controls="profile-menu"
              aria-haspopup="true"
              onClick={handleProfileMenuOpen}
              color="inherit"
            >
              <Avatar sx={{ width: 32, height: 32 }}>
                {user?.name?.charAt(0).toUpperCase()}
              </Avatar>
            </IconButton>
          </Box>
        </Toolbar>
      </AppBar>

      {/* Profile Menu */}
      <Menu
        id="profile-menu"
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleProfileMenuClose}
        onClick={handleProfileMenuClose}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >
        <MenuItem onClick={() => handleNavigate('/profile')}>
          <ListItemIcon>
            <Person fontSize="small" />
          </ListItemIcon>
          Profile
        </MenuItem>
        <MenuItem onClick={handleLogout}>
          <ListItemIcon>
            <Logout fontSize="small" />
          </ListItemIcon>
          Logout
        </MenuItem>
      </Menu>

      {/* Navigation Drawer */}
      <Box
        component="nav"
        sx={{ width: { md: drawerWidth }, flexShrink: { md: 0 } }}
        aria-label="navigation"
      >
        {/* Mobile drawer */}
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{
            keepMounted: true, // Better open performance on mobile.
          }}
          sx={{
            display: { xs: 'block', md: 'none' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
        >
          {drawer}
        </Drawer>
        
        {/* Desktop drawer */}
        <Drawer
          variant="permanent"
          sx={{
            display: { xs: 'none', md: 'block' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
          open
        >
          {drawer}
        </Drawer>
      </Box>

      {/* Main content */}
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          p: 3,
          width: { md: `calc(100% - ${drawerWidth}px)` },
          mt: '64px', // AppBar height
        }}
      >
        <Outlet />
      </Box>
    </Box>
  );
};

export default Layout;

================
File: src/contexts/AuthContext.tsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import type { ReactNode } from 'react';
import type { User, LoginRequest, RegisterRequest } from '../types/api';
import { apiService } from '../services/api';

interface AuthContextType {
  user: User | null;
  token: string | null;
  isLoading: boolean;
  login: (credentials: LoginRequest) => Promise<void>;
  register: (userData: RegisterRequest) => Promise<void>;
  logout: () => void;
  updateUser: (updatedUser: User) => void;
  isAuthenticated: boolean;
  isAdmin: boolean;
  isMember: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Initialize auth state from localStorage
  useEffect(() => {
    const storedToken = localStorage.getItem('token');
    const storedUser = localStorage.getItem('user');

    if (storedToken && storedUser) {
      try {
        const parsedUser = JSON.parse(storedUser);
        setToken(storedToken);
        setUser(parsedUser);
      } catch (error) {
        console.error('Error parsing stored user data:', error);
        localStorage.removeItem('token');
        localStorage.removeItem('user');
      }
    }
    setIsLoading(false);
  }, []);

  // Verify token and refresh user data on app start
  useEffect(() => {
    const verifyToken = async () => {
      if (token && !user) {
        try {
          const userData = await apiService.getProfile();
          setUser(userData);
          localStorage.setItem('user', JSON.stringify(userData));
        } catch (error) {
          console.error('Token verification failed:', error);
          logout();
        }
      }
    };

    if (token) {
      verifyToken();
    }
  }, [token, user]);

  const login = async (credentials: LoginRequest): Promise<void> => {
    try {
      const response = await apiService.login(credentials);
      const { token: newToken, user: userData } = response;

      setToken(newToken);
      setUser(userData);
      localStorage.setItem('token', newToken);
      localStorage.setItem('user', JSON.stringify(userData));
    } catch (error) {
      throw error;
    }
  };

  const register = async (userData: RegisterRequest): Promise<void> => {
    try {
      await apiService.register(userData);
      // Note: Registration doesn't automatically log in the user
      // They need admin approval first
    } catch (error) {
      throw error;
    }
  };

  const logout = (): void => {
    setUser(null);
    setToken(null);
    localStorage.removeItem('token');
    localStorage.removeItem('user');
  };

  const updateUser = (updatedUser: User): void => {
    setUser(updatedUser);
    localStorage.setItem('user', JSON.stringify(updatedUser));
  };

  const isAuthenticated = !!user && !!token;
  const isAdmin = user?.role === 'admin';
  const isMember = user?.role === 'member';

  const value: AuthContextType = {
    user,
    token,
    isLoading,
    login,
    register,
    logout,
    updateUser,
    isAuthenticated,
    isAdmin,
    isMember,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================
File: src/pages/admin/AdminAnnouncementsPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminAnnouncementsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Manage Announcements
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Announcement management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminAnnouncementsPage;

================
File: src/pages/admin/AdminAuditPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminAuditPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Audit Logs
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Audit logs page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminAuditPage;

================
File: src/pages/admin/AdminConfigPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminConfigPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Site Configuration
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Site configuration page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminConfigPage;

================
File: src/pages/admin/AdminDashboardPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminDashboardPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Admin Dashboard
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Admin dashboard coming soon...
      </Typography>
    </Box>
  );
};

export default AdminDashboardPage;

================
File: src/pages/admin/AdminDocumentsPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminDocumentsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Manage Documents
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Document management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminDocumentsPage;

================
File: src/pages/admin/AdminEventsPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminEventsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Manage Events
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Event management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminEventsPage;

================
File: src/pages/admin/AdminUsersPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminUsersPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        User Management
      </Typography>
      <Typography variant="body1" color="text.secondary">
        User management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminUsersPage;

================
File: src/pages/auth/ForgotPasswordPage.tsx
================
import React from 'react';
import { Container, Typography, Box } from '@mui/material';

const ForgotPasswordPage: React.FC = () => {
  return (
    <Container component="main" maxWidth="sm">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
        }}
      >
        <Typography variant="h4" gutterBottom>
          Forgot Password
        </Typography>
        <Typography variant="body1" color="text.secondary">
          Password reset form coming soon...
        </Typography>
      </Box>
    </Container>
  );
};

export default ForgotPasswordPage;

================
File: src/pages/auth/LoginPage.tsx
================
import React, { useState } from 'react';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import {
  Box,
  Card,
  CardContent,
  TextField,
  Button,
  Typography,
  Alert,
  Container,
  Paper,
  Divider,
} from '@mui/material';
import { Formik, Form, Field } from 'formik';
import * as Yup from 'yup';
import type { LoginRequest } from '../../types/api';
import { useAuth } from '../../contexts/AuthContext';

const validationSchema = Yup.object({
  email: Yup.string()
    .email('Invalid email address')
    .required('Email is required'),
  password: Yup.string()
    .required('Password is required'),
});

const LoginPage: React.FC = () => {
  const [error, setError] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  const { login } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();

  const from = location.state?.from?.pathname || '/dashboard';

  const handleSubmit = async (values: LoginRequest) => {
    setError('');
    setIsLoading(true);

    try {
      await login(values);
      navigate(from, { replace: true });
    } catch (err: any) {
      setError(err.response?.data?.message || 'Login failed. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="sm">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          py: 4,
        }}
      >
        <Paper elevation={3} sx={{ p: 4 }}>
          <Box sx={{ textAlign: 'center', mb: 4 }}>
            <Typography component="h1" variant="h4" gutterBottom>
              HOA Community Hub
            </Typography>
            <Typography variant="h5" color="text.secondary">
              Sign In
            </Typography>
          </Box>

          {error && (
            <Alert severity="error" sx={{ mb: 3 }}>
              {error}
            </Alert>
          )}

          <Formik
            initialValues={{
              email: '',
              password: '',
            }}
            validationSchema={validationSchema}
            onSubmit={handleSubmit}
          >
            {({ errors, touched, isSubmitting }) => (
              <Form>
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                  <Field
                    as={TextField}
                    name="email"
                    type="email"
                    label="Email Address"
                    fullWidth
                    autoComplete="email"
                    autoFocus
                    error={touched.email && !!errors.email}
                    helperText={touched.email && errors.email}
                  />

                  <Field
                    as={TextField}
                    name="password"
                    type="password"
                    label="Password"
                    fullWidth
                    autoComplete="current-password"
                    error={touched.password && !!errors.password}
                    helperText={touched.password && errors.password}
                  />

                  <Button
                    type="submit"
                    fullWidth
                    variant="contained"
                    size="large"
                    disabled={isLoading || isSubmitting}
                    sx={{ mt: 2 }}
                  >
                    {isLoading ? 'Signing In...' : 'Sign In'}
                  </Button>
                </Box>
              </Form>
            )}
          </Formik>

          <Divider sx={{ my: 3 }} />

          <Box sx={{ textAlign: 'center', display: 'flex', flexDirection: 'column', gap: 2 }}>
            <Typography variant="body2">
              <Link 
                to="/forgot-password" 
                style={{ textDecoration: 'none', color: 'inherit' }}
              >
                Forgot your password?
              </Link>
            </Typography>
            
            <Typography variant="body2">
              Don't have an account?{' '}
              <Link 
                to="/register" 
                style={{ textDecoration: 'none', fontWeight: 'bold' }}
              >
                Sign up here
              </Link>
            </Typography>

            <Typography variant="body2" color="text.secondary">
              <Link 
                to="/public" 
                style={{ textDecoration: 'none', color: 'inherit' }}
              >
                View public information
              </Link>
            </Typography>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default LoginPage;

================
File: src/pages/auth/RegisterPage.tsx
================
import React from 'react';
import { Container, Typography, Box } from '@mui/material';

const RegisterPage: React.FC = () => {
  return (
    <Container component="main" maxWidth="sm">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
        }}
      >
        <Typography variant="h4" gutterBottom>
          Register Page
        </Typography>
        <Typography variant="body1" color="text.secondary">
          Registration form coming soon...
        </Typography>
      </Box>
    </Container>
  );
};

export default RegisterPage;

================
File: src/pages/auth/ResetPasswordPage.tsx
================
import React from 'react';
import { Container, Typography, Box } from '@mui/material';

const ResetPasswordPage: React.FC = () => {
  return (
    <Container component="main" maxWidth="sm">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
        }}
      >
        <Typography variant="h4" gutterBottom>
          Reset Password
        </Typography>
        <Typography variant="body1" color="text.secondary">
          Password reset form coming soon...
        </Typography>
      </Box>
    </Container>
  );
};

export default ResetPasswordPage;

================
File: src/pages/member/AnnouncementsPage.tsx
================
import React from 'react';
import { Container, Typography, Box } from '@mui/material';

const AnnouncementsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Announcements
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Announcements page coming soon...
      </Typography>
    </Box>
  );
};

export default AnnouncementsPage;

================
File: src/pages/member/DashboardPage.tsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Grid,
  Card,
  CardContent,
  Typography,
  Alert,
  CircularProgress,
  Button,
  Chip,
} from '@mui/material';
import {
  Announcement as AnnouncementIcon,
  Event as EventIcon,
  Description as DocumentIcon,
  Forum as ForumIcon,
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import type { Announcement, Event } from '../../types/api';
import { apiService } from '../../services/api';
import { useAuth } from '../../contexts/AuthContext';

const DashboardPage: React.FC = () => {
  const [announcements, setAnnouncements] = useState<Announcement[]>([]);
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string>('');
  const navigate = useNavigate();
  const { user } = useAuth();

  useEffect(() => {
    const fetchDashboardData = async () => {
      try {
        setLoading(true);
        
        // Fetch recent announcements
        const announcementsResponse = await apiService.getAnnouncements({
          limit: 5,
          status: 'active',
          sortBy: 'created_at',
          sortOrder: 'desc',
        });
        
        // Fetch upcoming events
        const eventsResponse = await apiService.getEvents({
          status: 'upcoming',
          limit: 5,
          sortBy: 'event_date',
          sortOrder: 'asc',
        });

        setAnnouncements(announcementsResponse.data);
        setEvents(eventsResponse.data);
      } catch (err: any) {
        setError('Failed to load dashboard data');
        console.error('Dashboard error:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchDashboardData();
  }, []);

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="400px">
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Welcome back, {user?.name}!
      </Typography>
      
      <Typography variant="body1" color="text.secondary" sx={{ mb: 4 }}>
        Here's what's happening in your community.
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}

      <Grid container spacing={3}>
        {/* Quick Actions */}
        <Grid size={12}>
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                Quick Actions
              </Typography>
              <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
                <Button
                  variant="outlined"
                  startIcon={<AnnouncementIcon />}
                  onClick={() => navigate('/announcements')}
                >
                  View Announcements
                </Button>
                <Button
                  variant="outlined"
                  startIcon={<EventIcon />}
                  onClick={() => navigate('/events')}
                >
                  View Events
                </Button>
                <Button
                  variant="outlined"
                  startIcon={<DocumentIcon />}
                  onClick={() => navigate('/documents')}
                >
                  Browse Documents
                </Button>
                <Button
                  variant="outlined"
                  startIcon={<ForumIcon />}
                  onClick={() => navigate('/discussions')}
                >
                  Join Discussions
                </Button>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Recent Announcements */}
        <Grid size={{ xs: 12, md: 6 }}>
          <Card>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h6">
                  Recent Announcements
                </Typography>
                <Button size="small" onClick={() => navigate('/announcements')}>
                  View All
                </Button>
              </Box>
              
              {announcements.length === 0 ? (
                <Typography color="text.secondary">
                  No recent announcements
                </Typography>
              ) : (
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                  {announcements.map((announcement) => (
                    <Box key={announcement.id} sx={{ p: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
                      <Typography variant="subtitle2" gutterBottom>
                        {announcement.title}
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                        {announcement.content.replace(/<[^>]*>/g, '').substring(0, 100)}...
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        {new Date(announcement.created_at).toLocaleDateString()}
                      </Typography>
                    </Box>
                  ))}
                </Box>
              )}
            </CardContent>
          </Card>
        </Grid>

        {/* Upcoming Events */}
        <Grid size={{ xs: 12, md: 6 }}>
          <Card>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h6">
                  Upcoming Events
                </Typography>
                <Button size="small" onClick={() => navigate('/events')}>
                  View All
                </Button>
              </Box>
              
              {events.length === 0 ? (
                <Typography color="text.secondary">
                  No upcoming events
                </Typography>
              ) : (
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                  {events.map((event) => (
                    <Box key={event.id} sx={{ p: 2, border: '1px solid', borderColor: 'divider', borderRadius: 1 }}>
                      <Typography variant="subtitle2" gutterBottom>
                        {event.title}
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                        {event.description.substring(0, 100)}...
                      </Typography>
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <Typography variant="caption" color="text.secondary">
                          {event.location}
                        </Typography>
                        <Chip 
                          label={new Date(event.start_date).toLocaleDateString()} 
                          size="small" 
                          color="primary" 
                          variant="outlined"
                        />
                      </Box>
                    </Box>
                  ))}
                </Box>
              )}
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    </Box>
  );
};

export default DashboardPage;

================
File: src/pages/member/DiscussionsPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const DiscussionsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Discussions
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Discussions page coming soon...
      </Typography>
    </Box>
  );
};

export default DiscussionsPage;

================
File: src/pages/member/DiscussionThreadPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const DiscussionThreadPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Discussion Thread
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Discussion thread page coming soon...
      </Typography>
    </Box>
  );
};

export default DiscussionThreadPage;

================
File: src/pages/member/DocumentsPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const DocumentsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Documents
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Documents page coming soon...
      </Typography>
    </Box>
  );
};

export default DocumentsPage;

================
File: src/pages/member/EventsPage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const EventsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Events
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Events page coming soon...
      </Typography>
    </Box>
  );
};

export default EventsPage;

================
File: src/pages/member/ProfilePage.tsx
================
import React from 'react';
import { Typography, Box } from '@mui/material';

const ProfilePage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Profile
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Profile page coming soon...
      </Typography>
    </Box>
  );
};

export default ProfilePage;

================
File: src/pages/public/PublicHomePage.tsx
================
import React from 'react';
import { Container, Typography, Box } from '@mui/material';

const PublicHomePage: React.FC = () => {
  return (
    <Container component="main" maxWidth="lg">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
        }}
      >
        <Typography variant="h4" gutterBottom>
          Public Home Page
        </Typography>
        <Typography variant="body1" color="text.secondary">
          Public information coming soon...
        </Typography>
      </Box>
    </Container>
  );
};

export default PublicHomePage;

================
File: src/pages/create_pages.sh
================
#!/bin/bash

# Create member pages
cat > member/DiscussionsPage.tsx << 'MEMBER_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const DiscussionsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Discussions
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Discussions page coming soon...
      </Typography>
    </Box>
  );
};

export default DiscussionsPage;
MEMBER_EOF

cat > member/DiscussionThreadPage.tsx << 'MEMBER_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const DiscussionThreadPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Discussion Thread
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Discussion thread page coming soon...
      </Typography>
    </Box>
  );
};

export default DiscussionThreadPage;
MEMBER_EOF

cat > member/ProfilePage.tsx << 'MEMBER_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const ProfilePage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Profile
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Profile page coming soon...
      </Typography>
    </Box>
  );
};

export default ProfilePage;
MEMBER_EOF

# Create admin pages
cat > admin/AdminDashboardPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminDashboardPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Admin Dashboard
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Admin dashboard coming soon...
      </Typography>
    </Box>
  );
};

export default AdminDashboardPage;
ADMIN_EOF

cat > admin/AdminUsersPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminUsersPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        User Management
      </Typography>
      <Typography variant="body1" color="text.secondary">
        User management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminUsersPage;
ADMIN_EOF

cat > admin/AdminAnnouncementsPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminAnnouncementsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Manage Announcements
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Announcement management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminAnnouncementsPage;
ADMIN_EOF

cat > admin/AdminEventsPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminEventsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Manage Events
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Event management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminEventsPage;
ADMIN_EOF

cat > admin/AdminDocumentsPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminDocumentsPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Manage Documents
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Document management page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminDocumentsPage;
ADMIN_EOF

cat > admin/AdminConfigPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminConfigPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Site Configuration
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Site configuration page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminConfigPage;
ADMIN_EOF

cat > admin/AdminAuditPage.tsx << 'ADMIN_EOF'
import React from 'react';
import { Typography, Box } from '@mui/material';

const AdminAuditPage: React.FC = () => {
  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Audit Logs
      </Typography>
      <Typography variant="body1" color="text.secondary">
        Audit logs page coming soon...
      </Typography>
    </Box>
  );
};

export default AdminAuditPage;
ADMIN_EOF

echo "All pages created successfully!"

================
File: src/services/api.ts
================
import axios from 'axios';
import type { AxiosInstance, AxiosResponse } from 'axios';
import type {
  User,
  Announcement,
  Event,
  Document,
  Discussion,
  Config,
  AuditLog,
  PaginatedResponse,
  DocumentsResponse,
  DiscussionThreadResponse,
  LoginRequest,
  LoginResponse,
  RegisterRequest,
  RegisterResponse,
  ForgotPasswordRequest,
  ResetPasswordRequest,
  CreateAnnouncementRequest,
  CreateEventRequest,
  UpdateEventRequest,
  CreateDiscussionRequest,
  CreateReplyRequest,
  UpdateProfileRequest,
  ChangePasswordRequest,
  UpdateUserStatusRequest,
  UpdateUserRoleRequest,
  UpdateConfigRequest,
} from '../types/api';

class ApiService {
  private api: AxiosInstance;

  constructor() {
    this.api = axios.create({
      baseURL: 'http://localhost:3001/api',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Add request interceptor to include auth token
    this.api.interceptors.request.use((config) => {
      const token = localStorage.getItem('token');
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });

    // Add response interceptor to handle auth errors
    this.api.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          localStorage.removeItem('token');
          localStorage.removeItem('user');
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }
    );
  }

  // Authentication
  async login(data: LoginRequest): Promise<LoginResponse> {
    const response: AxiosResponse<LoginResponse> = await this.api.post('/auth/login', data);
    return response.data;
  }

  async register(data: RegisterRequest): Promise<RegisterResponse> {
    const response: AxiosResponse<RegisterResponse> = await this.api.post('/auth/register', data);
    return response.data;
  }

  async forgotPassword(data: ForgotPasswordRequest): Promise<{ message: string }> {
    const response = await this.api.post('/auth/forgot-password', data);
    return response.data;
  }

  async resetPassword(data: ResetPasswordRequest): Promise<{ message: string }> {
    const response = await this.api.post('/auth/reset-password', data);
    return response.data;
  }

  // User Profile
  async getProfile(): Promise<User> {
    const response: AxiosResponse<User> = await this.api.get('/users/me');
    return response.data;
  }

  async updateProfile(data: UpdateProfileRequest): Promise<User> {
    const response: AxiosResponse<User> = await this.api.put('/users/me', data);
    return response.data;
  }

  async changePassword(data: ChangePasswordRequest): Promise<{ message: string }> {
    const response = await this.api.put('/users/me/password', data);
    return response.data;
  }

  // Announcements
  async getAnnouncements(params?: {
    page?: number;
    limit?: number;
    status?: string;
    sortBy?: string;
    sortOrder?: string;
  }): Promise<PaginatedResponse<Announcement>> {
    const response: AxiosResponse<PaginatedResponse<Announcement>> = await this.api.get('/announcements', { params });
    return response.data;
  }

  async createAnnouncement(data: CreateAnnouncementRequest): Promise<Announcement> {
    const response: AxiosResponse<Announcement> = await this.api.post('/announcements', data);
    return response.data;
  }

  async updateAnnouncement(id: number, data: Partial<CreateAnnouncementRequest>): Promise<Announcement> {
    const response: AxiosResponse<Announcement> = await this.api.put(`/announcements/${id}`, data);
    return response.data;
  }

  async deleteAnnouncement(id: number): Promise<void> {
    await this.api.delete(`/announcements/${id}`);
  }

  // Events
  async getEvents(params?: {
    status?: string;
    page?: number;
    limit?: number;
    sortBy?: string;
    sortOrder?: string;
  }): Promise<PaginatedResponse<Event>> {
    const response: AxiosResponse<PaginatedResponse<Event>> = await this.api.get('/events', { params });
    return response.data;
  }

  async createEvent(data: CreateEventRequest): Promise<Event> {
    const response: AxiosResponse<Event> = await this.api.post('/events', data);
    return response.data;
  }

  async updateEvent(id: number, data: UpdateEventRequest): Promise<Event> {
    const response: AxiosResponse<Event> = await this.api.put(`/events/${id}`, data);
    return response.data;
  }

  async deleteEvent(id: number): Promise<void> {
    await this.api.delete(`/events/${id}`);
  }

  // Documents
  async getDocuments(params?: { limit?: number; offset?: number }): Promise<DocumentsResponse> {
    const response: AxiosResponse<DocumentsResponse> = await this.api.get('/documents', { params });
    return response.data;
  }

  async getDocument(id: number): Promise<Document> {
    const response: AxiosResponse<Document> = await this.api.get(`/documents/${id}`);
    return response.data;
  }

  async downloadDocument(id: number): Promise<Blob> {
    const response: AxiosResponse<Blob> = await this.api.get(`/documents/${id}/download`, {
      responseType: 'blob',
    });
    return response.data;
  }

  async uploadDocument(formData: FormData): Promise<{ message: string; document: Document }> {
    const response = await this.api.post('/admin/documents', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    return response.data;
  }

  async approveDocument(id: number): Promise<Document> {
    const response: AxiosResponse<Document> = await this.api.put(`/admin/documents/${id}/approve`);
    return response.data;
  }

  async deleteDocument(id: number): Promise<void> {
    await this.api.delete(`/admin/documents/${id}`);
  }

  // Discussions
  async getDiscussions(params?: { page?: number; limit?: number }): Promise<PaginatedResponse<Discussion>> {
    const response: AxiosResponse<PaginatedResponse<Discussion>> = await this.api.get('/discussions', { params });
    return response.data;
  }

  async createDiscussion(data: CreateDiscussionRequest): Promise<Discussion> {
    const response: AxiosResponse<Discussion> = await this.api.post('/discussions', data);
    return response.data;
  }

  async getDiscussionThread(id: number): Promise<DiscussionThreadResponse> {
    const response: AxiosResponse<DiscussionThreadResponse> = await this.api.get(`/discussions/${id}`);
    return response.data;
  }

  async createReply(threadId: number, data: CreateReplyRequest): Promise<Discussion> {
    const response: AxiosResponse<Discussion> = await this.api.post(`/discussions/${threadId}/replies`, data);
    return response.data;
  }

  async deleteDiscussion(id: number): Promise<void> {
    await this.api.delete(`/discussions/${id}`);
  }

  async deleteReply(id: number): Promise<void> {
    await this.api.delete(`/discussions/replies/${id}`);
  }

  // Admin - User Management
  async getUsers(params?: { limit?: number; offset?: number }): Promise<{ count: number; users: User[] }> {
    const response = await this.api.get('/admin/users', { params });
    return response.data;
  }

  async getUser(id: number): Promise<User> {
    const response: AxiosResponse<User> = await this.api.get(`/admin/users/${id}`);
    return response.data;
  }

  async updateUserStatus(id: number, data: UpdateUserStatusRequest): Promise<User> {
    const response: AxiosResponse<User> = await this.api.put(`/admin/users/${id}/status`, data);
    return response.data;
  }

  async updateUserRole(id: number, data: UpdateUserRoleRequest): Promise<User> {
    const response: AxiosResponse<User> = await this.api.put(`/admin/users/${id}/role`, data);
    return response.data;
  }

  async updateUserPassword(id: number, data: { newPassword: string }): Promise<{ message: string }> {
    const response = await this.api.put(`/admin/users/${id}/password`, data);
    return response.data;
  }

  async deleteUser(id: number): Promise<void> {
    await this.api.delete(`/admin/users/${id}`);
  }

  // Admin - Site Configuration
  async getConfig(): Promise<Config> {
    const response: AxiosResponse<Config> = await this.api.get('/admin/config');
    return response.data;
  }

  async updateConfig(key: string, data: UpdateConfigRequest): Promise<{ message: string }> {
    const response = await this.api.put(`/admin/config/${key}`, data);
    return response.data;
  }

  // Admin - Audit Logs
  async getAuditLogs(params?: { page?: number; limit?: number }): Promise<PaginatedResponse<AuditLog>> {
    const response: AxiosResponse<PaginatedResponse<AuditLog>> = await this.api.get('/admin/audit-logs', { params });
    return response.data;
  }
}

export const apiService = new ApiService();

================
File: src/theme/theme.ts
================
import { createTheme } from '@mui/material/styles';

// Define custom color palette
const palette = {
  primary: {
    main: '#1976d2', // Professional blue
    light: '#42a5f5',
    dark: '#1565c0',
    contrastText: '#ffffff',
  },
  secondary: {
    main: '#dc004e', // Accent red
    light: '#ff5983',
    dark: '#9a0036',
    contrastText: '#ffffff',
  },
  background: {
    default: '#f5f5f5',
    paper: '#ffffff',
  },
  text: {
    primary: '#212121',
    secondary: '#757575',
  },
  success: {
    main: '#4caf50',
    light: '#81c784',
    dark: '#388e3c',
  },
  warning: {
    main: '#ff9800',
    light: '#ffb74d',
    dark: '#f57c00',
  },
  error: {
    main: '#f44336',
    light: '#e57373',
    dark: '#d32f2f',
  },
  info: {
    main: '#2196f3',
    light: '#64b5f6',
    dark: '#1976d2',
  },
};

// Create the theme
export const theme = createTheme({
  palette,
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 600,
      lineHeight: 1.3,
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 600,
      lineHeight: 1.4,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 600,
      lineHeight: 1.4,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 600,
      lineHeight: 1.5,
    },
    h6: {
      fontSize: '1rem',
      fontWeight: 600,
      lineHeight: 1.6,
    },
    body1: {
      fontSize: '1rem',
      lineHeight: 1.6,
    },
    body2: {
      fontSize: '0.875rem',
      lineHeight: 1.6,
    },
    button: {
      textTransform: 'none',
      fontWeight: 500,
    },
  },
  shape: {
    borderRadius: 8,
  },
  spacing: 8,
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          padding: '8px 16px',
          fontSize: '0.875rem',
          fontWeight: 500,
          textTransform: 'none',
          boxShadow: 'none',
          '&:hover': {
            boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
          },
        },
        contained: {
          '&:hover': {
            boxShadow: '0 4px 8px rgba(0,0,0,0.15)',
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
          '&:hover': {
            boxShadow: '0 4px 16px rgba(0,0,0,0.15)',
          },
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
        elevation1: {
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        },
        elevation2: {
          boxShadow: '0 4px 8px rgba(0,0,0,0.12)',
        },
        elevation3: {
          boxShadow: '0 6px 12px rgba(0,0,0,0.15)',
        },
      },
    },
    MuiTextField: {
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-root': {
            borderRadius: 8,
          },
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          borderRadius: 0,
          borderRight: '1px solid rgba(0,0,0,0.12)',
        },
      },
    },
    MuiListItemButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          margin: '2px 8px',
          '&:hover': {
            backgroundColor: 'rgba(25, 118, 210, 0.08)',
          },
          '&.Mui-selected': {
            backgroundColor: 'rgba(25, 118, 210, 0.12)',
            '&:hover': {
              backgroundColor: 'rgba(25, 118, 210, 0.16)',
            },
          },
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 16,
        },
      },
    },
    MuiAlert: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
      },
    },
  },
});

// Status color mappings for consistent UI
export const statusColors = {
  pending: '#ff9800', // Orange
  approved: '#4caf50', // Green
  rejected: '#f44336', // Red
  active: '#4caf50', // Green
  expired: '#757575', // Gray
} as const;

// Role color mappings
export const roleColors = {
  admin: '#dc004e', // Secondary color
  member: '#1976d2', // Primary color
} as const;

export default theme;

================
File: src/types/api.ts
================
// API Data Models based on the HOA Management API

export interface User {
  id: number;
  name: string;
  email: string;
  role: 'member' | 'admin';
  status: 'pending' | 'approved' | 'rejected';
  email_verified: boolean;
  is_system_user: boolean;
  created_at: string;
  updated_at: string;
}

export interface Announcement {
  id: number;
  title: string;
  content: string;
  created_by: number;
  expires_at: string | null;
  created_at: string;
  updated_at: string;
  creator?: {
    id: number;
    name: string;
  };
}

export interface Event {
  id: number;
  title: string;
  description: string;
  start_date: string;
  end_date: string;
  location: string;
  created_by: number;
  created_at: string;
  updated_at: string;
  creator?: {
    id: number;
    name: string;
  };
}

export interface Document {
  id: number;
  title: string;
  description: string | null;
  file_name: string;
  original_file_name: string;
  file_path: string;
  uploaded_by: number;
  approved: boolean;
  is_public: boolean;
  uploaded_at: string;
  updated_at: string;
  uploader?: {
    id: number;
    name: string;
  };
}

export interface Discussion {
  id: number;
  title: string | null;
  content: string;
  user_id: number;
  parent_id: number | null;
  created_at: string;
  updated_at: string;
  author?: {
    id: number;
    name: string;
  };
  reply_count?: number;
}

export interface Config {
  [key: string]: string;
}

export interface AuditLog {
  id: number;
  admin_name: string;
  action: string;
  details: object;
  created_at: string;
}

// API Response Types
export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    totalItems: number;
    totalPages: number;
    currentPage: number;
    limit: number;
  };
}

export interface DocumentsResponse {
  count: number;
  documents: Document[];
}

export interface DiscussionThreadResponse {
  mainThread: Discussion;
  replies: Discussion[];
}

// Auth Types
export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  message: string;
  token: string;
  user: User;
}

export interface RegisterRequest {
  name: string;
  email: string;
  password: string;
}

export interface RegisterResponse {
  message: string;
  user: User;
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ResetPasswordRequest {
  token: string;
  newPassword: string;
}

// Form Types
export interface CreateAnnouncementRequest {
  title: string;
  content: string;
  expiresAt?: string;
}

export interface CreateEventRequest {
  title: string;
  description: string;
  event_date: string;
  location: string;
}

export interface UpdateEventRequest {
  title?: string;
  description?: string;
  start_date?: string;
  end_date?: string;
  location?: string;
}

export interface CreateDiscussionRequest {
  title: string;
  content: string;
}

export interface CreateReplyRequest {
  content: string;
}

export interface UpdateProfileRequest {
  name: string;
}

export interface ChangePasswordRequest {
  currentPassword: string;
  newPassword: string;
}

export interface UpdateUserStatusRequest {
  status: 'approved' | 'pending' | 'rejected';
}

export interface UpdateUserRoleRequest {
  role: 'admin' | 'member';
}

export interface UpdateConfigRequest {
  value: string;
}

// Error Response
export interface ApiError {
  message: string;
  error?: string;
}

================
File: src/App.css
================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: src/App.tsx
================
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider } from '@mui/material/styles';
import { CssBaseline } from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';

import { AuthProvider } from './contexts/AuthContext';
import { theme } from './theme/theme';
import ProtectedRoute from './components/common/ProtectedRoute';
import PublicRoute from './components/common/PublicRoute';
import Layout from './components/layout/Layout';

// Public Pages
import LoginPage from './pages/auth/LoginPage';
import RegisterPage from './pages/auth/RegisterPage';
import ForgotPasswordPage from './pages/auth/ForgotPasswordPage';
import ResetPasswordPage from './pages/auth/ResetPasswordPage';
import PublicHomePage from './pages/public/PublicHomePage';

// Member Pages
import DashboardPage from './pages/member/DashboardPage';
import AnnouncementsPage from './pages/member/AnnouncementsPage';
import EventsPage from './pages/member/EventsPage';
import DocumentsPage from './pages/member/DocumentsPage';
import DiscussionsPage from './pages/member/DiscussionsPage';
import DiscussionThreadPage from './pages/member/DiscussionThreadPage';
import ProfilePage from './pages/member/ProfilePage';

// Admin Pages
import AdminDashboardPage from './pages/admin/AdminDashboardPage';
import AdminUsersPage from './pages/admin/AdminUsersPage';
import AdminAnnouncementsPage from './pages/admin/AdminAnnouncementsPage';
import AdminEventsPage from './pages/admin/AdminEventsPage';
import AdminDocumentsPage from './pages/admin/AdminDocumentsPage';
import AdminConfigPage from './pages/admin/AdminConfigPage';
import AdminAuditPage from './pages/admin/AdminAuditPage';

const App: React.FC = () => {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <LocalizationProvider dateAdapter={AdapterDayjs}>
        <AuthProvider>
          <Router>
            <Routes>
              {/* Public Routes */}
              <Route
                path="/login"
                element={
                  <PublicRoute>
                    <LoginPage />
                  </PublicRoute>
                }
              />
              <Route
                path="/register"
                element={
                  <PublicRoute>
                    <RegisterPage />
                  </PublicRoute>
                }
              />
              <Route
                path="/forgot-password"
                element={
                  <PublicRoute>
                    <ForgotPasswordPage />
                  </PublicRoute>
                }
              />
              <Route
                path="/reset-password"
                element={
                  <PublicRoute>
                    <ResetPasswordPage />
                  </PublicRoute>
                }
              />
              <Route
                path="/public"
                element={
                  <PublicRoute>
                    <PublicHomePage />
                  </PublicRoute>
                }
              />

              {/* Protected Member Routes */}
              <Route
                path="/"
                element={
                  <ProtectedRoute>
                    <Layout />
                  </ProtectedRoute>
                }
              >
                <Route index element={<Navigate to="/dashboard" replace />} />
                <Route path="dashboard" element={<DashboardPage />} />
                <Route path="announcements" element={<AnnouncementsPage />} />
                <Route path="events" element={<EventsPage />} />
                <Route path="documents" element={<DocumentsPage />} />
                <Route path="discussions" element={<DiscussionsPage />} />
                <Route path="discussions/:id" element={<DiscussionThreadPage />} />
                <Route path="profile" element={<ProfilePage />} />

                {/* Admin Routes */}
                <Route
                  path="admin"
                  element={
                    <ProtectedRoute requireAdmin>
                      <Navigate to="/admin/dashboard" replace />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/dashboard"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminDashboardPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/users"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminUsersPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/announcements"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminAnnouncementsPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/events"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminEventsPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/documents"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminDocumentsPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/config"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminConfigPage />
                    </ProtectedRoute>
                  }
                />
                <Route
                  path="admin/audit"
                  element={
                    <ProtectedRoute requireAdmin>
                      <AdminAuditPage />
                    </ProtectedRoute>
                  }
                />
              </Route>

              {/* Fallback route */}
              <Route path="*" element={<Navigate to="/" replace />} />
            </Routes>
          </Router>
        </AuthProvider>
      </LocalizationProvider>
    </ThemeProvider>
  );
};

export default App;

================
File: src/index.css
================
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

================
File: src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^7.1.1",
    "@mui/material": "^7.1.1",
    "@mui/x-date-pickers": "^8.5.1",
    "@types/yup": "^0.29.14",
    "axios": "^1.9.0",
    "dayjs": "^1.11.13",
    "formik": "^2.4.6",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-router-dom": "^7.6.2",
    "yup": "^1.6.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "^6.3.5"
  }
}

================
File: README.md
================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

================
File: frontend/tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: frontend/tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: frontend/tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: frontend/vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

================
File: .dockerignore
================
# Git specific
.git
.gitignore

# Node modules (for both backend and potentially frontend if it exists here)
backend/node_modules/
frontend/node_modules/ # If frontend directory exists at root
node_modules/ # General node_modules at root, if any

# Environment files (should be passed at runtime)
.env
.env.*
!.env.example

# Docker specific files
Dockerfile
backend.Dockerfile # If you named it differently
frontend.Dockerfile # If you add a frontend Dockerfile
docker-compose.yml
docker-compose.*.yml

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Local database files (will be mounted as a volume)
# These paths are relative to the project root, where .dockerignore resides
backend/database/*.db
backend/database/*.db-journal

# Local uploads (will be mounted as a volume)
backend/uploads/

# IDE specific
.vscode/
.idea/

# OS specific
.DS_Store
Thumbs.db

# Other build artifacts or temporary files
# Example:
# frontend/dist/
# frontend/build/

================
File: .env.example
================
# Server Configuration
PORT=3000
NODE_ENV=development

# JWT Configuration
JWT_SECRET=your-jwt-secret-here
JWT_EXPIRATION=1h

# Admin Account (for seeding)
ADMIN_EMAIL=admin@example.com
ADMIN_PASSWORD=change-this-password

# HOA Configuration (for seeding)
HOA_NAME=Sanderson Creek HOA
HOA_DESCRIPTION=Sanderson Creek HOA Community Management System
HOA_LOGO=/images/logo.png

# File Upload Configuration
MAX_FILE_SIZE=5242880  # 5MB in bytes
UPLOAD_PATH=./uploads/documents

# Allowed File Types (comma-separated)
ALLOWED_FILE_TYPES=pdf,doc,docx,jpg,jpeg,png
APP_PORT=3001

================
File: .gitignore
================
# Dependencies
node_modules/

# Environment
.env
.env.*
!.env.example

# Database
src/database/*.db
src/database/*.db-journal

# Logs
logs/
*.log
npm-debug.log*

# IDE
.vscode/
.idea/

# Misc
.DS_Store
coverage/

================
File: API-overview.md
================
# HOA Management API Documentation

## 1. Introduction

Welcome to the HOA Management API documentation. This document provides all the necessary information for developers to build a modern, feature-rich client application for a Homeowners Association website. The API is built using Node.js, Express, and Sequelize, providing a RESTful interface for managing users, announcements, events, documents, and community discussions.

The API is designed with a clear separation of roles and permissions, primarily distinguishing between **members** and **admins**. This documentation will detail each endpoint, its purpose, required permissions, request/response formats, and provide context for its use in a front-end application.

### 1.1. Base URL

All API routes are prefixed with `/api`. The base URL for the API will depend on your deployment environment.

-   **Development (Local):** `http://localhost:3001/api`

### 1.2. General Conventions

-   **Request/Response Format:** All data is sent and received in `JSON` format.
-   **Authentication:** Protected endpoints require a JSON Web Token (JWT) to be sent in the `Authorization` header as a Bearer token.
-   **Error Handling:** The API uses standard HTTP status codes to indicate the success or failure of a request. Error responses will include a `message` or `error` key with a descriptive string.
    -   `400 Bad Request`: Invalid input, validation error.
    -   `401 Unauthorized`: Missing or invalid authentication token.
    -   `403 Forbidden`: Authenticated user lacks permission to access the resource.
    -   `404 Not Found`: The requested resource does not exist.
    -   `409 Conflict`: Resource creation failed due to a conflict (e.g., duplicate email).
    -   `500 Internal Server Error`: An unexpected error occurred on the server.

---

## 2. Authentication

Authentication is managed via JWTs. Users must first register and be approved by an admin before they can log in and access protected resources.

### `POST /auth/register`

Registers a new user. New accounts are created with a `pending` status and must be approved by an administrator.

-   **Authorization:** Public
-   **Request Body:**
    ```json
    {
      "name": "Jane Resident",
      "email": "jane.resident@example.com",
      "password": "SecurePassword123!"
    }
    ```
-   **Success Response (201 Created):**
    ```json
    {
      "message": "Registration successful. Your account is pending approval.",
      "user": {
        "id": 5,
        "name": "Jane Resident",
        "email": "jane.resident@example.com",
        "role": "member",
        "status": "pending",
        "email_verified": false,
        "is_system_user": false,
        "created_at": "2025-06-09T10:00:00.000Z",
        "updated_at": "2025-06-09T10:00:00.000Z"
      }
    }
    ```

### `POST /auth/login`

Logs in an approved user and returns a JWT for accessing protected routes.

-   **Authorization:** Public
-   **Request Body:**
    ```json
    {
      "email": "jane.resident@example.com",
      "password": "SecurePassword123!"
    }
    ```
-   **Success Response (200 OK):**
    ```json
    {
      "message": "Login successful.",
      "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "user": {
        "id": 5,
        "name": "Jane Resident",
        "email": "jane.resident@example.com",
        "role": "member",
        "status": "approved"
        // ... other user fields
      }
    }
    ```

### `POST /auth/forgot-password`

Initiates the password reset process. If the user exists and is active, a password reset link will be generated (in a real implementation, this would be emailed).

-   **Authorization:** Public
-   **Request Body:**
    ```json
    {
      "email": "jane.resident@example.com"
    }
    ```
-   **Success Response (200 OK):**
    ```json
    {
      "message": "Password reset email sent. Please check your inbox."
    }
    ```

### `POST /auth/reset-password`

Resets the user's password using the token from the forgot-password flow.

-   **Authorization:** Public
-   **Request Body:**
    ```json
    {
      "token": "THE_GENERATED_TOKEN_FROM_EMAIL",
      "newPassword": "NewerSecurePassword456!"
    }
    ```
-   **Success Response (200 OK):**
    ```json
    {
      "message": "Password has been reset successfully."
    }
    ```
-   **Note:** The `token` is the plain token from the reset link, not a JWT. The new password must meet complexity requirements (min 8 characters, uppercase, lowercase, number, special character).

---

## 3. Data Models

These are the primary data objects returned by the API.

### User Object

Represents a user account in the system. The `password` field is never returned.

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  role: 'member' | 'admin';
  status: 'pending' | 'approved' | 'rejected';
  email_verified: boolean;
  is_system_user: boolean; // System users cannot be modified/deleted by admins
  created_at: string; // ISO 8601 Date
  updated_at: string; // ISO 8601 Date
}
```

### Announcement Object

Represents a site-wide announcement.

```typescript
interface Announcement {
  id: number;
  title: string;
  content: string; // Sanitized HTML content
  created_by: number;
  expires_at: string | null; // ISO 8601 Date
  created_at: string; // ISO 8601 Date
  updated_at: string; // ISO 8601 Date
  creator?: { // Included in list views
    id: number;
    name: string;
  };
}
```

### Event Object

Represents a community event.

```typescript
interface Event {
  id: number;
  title: string;
  description: string;
  start_date: string; // ISO 8601 Date
  end_date: string; // ISO 8601 Date
  location: string;
  created_by: number;
  created_at: string; // ISO 8601 Date
  updated_at: string; // ISO 8601 Date
  creator?: { // Included in list views
    id: number;
    name: string;
  };
}
```

### Document Object

Represents a file uploaded to the system.

```typescript
interface Document {
  id: number;
  title: string;
  description: string | null;
  file_name: string; // Unique stored filename
  original_file_name: string; // User-facing filename
  file_path: string; // Server-side path (not for client use)
  uploaded_by: number;
  approved: boolean;
  is_public: boolean;
  uploaded_at: string; // ISO 8601 Date
  updated_at: string; // ISO 8601 Date
  uploader?: { // Included in list views
    id: number;
    name: string;
  };
}
```

### Discussion Object

Represents a discussion thread or a reply.

```typescript
interface Discussion {
  id: number;
  title: string | null; // Null for replies
  content: string; // Sanitized HTML content
  user_id: number;
  parent_id: number | null; // Null for main threads
  created_at: string; // ISO 8601 Date
  updated_at: string; // ISO 8601 Date
  author?: { // Included in list/view endpoints
    id: number;
    name: string;
  };
  // 'reply_count' is included in thread lists
  reply_count?: number; 
}
```

### Config Object

Represents a key-value site configuration setting.

```typescript
interface Config {
  [key: string]: string; // e.g., { "hoa_name": "Sanderson Creek HOA" }
}
```

### AuditLog Object

Represents a logged administrative action.

```typescript
interface AuditLog {
  id: number;
  admin_name: string; // Name of the admin who performed the action
  action: string; // e.g., 'user_status_update'
  details: object; // JSON object with details of the action
  created_at: string; // ISO 8601 Date
}
```
---

## 4. API Endpoints

### 4.1. User Profile (Self-Management)

These endpoints allow authenticated users to manage their own profiles.

-   **Base Path:** `/api/users`
-   **Authorization:** `Member` or `Admin`

#### `GET /me`
-   **Description:** Retrieves the profile of the currently authenticated user.
-   **Success Response (200 OK):** A `User` object.

#### `PUT /me`
-   **Description:** Updates the authenticated user's name.
-   **Request Body:** `{ "name": "New Name" }`
-   **Success Response (200 OK):** The updated `User` object.

#### `PUT /me/password`
-   **Description:** Changes the authenticated user's password.
-   **Request Body:** `{ "currentPassword": "oldPassword", "newPassword": "NewSecurePassword123!" }`
-   **Success Response (200 OK):** `{ "message": "Password changed successfully." }`

### 4.2. Announcements

Endpoints for managing and viewing announcements.

-   **Base Path:** `/api/announcements`

#### `GET /`
-   **Description:** Lists active announcements. Useful for the main dashboard.
-   **Authorization:** `Member` or `Admin`
-   **Query Parameters:**
    -   `page` (number, optional, default: 1)
    -   `limit` (number, optional, default: 10)
    -   `status` (string, optional, must be 'active'): Filters for non-expired announcements.
    -   `sortBy` (string, optional, default: 'created_at')
    -   `sortOrder` (string, optional, 'ASC' or 'DESC')
-   **Success Response (200 OK):**
    ```json
    {
      "data": [ /* Array of Announcement objects */ ],
      "pagination": {
        "totalItems": 15,
        "totalPages": 2,
        "currentPage": 1,
        "limit": 10
      }
    }
    ```

#### `POST /`
-   **Description:** Creates a new announcement.
-   **Authorization:** `Admin Only`
-   **Request Body:**
    ```json
    {
      "title": "Community Pool Maintenance",
      "content": "<p>The community pool will be closed for maintenance from June 10th to June 12th.</p>",
      "expiresAt": "2025-06-13T00:00:00.000Z" // Optional
    }
    ```
-   **Success Response (201 Created):** An `Announcement` object.

#### `PUT /:id`
-   **Description:** Updates an existing announcement.
-   **Authorization:** `Admin Only`
-   **Request Body:** `{ "title": "...", "content": "...", "expires_at": "..." }` (at least one field required)
-   **Success Response (200 OK):** The updated `Announcement` object.

#### `DELETE /:id`
-   **Description:** Deletes an announcement.
-   **Authorization:** `Admin Only`
-   **Success Response (204 No Content):** No body.

### 4.3. Events

Endpoints for managing and viewing community events.

-   **Base Path:** `/api/events`

#### `GET /`
-   **Description:** Lists community events. The main event calendar view.
-   **Authorization:** `Member` or `Admin`
-   **Query Parameters:**
    -   `status` (string, optional, default: 'upcoming'): Can be `upcoming` or `past`.
    -   `page`, `limit`, `sortBy` ('event_date', 'title', 'created_at'), `sortOrder`
-   **Success Response (200 OK):** Paginated list of `Event` objects.

#### `POST /`
-   **Description:** Creates a new event.
-   **Authorization:** `Admin Only`
-   **Request Body:**
    ```json
    {
      "title": "Annual HOA BBQ",
      "description": "Join us for our annual community BBQ!",
      "event_date": "2025-07-04T12:00:00.000Z", // Maps to start_date
      "location": "Community Park"
    }
    ```
-   **Success Response (201 Created):** An `Event` object.

#### `PUT /:id`
-   **Description:** Updates an existing event.
-   **Authorization:** `Admin Only`
-   **Request Body:** `{ "title": "...", "description": "...", "start_date": "...", "end_date": "...", "location": "..." }`
-   **Success Response (200 OK):** The updated `Event` object.

#### `DELETE /:id`
-   **Description:** Deletes an event.
-   **Authorization:** `Admin Only`
-   **Success Response (204 No Content):** No body.

### 4.4. Documents

Endpoints for managing and accessing documents. Note the two base paths for admin vs. public access.

-   **Public/Member Base Path:** `/api/documents`
-   **Admin Base Path:** `/api/admin/documents`

#### `GET /api/documents`
-   **Description:** Lists documents. Guests see only `public` and `approved` documents. Members see all `approved` documents. Admins see all documents via this route if authenticated.
-   **Authorization:** `Optional` (Public, Member, or Admin)
-   **Query Parameters:** `limit`, `offset`
-   **Success Response (200 OK):** `{ "count": 20, "documents": [ /* Array of Document objects */ ] }`

#### `GET /api/documents/:documentId`
-   **Description:** Gets metadata for a single document, respecting access permissions.
-   **Authorization:** `Optional`
-   **Success Response (200 OK):** A `Document` object.

#### `GET /api/documents/:documentId/download`
-   **Description:** Downloads the physical file for a document, respecting access permissions.
-   **Authorization:** `Optional`
-   **Success Response (200 OK):** The file stream with appropriate `Content-Type` header.

#### `POST /api/admin/documents`
-   **Description:** Uploads a new document.
-   **Authorization:** `Admin Only`
-   **Request Body:** `multipart/form-data`
    -   `documentFile`: The file to upload (PDF, DOC/DOCX, JPG, PNG, GIF). Max 10MB.
    -   `title` (string): Title of the document.
    -   `description` (string, optional): Description of the document.
    -   `is_public` (boolean): `true` if the document should be visible to guests.
-   **Success Response (201 Created):** `{ "message": "...", "document": { ...Document object... } }`

#### `PUT /api/admin/documents/:id/approve`
-   **Description:** Approves a document, making it visible to members (and public if flagged).
-   **Authorization:** `Admin Only`
-   **Success Response (200 OK):** The updated `Document` object.

#### `DELETE /api/admin/documents/:id`
-   **Description:** Deletes a document record and its physical file.
-   **Authorization:** `Admin Only`
-   **Success Response (204 No Content):** No body.

### 4.5. Discussions

Endpoints for the community discussion forum.

-   **Base Path:** `/api/discussions`
-   **Authorization:** `Member` or `Admin`

#### `GET /`
-   **Description:** Lists all main discussion threads (not replies), including author info and reply count.
-   **Query Parameters:** `page`, `limit`
-   **Success Response (200 OK):** Paginated list of `Discussion` objects.

#### `POST /`
-   **Description:** Creates a new main discussion thread.
-   **Request Body:** `{ "title": "New Thread Title", "content": "My question is..." }`
-   **Success Response (201 Created):** A `Discussion` object.

#### `GET /:threadId`
-   **Description:** Retrieves a single main thread and all of its replies, sorted chronologically.
-   **Success Response (200 OK):** `{ "mainThread": { ...Discussion object... }, "replies": [ /* Array of Discussion objects */ ] }`

#### `POST /:threadId/replies`
-   **Description:** Adds a reply to a specific discussion thread.
-   **Request Body:** `{ "content": "This is my reply." }`
-   **Success Response (201 Created):** The new reply `Discussion` object.

#### `DELETE /:threadId`
-   **Description:** Deletes a main discussion thread and all its replies.
-   **Authorization:** `Admin Only`
-   **Success Response (204 No Content):** No body.

#### `DELETE /replies/:replyId`
-   **Description:** Deletes a single reply.
-   **Authorization:** `Admin Only`
-   **Success Response (204 No Content):** No body.

### 4.6. Administration

Endpoints reserved for high-level administrative tasks.

#### User Management
-   **Base Path:** `/api/admin/users`
-   **Authorization:** `Admin Only`

-   **`GET /`**: Lists all non-system users. Supports `limit` and `offset` query params.
-   **`GET /:userId`**: Gets a specific non-system user's details.
-   **`PUT /:userId/status`**: Updates a user's status. Body: `{ "status": "approved" | "pending" | "rejected" }`.
-   **`PUT /:userId/role`**: Updates a user's role. Body: `{ "role": "admin" | "member" }`.
-   **`PUT /:userId/password`**: Changes a user's password. Body: `{ "newPassword": "..." }`.
-   **`DELETE /:userId`**: Deletes a user and all their associated content (e.g., uploaded documents).

#### Site Configuration
-   **Base Path:** `/api/admin/config`
-   **Authorization:** `Admin Only`

-   **`GET /`**: Retrieves all site configuration key-value pairs.
-   **`PUT /:key`**: Updates or creates a configuration value. Body: `{ "value": "New HOA Name" }`.

#### Audit Logs
-   **Base Path:** `/api/admin/audit-logs`
-   **Authorization:** `Admin Only`

-   **`GET /`**: Retrieves a paginated list of all administrative actions. Supports `page` and `limit` query params.

---

## 5. UI/UX Implementation Guidance

Based on this API, a modern and "beautiful" web client could be structured as follows:

### 5.1. Public-Facing Pages (No Login Required)

-   **Login Page:** Uses the `/api/auth/login` endpoint. Include a "Forgot Password?" link.
-   **Registration Page:** Uses `/api/auth/register`. Clearly state that accounts require admin approval.
-   **Password Reset Page:** A two-step process. A page to request the reset (`/api/auth/forgot-password`), and a page that accepts the token from the email link to set a new password (`/api/auth/reset-password`).
-   **Public Content:** A section of the site could display public-only documents (`GET /api/documents` without a token) or announcements, creating a welcoming portal for prospective residents.

### 5.2. Member-Authenticated Area

This is the main dashboard for residents.

-   **Dashboard Home:** The landing page after login. Should prominently display a feed of the latest announcements (`GET /api/announcements`) and a list or calendar of upcoming events (`GET /api/events`).
-   **Documents Library:** A searchable, filterable view of all approved documents (`GET /api/documents`). Each document should be viewable (metadata) and downloadable.
-   **Discussion Forum:** A page listing all discussion threads (`GET /api/discussions`) with links to view a single thread and its replies (`GET /api/discussions/:threadId`). Users should be able to create new threads and post replies.
-   **My Profile:** A page for users to view (`GET /api/users/me`), update their name (`PUT /api/users/me`), and change their password (`PUT /api/users/me/password`).

### 5.3. Admin-Authenticated Area

A separate, secure section of the site for administrators. This should have a distinct layout, possibly with a sidebar for navigation.

-   **Admin Dashboard:** Could provide a high-level overview: number of pending users, recent activities, etc.
-   **User Management:** A table of all users (`GET /api/admin/users`).
    -   Provide actions to **approve/reject/pending** user status (`PUT /api/admin/users/:id/status`). This is a key workflow.
    -   Provide actions to change a user's role, change their password, or delete them entirely.
-   **Content Management:**
    -   **Announcements:** A view to list, create, edit, and delete announcements.
    -   **Events:** A view to list, create, edit, and delete events.
    -   **Documents:** A comprehensive view of all documents (approved or not). Admins should have clear "Approve" and "Delete" buttons for each document. A dedicated upload form should use the `POST /api/admin/documents` endpoint.
-   **Site Settings:** A form to manage site configuration (`GET /api/admin/config` to populate, `PUT /api/admin/config/:key` to save), allowing admins to change the HOA Name, Description, etc.
-   **Audit Trail:** A page to display the audit logs (`GET /api/admin/audit-logs`) in a clear, paginated table, showing which admin performed what action and when. This is crucial for accountability.

================
File: backend-system-analysis.md
================
# Backend System Analysis for Frontend Integration

## 1. API Surface Summary

### Authentication
| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/auth/register` | POST | Register new user (status: pending) |
| `/api/auth/login` | POST | Authenticate user, return JWT |
| `/api/auth/forgot-password` | POST | Initiate password reset |
| `/api/auth/verify-reset-token` | GET | Validate password reset token |
| `/api/auth/reset-password` | POST | Complete password reset |

### User Profile
| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/users/me` | GET | Get authenticated user's profile |
| `/api/users/me` | PUT | Update user's profile |
| `/api/users/me/password` | PUT | Change user's password |

### Admin Management
| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/admin/users` | GET | List all non-system users |
| `/api/admin/users/{id}` | GET | Get user details by ID |
| `/api/admin/users/{id}/status` | PUT | Update user status |
| `/api/admin/users/{id}/role` | PUT | Update user role |
| `/api/admin/users/{id}/password` | PUT | Change user's password (admin) |
| `/api/admin/users/{id}` | DELETE | Delete user and associated data |

### Content Modules
*(Refer to phase.md for full endpoint details)*
- Announcements: CRUD operations
- Events: CRUD operations
- Documents: Upload/download with approval flow
- Discussions: Thread/reply management

## 2. Core Data Models

```mermaid
erDiagram
    USER ||--o{ DOCUMENT : uploads
    USER ||--o{ EVENT : creates
    USER ||--o{ ANNOUNCEMENT : creates
    USER ||--o{ DISCUSSION : authors
    DISCUSSION ||--o{ DISCUSSION : replies
    DOCUMENT ||--o{ DISCUSSION : referenced_in

    USER {
        int id PK
        string name
        string email
        string password
        string role
        string status
        boolean email_verified
        boolean is_system_user
    }
    
    DOCUMENT {
        int id PK
        string title
        string description
        string file_name
        string file_path
        boolean approved
        boolean is_public
    }
    
    EVENT {
        int id PK
        string title
        string description
        datetime start_date
        datetime end_date
        string location
    }
    
    ANNOUNCEMENT {
        int id PK
        string title
        text content
        datetime expires_at
    }
    
    DISCUSSION {
        int id PK
        string title
        text content
        int parent_id FK
    }
```

## 3. Auth Mechanism

### JWT Flow
```mermaid
sequenceDiagram
    Frontend->>Backend: POST /api/auth/login (email, password)
    Backend->>Frontend: JWT + User Data
    Frontend->>Backend: Subsequent requests (with Authorization: Bearer <token>)
    Backend->>Backend: Verify token + check permissions
    Backend->>Frontend: Requested data or error
```

### Role-Based Access
| Role | Permissions |
|------|-------------|
| Member | View content, Manage own profile, Post discussions |
| Admin | Full user management, Content moderation, System configuration |

## 4. Key Dependencies
- **Runtime**: Node.js
- **Framework**: Express
- **Database**: SQLite via Sequelize ORM
- **Auth**: jsonwebtoken, bcrypt
- **Validation**: Joi, express-validator
- **File Handling**: multer
- **Security**: dompurify, jsdom

## 5. Integration Risks
1. **File Uploads**: 
   - Requires multipart/form-data handling
   - Large file support not implemented
   - Virus scanning not included

2. **Error Handling**:
   - Mixed error response formats (some Swagger-standard, some custom)
   - Needs consistent frontend error parsing

3. **Security**:
   - JWT storage/refresh strategy needed
   - Content sanitization for rich text fields

4. **Pagination**:
   - Inconsistent pagination parameters across endpoints
   - Frontend must handle varying response structures

5. **State Management**:
   - Pending user status requires special handling
   - Admin approval flows need UI representation

================
File: DOCKER_GUIDE.md
================
# Docker Setup Guide - HOA Management System

This guide explains how to run the HOA Management System using Docker containers.

##  **Overview**

The application is containerized with the following services:
- **Backend**: Node.js API server (Port 3001)
- **Frontend**: React application served by Nginx (Port 3000)
- **Test Runner**: Automated testing service

##  **Prerequisites**

- Docker Engine 20.10+
- Docker Compose 2.0+
- At least 2GB available RAM
- Ports 3000 and 3001 available on your host machine

##  **Quick Start**

### **1. Clone and Setup**
```bash
git clone <repository-url>
cd hoa-management-system
```

### **2. Environment Configuration**
Create a `.env` file in the project root:
```bash
cp .env.example .env
```

Edit the `.env` file with your configuration:
```env
# Backend Configuration
NODE_ENV=production
APP_PORT=3001
PORT=3001

# Frontend Configuration
FRONTEND_PORT=3000

# Database
DB_PATH=/usr/src/app/backend/database/hoa.db

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-here
JWT_EXPIRES_IN=7d

# File Upload
MAX_FILE_SIZE_MB=10
```

### **3. Build and Run**
```bash
# Build and start all services
docker-compose up --build

# Or run in detached mode
docker-compose up --build -d
```

### **4. Access the Application**
- **Frontend**: http://localhost:3000
- **Backend API**: http://localhost:3001/api
- **Public Page**: http://localhost:3000/public

##  **Docker Commands**

### **Basic Operations**
```bash
# Start services
docker-compose up

# Start in background
docker-compose up -d

# Stop services
docker-compose down

# Rebuild and start
docker-compose up --build

# View logs
docker-compose logs

# View logs for specific service
docker-compose logs frontend
docker-compose logs backend
```

### **Development Commands**
```bash
# Run tests
docker-compose run test-runner

# Access backend container shell
docker-compose exec backend sh

# Access frontend container shell
docker-compose exec frontend sh

# Restart specific service
docker-compose restart frontend
docker-compose restart backend
```

### **Cleanup Commands**
```bash
# Stop and remove containers
docker-compose down

# Remove containers and volumes
docker-compose down -v

# Remove containers, volumes, and images
docker-compose down -v --rmi all

# Clean up unused Docker resources
docker system prune -a
```

##  **Service Details**

### **Backend Service**
- **Container**: `hoa_backend_api`
- **Port**: 3001
- **Technology**: Node.js + Express
- **Database**: SQLite (persistent volume)
- **File Uploads**: Persistent volume mounted

**Volumes:**
- `./backend/database`  `/usr/src/app/backend/database`
- `./backend/uploads`  `/usr/src/app/backend/uploads`

### **Frontend Service**
- **Container**: `hoa_frontend_web`
- **Port**: 3000
- **Technology**: React + Vite + Nginx
- **Build**: Multi-stage Docker build
- **Serving**: Nginx with optimized configuration

**Features:**
- Production-optimized build
- Gzip compression enabled
- Client-side routing support
- Security headers configured
- Static asset caching

### **Test Runner Service**
- **Container**: `hoa_test_runner`
- **Purpose**: Automated testing
- **Command**: `npm run test:debugging`
- **Dependencies**: Requires backend service

##  **Configuration Options**

### **Environment Variables**

| Variable | Default | Description |
|----------|---------|-------------|
| `APP_PORT` | 3001 | Backend API port |
| `FRONTEND_PORT` | 3000 | Frontend web port |
| `NODE_ENV` | development | Node.js environment |
| `DB_PATH` | `/usr/src/app/backend/database/hoa.db` | Database file path |
| `JWT_SECRET` | (required) | JWT signing secret |
| `MAX_FILE_SIZE_MB` | 10 | Maximum upload file size |

### **Port Customization**
```bash
# Use different ports
FRONTEND_PORT=8080 APP_PORT=8001 docker-compose up
```

### **Development Mode**
For development with live reloading, uncomment the volume mounts in `docker-compose.yml`:
```yaml
volumes:
  - ./backend:/usr/src/app/backend
  - /usr/src/app/backend/node_modules
```

##  **Troubleshooting**

### **Common Issues**

#### **Port Already in Use**
```bash
# Check what's using the port
lsof -i :3000
lsof -i :3001

# Kill the process or change ports in .env
FRONTEND_PORT=8080 APP_PORT=8001 docker-compose up
```

#### **Permission Issues**
```bash
# Fix file permissions
sudo chown -R $USER:$USER ./backend/database
sudo chown -R $USER:$USER ./backend/uploads
```

#### **Build Failures**
```bash
# Clean build cache
docker-compose build --no-cache

# Remove old images
docker image prune -a
```

#### **Database Issues**
```bash
# Reset database (WARNING: This deletes all data)
rm -rf ./backend/database/hoa.db
docker-compose up --build
```

### **Logs and Debugging**
```bash
# View all logs
docker-compose logs -f

# View specific service logs
docker-compose logs -f backend
docker-compose logs -f frontend

# Check container status
docker-compose ps

# Inspect container
docker-compose exec backend env
```

##  **Security Considerations**

### **Production Deployment**
- Change default JWT secret
- Use environment-specific `.env` files
- Enable HTTPS with reverse proxy
- Implement proper backup strategy
- Monitor container resource usage

### **Network Security**
- Services communicate through internal Docker network
- Only necessary ports are exposed to host
- Nginx serves frontend with security headers

##  **Monitoring**

### **Health Checks**
```bash
# Check if services are responding
curl http://localhost:3001/api
curl http://localhost:3000/health
```

### **Resource Usage**
```bash
# Monitor container resources
docker stats

# View container details
docker-compose top
```

##  **Updates and Maintenance**

### **Updating the Application**
```bash
# Pull latest changes
git pull origin main

# Rebuild and restart
docker-compose down
docker-compose up --build
```

### **Database Backups**
```bash
# Backup database
cp ./backend/database/hoa.db ./backend/database/hoa.db.backup

# Restore database
cp ./backend/database/hoa.db.backup ./backend/database/hoa.db
docker-compose restart backend
```

### **File Upload Backups**
```bash
# Backup uploads
tar -czf uploads-backup.tar.gz ./backend/uploads/

# Restore uploads
tar -xzf uploads-backup.tar.gz
```

##  **Support**

For issues with the Docker setup:
1. Check the logs: `docker-compose logs`
2. Verify environment variables in `.env`
3. Ensure ports are available
4. Try rebuilding: `docker-compose up --build`
5. Check Docker and Docker Compose versions

---

*This Docker setup provides a production-ready containerized environment for the HOA Management System with optimized builds, persistent data storage, and comprehensive configuration options.*

================
File: docker-compose.yml
================
version: '3.8'

services:
  backend:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: hoa_backend_api
    user: "${UID:-1000}:${GID:-1000}"
    ports:
      - "${APP_PORT:-3001}:${PORT:-3001}"
    volumes:
      - ./backend/database:/usr/src/app/backend/database
      - ./backend/uploads:/usr/src/app/backend/uploads
    environment:
      - NODE_ENV=${NODE_ENV:-development}
      - DB_PATH=/usr/src/app/backend/database/test.db
    env_file:
      - .env
    restart: unless-stopped
    networks:
      - hoa-app-network

  frontend:
    build:
      context: ./frontend # Build context is the frontend directory
      dockerfile: Dockerfile # Frontend-specific Dockerfile
    container_name: hoa_frontend_web
    ports:
      # Map host port 3000 to container's port 80 (nginx)
      - "${FRONTEND_PORT:-3000}:80"
    environment:
      # API URL for the frontend to connect to backend
      - VITE_API_BASE_URL=http://localhost:${APP_PORT:-3001}/api
    depends_on:
      - backend # Ensure backend starts before frontend
    restart: unless-stopped
    networks:
      - hoa-app-network

  test-runner:
    build:
      context: .
      dockerfile: Dockerfile.test
    container_name: hoa_test_runner
    user: "${UID:-1000}:${GID:-1000}"
    depends_on:
      - backend
    volumes:
      - ./backend:/usr/src/app/backend
      - /usr/src/app/backend/node_modules
    environment:
      - NODE_ENV=test
      - DB_PATH=/usr/src/app/backend/database/test.db
    env_file:
      - .env.test
    command: npm run test:debugging
    networks:
      - hoa-app-network

networks:
  hoa-app-network:
    driver: bridge

# Optional: Define named volumes if you prefer them over host mounts
# volumes:
#   hoa_db_data:
#   hoa_uploads_data:

================
File: Dockerfile
================
# Stage 1: Use an official Node.js LTS Alpine image for a smaller footprint
FROM node:18-alpine AS base

# Set the working directory for backend code within the container
# All subsequent commands will be run from this directory
WORKDIR /usr/src/app/backend

# Copy only package.json and package-lock.json from the backend directory first
# This leverages Docker's layer caching. If these files don't change,
# Docker won't re-run 'npm ci' in subsequent builds.
COPY ./backend/package*.json ./

# Install production dependencies for the backend
# 'npm ci' is generally recommended for CI/production for consistency with package-lock.json
# '--omit=dev' ensures devDependencies are not installed in the final image
RUN npm ci

# Copy the rest of the backend application code into the WORKDIR
COPY ./backend/ ./

# Ensure necessary directories exist within the container's WORKDIR
# These paths are relative to /usr/src/app/backend
# The application will write to these; Docker volumes will map them to the host.
# chown might be needed if you run the container as a non-root user.
# For the default node user (often root in -alpine images unless specified),
# mkdir is usually sufficient. If using USER node, chown is important.
RUN mkdir -p database uploads/documents
# If you switch to USER node later:
# RUN chown -R node:node database uploads

# (Optional but recommended) Define a non-root user to run the application
# USER node

# Expose the port the application will run on *inside* the container
# This should match the PORT environment variable your app uses
ARG PORT=3001
ENV PORT=${PORT}
EXPOSE ${PORT}

# Command to run the application
# This will execute 'npm start' from /usr/src/app/backend
CMD [ "npm", "start" ]

================
File: Dockerfile.test
================
# Use the same base image
FROM node:18-alpine

# Set the working directory
WORKDIR /usr/src/app/backend

# Copy package files
COPY ./backend/package*.json ./

# Install ALL dependencies, including devDependencies
# This is the key difference. We need jest, sequelize-cli, etc.
RUN npm install

# Copy the rest of the application code
COPY ./backend/ ./

# Command to keep the container running for exec commands, if needed.
# We will override this with the test command in docker-compose.
CMD ["tail", "-f", "/dev/null"]

================
File: phases.md
================
### **Project Kick-off: UI for HOA Management Platform**

**Objective:** To create a modern, mobile-friendly, and beautiful yet functional user interface for the existing HOA Management Platform backend. The UI will be developed under the `frontend/` directory.

**Guiding Principles:**
*   **Component-Based Architecture:** Promote reusability and maintainability.
*   **Mobile-First Design:** Ensure a seamless experience on all devices.
*   **Clear State Management:** Maintain a predictable and debuggable application state.
*   **Optimistic UI (where appropriate):** Provide a fast, responsive feel for the user.
*   **Security:** Properly handle JWTs, user roles, and secure API communication.

**Recommended Tech Stack:**
*   **Framework:** **React** (with TypeScript for type safety)
*   **Build Tool:** **Vite** (for fast development and optimized builds)
*   **Styling:** **Tailwind CSS** for utility-first styling, combined with a headless component library like **Headless UI** or a styled one like **Shadcn/UI** for accessibility and functionality.
*   **Routing:** **React Router**
*   **API Communication:** **Axios** (for its ease of use with interceptors for auth headers)
*   **State Management:** **Zustand** (for its simplicity and minimal boilerplate)
*   **Forms:** **React Hook Form** (for performance and validation)

---

### **Phase 1: Project Bootstrap & Core Authentication**

**Goal:** Establish the frontend project structure, set up the development environment, and implement the complete user authentication and registration flow. By the end of this phase, users can register, log in, log out, and reset their passwords.

#### **1. Project Initialization & Tooling Setup**

1.  **Create Project:** Inside the root directory, create the frontend project.
    ```bash
    # Ensure you are in the project root directory
    npm create vite@latest frontend -- --template react-ts
    cd frontend
    ```
2.  **Install Dependencies:**
    ```bash
    npm install
    npm install axios react-router-dom zustand tailwindcss postcss autoprefixer react-hook-form @hookform/resolvers joi
    npm install -D @types/react-router-dom
    ```
3.  **Configure Tailwind CSS:**
    ```bash
    npx tailwindcss init -p
    # Follow the official Tailwind guide to configure template paths in tailwind.config.js
    ```

#### **2. Docker Integration**

Update the root `docker-compose.yml` to include the new frontend service for a unified development environment.

**Updated `docker-compose.yml`:**

```yaml
version: '3.8'

services:
  backend:
    build:
      context: ./backend # Point build context to backend subdirectory
      dockerfile: Dockerfile
    container_name: hoa_backend_api
    user: "${UID:-1000}:${GID:-1000}"
    ports:
      - "${APP_PORT:-3001}:${PORT:-3001}"
    volumes:
      - ./backend/database:/usr/src/app/database
      - ./backend/uploads:/usr/src/app/uploads
    env_file:
      - ./backend/.env
    restart: unless-stopped
    networks:
      - hoa-app-network

  frontend:
    build:
      context: ./frontend # Point build context to frontend subdirectory
      dockerfile: Dockerfile
    container_name: hoa_frontend_ui
    user: "${UID:-1000}:${GID:-1000}"
    ports:
      - "5173:5173" # Default Vite port
    volumes:
      - ./frontend:/app
      - /app/node_modules # Isolate node_modules inside the container
    depends_on:
      - backend
    networks:
      - hoa-app-network
    environment:
      - VITE_API_BASE_URL=http://backend:3001/api # Use service name for inter-container communication

# test-runner service remains as is...

networks:
  hoa-app-network:
    driver: bridge
```

**Create `frontend/Dockerfile`:**

```dockerfile
# Stage 1: Build the application
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
# If you were building for production, you'd have a build step:
# RUN npm run build

# Stage 2: Serve the application for development
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app .
EXPOSE 5173
CMD ["npm", "run", "dev", "--", "--host"]
```

#### **3. Application Shell & Routing**

1.  **Create a main layout component:** `src/components/layout/MainLayout.tsx` with a header, a placeholder sidebar, and a main content area.
2.  **Set up routing:** In `src/App.tsx`, configure React Router with public routes (`/login`, `/register`, `/forgot-password`) and a placeholder for protected routes.
3.  **Create `ProtectedRoute` component:** This component will wrap protected routes. It checks for a valid auth token in the state and redirects to `/login` if it's missing.

#### **4. Authentication Flow Implementation**

**State Management (`src/store/authStore.ts`)**

Create a Zustand store to manage authentication state globally.

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface User {
  id: number;
  name: string;
  email: string;
  role: 'admin' | 'member';
  status: 'pending' | 'approved' | 'rejected';
}

interface AuthState {
  token: string | null;
  user: User | null;
  setAuth: (token: string, user: User) => void;
  logout: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      token: null,
      user: null,
      setAuth: (token, user) => set({ token, user }),
      logout: () => set({ token: null, user: null }),
    }),
    {
      name: 'auth-storage', // name of the item in the storage (must be unique)
    }
  )
);
```

**API Service (`src/services/api.ts` & `src/services/authService.ts`)**

*   Create an Axios instance with the base URL and an interceptor to add the auth token to headers.
*   Implement functions for each auth endpoint.

**Pages & API Calls:**

*   **Login Page (`src/pages/Login.tsx`)**
    *   **UI:** Form with email and password fields.
    *   **API Call:**
        *   **Endpoint:** `POST /api/auth/login`
        *   **Request Body:** `{ "email": "user@example.com", "password": "password123" }`
        *   **On Success (200):**
            *   **Response Data Structure:**
                ```json
                {
                  "message": "Login successful.",
                  "token": "eyJhbGciOiJI...",
                  "user": {
                    "id": 1,
                    "name": "John Doe",
                    "email": "john.doe@example.com",
                    "role": "member",
                    "status": "approved",
                    "created_at": "...",
                    "updated_at": "..."
                  }
                }
                ```
            *   **Action:** Call `useAuthStore.getState().setAuth(token, user)` and navigate to the dashboard.

*   **Registration Page (`src/pages/Register.tsx`)**
    *   **UI:** Form for name, email, and password.
    *   **API Call:**
        *   **Endpoint:** `POST /api/auth/register`
        *   **Request Body:** `{ "name": "Jane Doe", "email": "jane@example.com", "password": "Password123!" }`
        *   **On Success (201):**
            *   **Response Data Structure:**
                ```json
                {
                  "message": "Registration successful. Your account is pending approval.",
                  "user": { /* ... user object ... */ }
                }
                ```
            *   **Action:** Display the success message to the user, prompting them to wait for admin approval.

*   **Forgot & Reset Password Pages**
    *   **UI:** Forms for email submission and then token + new password submission.
    *   **API Calls:**
        *   `POST /api/auth/forgot-password` (Request Body: `{ "email": "..." }`)
        *   `POST /api/auth/reset-password` (Request Body: `{ "token": "...", "newPassword": "..." }`)

**Deliverables:**
*   A runnable `docker-compose up` environment for both backend and frontend.
*   Functional Login, Registration, and Forgot/Reset Password pages.
*   A protected dashboard route that is only accessible after login.
*   Global state management for authentication.

---

### **Phase 2: Member-Facing Core Features**

**Goal:** Build the essential features that an approved member will use. This includes the dashboard, viewing announcements, events, and documents, and managing their own profile.

#### **1. Main Dashboard (`src/pages/Dashboard.tsx`)**

*   **UI:** A central hub displaying a summary of key information.
    *   A "Welcome, [User Name]!" message.
    *   A component showing the 2-3 most recent **active announcements**.
    *   A component showing the 2-3 next **upcoming events**.
*   **API Calls:**
    *   `GET /api/announcements?limit=3&status=active&sortBy=created_at&sortOrder=DESC`
    *   `GET /api/events?limit=3&status=upcoming&sortBy=start_date&sortOrder=ASC`

#### **2. Announcements Module**

*   **UI:** A dedicated page (`/announcements`) listing all active announcements with pagination.
*   **API Call:**
    *   **Endpoint:** `GET /api/announcements` (with query params for pagination: `?page=1&limit=10`)
    *   **Response Data Structure:**
        ```json
        {
          "data": [
            {
              "id": 1,
              "title": "Pool Maintenance",
              "content": "<p>The community pool will be closed...</p>",
              "expires_at": "2025-07-01T23:59:59.000Z",
              "created_at": "...",
              "creator": { "id": 1, "name": "System Administrator" }
            }
          ],
          "pagination": { "totalItems": 20, "totalPages": 2, "currentPage": 1, "limit": 10 }
        }
        ```

#### **3. Events Calendar/List**

*   **UI:** A page (`/events`) that lists upcoming and past events, with a toggle or tabs. A simple list view is sufficient for this phase; a full calendar can be a future enhancement.
*   **API Call:**
    *   **Endpoint:** `GET /api/events?status=upcoming` (or `?status=past`)
    *   **Response Data Structure:**
        ```json
        {
          "data": [
            {
              "id": 1,
              "title": "Annual HOA Meeting",
              "description": "Discussing the budget for the next year.",
              "start_date": "2025-08-15T19:00:00.000Z",
              "end_date": "2025-08-15T21:00:00.000Z",
              "location": "Community Clubhouse",
              "created_by": { "id": 1, "name": "System Administrator" }
            }
          ],
          "pagination": { /* ... */ }
        }
        ```

#### **4. Document Library**

*   **UI:** A page (`/documents`) listing all approved documents (both public and member-only). Each item should have a title, description, uploader, and a download button.
*   **API Calls:**
    *   **Listing:** `GET /api/documents`
        *   **Response Data Structure:**
            ```json
            {
              "count": 5,
              "documents": [
                {
                  "id": 1,
                  "title": "Community Bylaws",
                  "description": "The official bylaws of the HOA.",
                  "original_file_name": "bylaws_2024.pdf",
                  "approved": true,
                  "is_public": true,
                  "uploaded_at": "...",
                  "uploader": { "id": 1, "name": "System Administrator" }
                }
              ]
            }
            ```
    *   **Downloading:** The download button will link to `GET /api/documents/:documentId/download`. This must be handled carefully. The link should be an `<a>` tag with the `download` attribute. The `href` will need to include the auth token if the API requires it for secure downloads. A better approach is a function that fetches the blob and triggers a download programmatically to attach the auth header.

#### **5. User Profile Management**

*   **UI:** A page (`/profile` or `/settings`) where users can view their details, update their name, and change their password.
*   **API Calls:**
    *   **Get Profile:** `GET /api/users/me`
    *   **Update Profile:** `PUT /api/users/me` (Request Body: `{ "name": "New Name" }`)
    *   **Change Password:** `PUT /api/users/me/password` (Request Body: `{ "currentPassword": "...", "newPassword": "..." }`)

**Deliverables:**
*   A functional dashboard for logged-in members.
*   Read-only modules for Announcements, Events, and Documents with pagination.
*   A fully functional user profile and password management page.

---

### **Phase 3: Community Discussion Forum**

**Goal:** Implement the interactive discussion board feature, allowing members to create threads and post replies.

#### **1. Discussion Threads List**

*   **UI:** A page (`/discussions`) that lists all parent discussion threads, showing the title, author, creation date, and reply count.
*   **API Call:**
    *   **Endpoint:** `GET /api/discussions`
    *   **Response Data Structure:**
        ```json
        {
          "totalItems": 15,
          "totalPages": 2,
          "currentPage": 1,
          "threads": [
            {
              "id": 1,
              "title": "Question about landscaping services",
              "content": "Does anyone know when the next lawn treatment is scheduled?",
              "created_at": "...",
              "author": { "id": 5, "name": "Jane Doe" },
              "reply_count": 3
            }
          ]
        }
        ```

#### **2. Thread View and Replies**

*   **UI:** A dynamic page (`/discussions/:threadId`) that shows the main thread's content at the top, followed by a chronological list of all replies. Include a form to add a new reply.
*   **API Calls:**
    *   **View Thread:** `GET /api/discussions/:threadId`
        *   **Response Data Structure:**
            ```json
            {
              "mainThread": { /* ... thread object ... */ },
              "replies": [
                {
                  "id": 10,
                  "content": "I believe it's next Tuesday.",
                  "created_at": "...",
                  "author": { "id": 8, "name": "Mark Smith" }
                }
              ]
            }
            ```
    *   **Post Reply:** `POST /api/discussions/:threadId/replies`
        *   **Request Body:** `{ "content": "This is my reply." }`
        *   **Action:** On success, refetch the thread data or optimistically add the new reply to the UI.

#### **3. Create New Thread**

*   **UI:** A form/modal for creating a new discussion thread with a title and content.
*   **API Call:**
    *   **Endpoint:** `POST /api/discussions`
    *   **Request Body:** `{ "title": "New Thread Title", "content": "..." }`
    *   **Action:** On success, navigate the user to the newly created thread's page.

**Deliverables:**
*   A complete, interactive discussion forum.
*   Members can create, view, and reply to threads.

---

### **Phase 4: Comprehensive Admin Panel**

**Goal:** Build a secure, dedicated section of the UI for administrators to manage all aspects of the platform. This section should be under a route like `/admin`.

#### **1. Admin Layout & Navigation**

*   Create a distinct layout for the admin panel, possibly with a different sidebar containing links to all admin-specific pages.
*   Use the `ProtectedRoute` component, but with an additional check for `user.role === 'admin'`.

#### **2. User Management Dashboard**

*   **UI:** A table listing all non-system users with their name, email, role, and status. Provide controls to edit status/role, change password, or delete.
*   **API Calls:**
    *   `GET /api/admin/users`: List all users.
    *   `PUT /api/admin/users/:userId/status`: (Body: `{ "status": "approved" }`)
    *   `PUT /api/admin/users/:userId/role`: (Body: `{ "role": "admin" }`)
    *   `DELETE /api/admin/users/:userId`

#### **3. Content Management (Announcements, Events, Documents)**

*   For each content type, create a management page with a table listing all items (not just active/approved).
*   Implement forms (modals are a good choice) for **creating** and **editing** items.
*   **Documents:**
    *   The creation form must handle `multipart/form-data` for file uploads.
    *   Add controls to **approve** documents.
    *   `POST /api/admin/documents`: (form-data with `documentFile`, `title`, etc.)
    *   `PUT /api/admin/documents/:id/approve`
*   **Announcements & Events:**
    *   `POST /api/announcements` | `PUT /api/announcements/:id` | `DELETE /api/announcements/:id`
    *   `POST /api/events` | `PUT /api/events/:id` | `DELETE /api/events/:id`

#### **4. Site Configuration**

*   **UI:** A simple form page that lists all configuration key-value pairs and allows admins to update the values.
*   **API Calls:**
    *   `GET /api/admin/config`: To populate the form.
    *   `PUT /api/admin/config/:key`: (Body: `{ "value": "New HOA Name" }`) - Call this for each changed value.

#### **5. Audit Log Viewer**

*   **UI:** A paginated table displaying the audit logs. Show the admin's name, the action, details, and timestamp.
*   **API Call:** `GET /api/admin/audit-logs`

**Deliverables:**
*   A fully functional and secure admin panel.
*   Admins can perform all CRUD and management operations as defined by the backend API.

---

### **Phase 5: Finalization, Polish, and Pre-Deployment**

**Goal:** Refine the application, ensure high quality across the board, and prepare for production deployment.

#### **1. Comprehensive UI/UX Polish**

*   Review all pages for consistent design, spacing, and typography.
*   Add loading states (spinners, skeletons) for all data-fetching operations.
*   Implement user-friendly error messages for API failures (e.g., "Invalid password" vs. a generic "Error").
*   Add subtle animations and transitions for a smoother feel.

#### **2. Final Responsive & Cross-Browser Testing**

*   Rigorously test the entire application on various screen sizes, from small mobile phones to large desktops.
*   Test on major browsers (Chrome, Firefox, Safari, Edge).

#### **3. Accessibility (a11y) Audit**

*   Ensure all interactive elements are keyboard-navigable.
*   Use semantic HTML and add appropriate ARIA attributes.
*   Check color contrast ratios.

#### **4. Performance Optimization**

*   Implement code-splitting (route-based) to reduce initial bundle size.
*   Optimize images and other static assets.
*   Analyze and optimize any slow-rendering components.

#### **5. Final Review and Documentation**

*   Update `README.md` with instructions on how to run the frontend.
*   Conduct a final code review.

**Deliverables:**
*   A production-ready, polished, and performant frontend application.
*   A high-quality user experience on all target platforms.

================
File: README.md
================
# HOA Community Hub

Welcome to the HOA Community Hub, a modern, full-stack web application designed to be the central digital point of contact for a Homeowners' Association and its residents. This platform streamlines communication, simplifies document access, manages community events, and provides essential administrative tools.

## Table of Contents

1.  [Vision & Purpose](#vision--purpose)
2.  [Core Features](#core-features)
3.  [Technology Stack](#technology-stack)
4.  [Project Structure](#project-structure)
5.  [Getting Started](#getting-started)
    - [Prerequisites](#prerequisites)
    - [Backend Setup](#backend-setup)
    - [Frontend Setup](#frontend-setup)
6.  [Running the Application](#running-the-application)
7.  [Running Tests](#running-tests)
8.  [API Documentation](#api-documentation)

---

## Vision & Purpose

The goal of the HOA Community Hub is to replace fragmented communication channels like email chains and paper notices with a single, secure, and user-friendly platform. It empowers community administrators with the tools they need to manage the HOA efficiently while providing residents with easy access to information and a forum for discussion.

**User Personas:**
*   **Administrator:** Manages users, content, and site configuration.
*   **Resident (Member):** Accesses information, participates in discussions.
*   **Guest:** Views public-facing information about the HOA.

---

## Core Features

| Feature                | Administrator (`admin`)                                      | Resident (`member`)                                  | Guest (Unauthenticated)     |
| ---------------------- | ------------------------------------------------------------ | ---------------------------------------------------- | --------------------------- |
| **Authentication**     |  Login/Logout                                              |  Login/Logout, Register, Password Reset            |                           |
| **User Management**    |  View, Approve/Reject, Change Role, Delete Users           |  Manage Own Profile                                |                           |
| **Announcements**      |  Create, Edit, Delete                                      |  View                                              |                           |
| **Events**             |  Create, Edit, Delete                                      |  View                                              |                           |
| **Documents**          |  Upload, Manage, Set Visibility                            |  View & Download Approved Docs                     |  View & Download Public Docs |
| **Discussions**        |  Delete Threads/Replies                                    |  Create/View Threads, Post Replies                 |                           |
| **Site Configuration** |  Edit Site Name/Description                                |                                                    |                           |
| **Audit Logs**         |  View all administrative actions                           |                                                    |                           |

---

## Technology Stack

*   **Backend:**
    *   **Framework:** Node.js with Express.js
    *   **Database:** SQLite3 (for simplicity and portability)
    *   **ORM:** Sequelize
    *   **Authentication:** JSON Web Tokens (JWT)
    *   **Testing:** Jest & Supertest
*   **Frontend:**
    *   **Framework:** React.js with TypeScript
    *   **UI Library:** Material-UI (MUI)
    *   **Routing:** React Router
    *   **State Management:** React Context API
    *   **Form Handling:** Formik & Yup
    *   **API Client:** Axios

---

## Project Structure

The project is a monorepo containing distinct `backend` and `frontend` applications.

## Getting Started

### Prerequisites

*   Node.js (v18.x or later recommended)
*   npm (v10.x or later recommended)

### Backend Setup

1.  **Navigate to the backend directory:**
    ```bash
    cd backend
    ```

2.  **Install dependencies:**
    ```bash
    npm install
    ```

3.  **Set up environment variables:**
    Create a `.env` file in the `backend/` directory by copying the example.
    ```bash
    # You can manually create a .env file and add the following:
    # A strong, secret key for signing JWTs
    JWT_SECRET=your_super_secret_key_here_123!
    JWT_EXPIRES_IN=8h

    # Default admin credentials for the initial database seed
    ADMIN_EMAIL=admin@example.com
    ADMIN_PASSWORD=AdminPassword123!
    ```

4.  **Run database migrations and seeders:**
    This command will create the database schema and populate it with an initial admin user and default site configuration.
    ```bash
    npm run db:migrate
    npm run db:seed
    ```

### Frontend Setup

*(These steps are for when Phase 1 of the frontend is complete.)*

1.  **Navigate to the frontend directory:**
    ```bash
    # from the project root
    cd frontend
    ```

2.  **Install dependencies:**
    ```bash
    npm install
    ```

---

## Running the Application

You will need two separate terminal windows to run the backend and frontend servers concurrently.

1.  **Start the Backend Server:**
    ```bash
    # In a terminal, from the backend/ directory
    npm start
    ```
    The API will be running on `http://localhost:3001`.

2.  **Start the Frontend Development Server:**
    ```bash
    # In a second terminal, from the frontend/ directory
    npm start
    ```
    The React application will open in your browser, usually at `http://localhost:3000`.

---

## Running Tests

The backend includes a full suite of integration tests to ensure API reliability.

*   **To run all backend tests:**
    ```bash
    # From the backend/ directory
    npm test:integration
    ```
*   **To run a specific test file (e.g., for debugging):**
    ```bash
    # From the backend/ directory
    npm run test:debugging -- test/debugging/users.test.js
    ```

================
File: USER_GUIDE.md
================
# HOA Management System - User Guide

Welcome to the HOA Management System! This guide will help you navigate and use all the features available in the application.

##  **System Access**

**Application URL**: http://localhost:5173/login

##  **User Roles**

The system supports two main user roles:

### **Member**
- View announcements and events
- Access approved documents
- Participate in community discussions
- Manage personal profile

### **Admin**
- All member capabilities
- User management (approve/reject registrations)
- Content management (announcements, events, documents)
- System configuration
- Audit trail access

---

##  **Getting Started**

### **1. Registration**
1. Navigate to http://localhost:5173/login
2. Click **"Don't have an account? Register"**
3. Fill in your details:
   - **Name**: Your full name
   - **Email**: Valid email address
   - **Password**: Must be at least 8 characters with uppercase, lowercase, number, and special character
4. Click **"Register"**
5. **Wait for admin approval** - Your account will be in "pending" status until an administrator approves it

### **2. Login**
1. Go to http://localhost:5173/login
2. Enter your **email** and **password**
3. Click **"Login"**
4. You'll be redirected to the dashboard based on your role

### **3. Password Reset**
1. On the login page, click **"Forgot Password?"**
2. Enter your email address
3. Follow the instructions sent to your email
4. Enter the reset token and new password

---

##  **Member Features**

### **Dashboard**
- **Recent Announcements**: View the latest community announcements
- **Upcoming Events**: See scheduled community events
- **Quick Actions**: Access to main features

### ** Announcements**
- View all active community announcements
- Filter and search announcements
- See announcement details and expiration dates

### ** Events**
- Browse upcoming and past community events
- View event details including:
  - Date and time
  - Location
  - Description
  - Event organizer

### ** Documents**
- Access approved community documents
- Download documents (PDF, Word, Excel, images)
- Search and filter documents
- View document descriptions and upload dates

### ** Discussions**
- **View Discussions**: Browse community discussion threads
- **Create New Thread**: Start a new discussion topic
- **Reply to Threads**: Participate in existing conversations
- **Search Discussions**: Find specific topics or conversations

### ** Profile Management**
- **Update Name**: Change your display name
- **Change Password**: Update your account password
- **View Account Info**: See your registration date and status

---

##  **Admin Features**

Admins have access to all member features plus additional administrative capabilities:

### ** User Management**
- **View All Users**: See complete user list with status and roles
- **Approve/Reject Registrations**: Manage pending user accounts
- **Update User Roles**: Promote members to admin or demote admins
- **Update User Status**: Change user status (approved, pending, rejected)
- **Delete Users**: Remove user accounts and associated data
- **Reset User Passwords**: Change passwords for any user

**User Status Options:**
- **Pending**: New registrations awaiting approval
- **Approved**: Active users who can log in
- **Rejected**: Denied access to the system

### ** Announcement Management**
- **Create Announcements**: Post new community announcements
- **Edit Announcements**: Modify existing announcements
- **Delete Announcements**: Remove outdated announcements
- **Set Expiration**: Configure when announcements expire
- **Rich Text Content**: Use HTML formatting for announcements

### ** Event Management**
- **Create Events**: Schedule new community events
- **Edit Events**: Update event details, dates, and locations
- **Delete Events**: Remove cancelled or past events
- **Event Details**: Set start/end dates, location, and descriptions

### ** Document Management**
- **Upload Documents**: Add new documents to the system
- **Approve Documents**: Review and approve uploaded documents
- **Delete Documents**: Remove documents and associated files
- **Set Visibility**: Configure documents as public or member-only
- **Document Types**: Support for PDF, Word, Excel, and image files

**Document Upload Process:**
1. Click **"Upload Document"**
2. Fill in document details:
   - **Title**: Document name
   - **Description**: Optional description
   - **Visibility**: Public (visible to all) or Private (members only)
3. Select file (max 10MB)
4. Click **"Upload"**

### ** System Configuration**
- **Site Settings**: Configure HOA name, description, and other settings
- **System Parameters**: Manage application-wide configurations
- **Update Settings**: Modify configuration values

### ** Audit Trail**
- **View Admin Actions**: See all administrative activities
- **Action Details**: Review what actions were performed and when
- **Admin Accountability**: Track which admin performed each action
- **Search Logs**: Find specific administrative activities

---

##  **Common Tasks**

### **For Members:**

#### **Joining a Discussion**
1. Go to **"Discussions"** in the navigation
2. Click on a thread title to view the conversation
3. Scroll to the bottom and click **"Reply"**
4. Type your response and click **"Post Reply"**

#### **Starting a New Discussion**
1. Go to **"Discussions"**
2. Click **"New Discussion"**
3. Enter a **title** and your **message**
4. Click **"Create Discussion"**

#### **Downloading a Document**
1. Go to **"Documents"**
2. Find the document you want
3. Click the **download icon** next to the document
4. The file will download to your computer

### **For Admins:**

#### **Approving New Users**
1. Go to **"Admin"**  **"User Management"**
2. Look for users with **"Pending"** status
3. Click the **"Update Status"** button for the user
4. Select **"Approved"** and click **"Update Status"**

#### **Creating an Announcement**
1. Go to **"Admin"**  **"Announcements"**
2. Click **"Create Announcement"**
3. Fill in the details:
   - **Title**: Announcement headline
   - **Content**: Message content (HTML supported)
   - **Expires At**: Optional expiration date
4. Click **"Create"**

#### **Uploading a Document**
1. Go to **"Admin"**  **"Documents"**
2. Click **"Upload Document"**
3. Fill in the form:
   - **Title**: Document name
   - **Description**: Optional description
   - **Public**: Check if visible to non-members
   - **File**: Select the file to upload
4. Click **"Upload"**

---

##  **Security & Privacy**

### **Password Requirements**
- Minimum 8 characters
- Must include:
  - At least one uppercase letter
  - At least one lowercase letter
  - At least one number
  - At least one special character

### **Data Privacy**
- Personal information is protected
- Only admins can see user management details
- Documents can be set as public or member-only
- Audit logs track all administrative actions

### **Account Security**
- Sessions expire automatically
- Password reset requires email verification
- Failed login attempts are monitored

---

##  **Browser Compatibility**

The system works best with modern browsers:
- **Chrome** (recommended)
- **Firefox**
- **Safari**
- **Edge**

---

##  **Troubleshooting**

### **Common Issues:**

#### **Can't Log In**
- Check your email and password
- Ensure your account is approved (contact an admin)
- Try password reset if needed

#### **File Upload Fails**
- Check file size (max 10MB)
- Ensure file type is supported:
  - PDF files
  - Word documents (.doc, .docx)
  - Excel files
  - Images (JPEG, PNG, GIF)

#### **Page Not Loading**
- Refresh the browser
- Check your internet connection
- Clear browser cache if needed

#### **Permission Denied**
- Ensure you're logged in
- Check if you have the required role (admin features require admin role)
- Contact an admin if you need role changes

### **Getting Help**
- Contact your HOA administrator
- Check with other community members in discussions
- Refer to this user guide for feature explanations

---

##  **Support Information**

For technical issues or questions about using the system:

1. **Check this user guide** for common tasks and troubleshooting
2. **Contact your HOA administrator** for account-related issues
3. **Use the community discussions** to ask questions and get help from other members

---

##  **System Updates**

The system is regularly updated with new features and improvements. Key areas of ongoing development:

- Enhanced mobile responsiveness
- Additional document types support
- Advanced search capabilities
- Email notifications
- Calendar integration

---

*This user guide covers the current features of the HOA Management System. For the most up-to-date information, please refer to system announcements or contact your administrator.*
