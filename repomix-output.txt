This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-01T15:07:37.172Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
backend/
  config/
    config.json
  migrations/
    20250531200615-add-original-file-name-to-documents.js
    20250531213155-create-users-table.js
    20250531214039-create-users-table.js
    20250531214112-create-config-table.js
    20250531214127-create-verification-tokens-table.js
    20250531214148-create-events-table.js
    20250531214209-create-documents-table.js
    20250531214231-create-discussions-table.js
    20250531214251-create-announcements-table.js
    20250531214312-create-audit-logs-table.js
    20250531221950-add-expires_at-to-announcements.js
  models/
    announcement.model.js
    auditLog.model.js
    config.model.js
    discussion.model.js
    document.model.js
    event.model.js
    index.js
    user.model.js
    verificationToken.model.js
  seeders/
    20250531214351-initial-admin-user.js
    20250531214406-initial-site-config.js
  src/
    controllers/
      admin.user.controller.js
      announcement.controller.js
      audit.controller.js
      auth.controller.js
      config.controller.js
      discussion.controller.js
      document.controller.js
      event.controller.js
      user.controller.js
    middlewares/
      auth.middleware.js
      upload.middleware.js
      validate.middleware.js
    routes/
      admin.user.routes.js
      announcement.routes.js
      audit.routes.js
      auth.routes.js
      config.routes.js
      discussion.routes.js
      document.routes.js
      event.routes.js
      user.routes.js
    services/
      announcement.service.js
      audit.service.js
      auth.service.js
      config.service.js
      discussion.service.js
      document.service.js
      event.service.js
      user.service.js
    utils/
      ApiError.js
      catchAsync.js
    validators/
      admin.user.validator.js
      announcement.validator.js
      audit.validator.js
      auth.validator.js
      config.validator.js
      discussion.validator.js
      document.validator.js
      event.validator.js
      user.validator.js
    app.js
  package.json
.dockerignore
.env.example
.gitignore
back-end-plan.md
docker-compose.yml
docker-plan.md
Dockerfile
front-end-plan.md
integration-plan.md

================================================================
Files
================================================================

================
File: backend/config/config.json
================
{
  "development": {
    "dialect": "sqlite",
    "storage": "database/hoa.db"
  },
  "test": {
    "dialect": "sqlite",
    "storage": "database/hoa.db"
  },
  "production": {
    "dialect": "sqlite",
    "storage": "database/hoa.db"
  }
}

================
File: backend/migrations/20250531200615-add-original-file-name-to-documents.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    await queryInterface.addColumn('Documents', 'original_file_name', {
      type: Sequelize.STRING,
      allowNull: false,
    });
  },

  async down (queryInterface, Sequelize) {
    await queryInterface.removeColumn('Documents', 'original_file_name');
  }
};

================
File: backend/migrations/20250531213155-create-users-table.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    /**
     * Add altering commands here.
     *
     * Example:
     * await queryInterface.createTable('users', { id: Sequelize.INTEGER });
     */
  },

  async down (queryInterface, Sequelize) {
    /**
     * Add reverting commands here.
     *
     * Example:
     * await queryInterface.dropTable('users');
     */
  }
};

================
File: backend/migrations/20250531214039-create-users-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('users', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false
      },
      email: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true
      },
      password: {
        type: Sequelize.STRING,
        allowNull: false
      },
      role: {
        type: Sequelize.STRING,
        allowNull: false,
        defaultValue: 'member'
      },
      status: {
        type: Sequelize.STRING,
        allowNull: false,
        defaultValue: 'pending'
      },
      email_verified: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      is_system_user: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('users');
  }
};

================
File: backend/migrations/20250531214112-create-config-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('config', {
      key: {
        type: Sequelize.STRING,
        primaryKey: true,
        allowNull: false
      },
      value: {
        type: Sequelize.TEXT
      }
      // No timestamps for config table
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('config');
  }
};

================
File: backend/migrations/20250531214127-create-verification-tokens-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('verification_tokens', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      user_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'users', // Name of the target table
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },
      token: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true
      },
      type: {
        type: Sequelize.STRING, // e.g., 'email_verification', 'password_reset'
        allowNull: false
      },
      expires_at: {
        type: Sequelize.DATE,
        allowNull: false
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
      // No updated_at for verification tokens
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('verification_tokens');
  }
};

================
File: backend/migrations/20250531214148-create-events-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('events', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: false
      },
      description: {
        type: Sequelize.TEXT
      },
      start_date: {
        type: Sequelize.DATE,
        allowNull: false
      },
      end_date: {
        type: Sequelize.DATE,
        allowNull: false
      },
      location: {
        type: Sequelize.STRING,
        allowNull: false
      },
      created_by: {
        type: Sequelize.INTEGER,
        allowNull: true,
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('events');
  }
};

================
File: backend/migrations/20250531214209-create-documents-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('documents', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: false
      },
      description: {
        type: Sequelize.TEXT
      },
      file_name: { // Stored unique name
        type: Sequelize.STRING,
        allowNull: false
      },
      file_path: { // Server path
        type: Sequelize.STRING,
        allowNull: false
      },
      uploaded_by: {
        type: Sequelize.INTEGER,
        allowNull: true,
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      approved: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      is_public: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      uploaded_at: { // mapped from createdAt
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('documents');
  }
};

================
File: backend/migrations/20250531214231-create-discussions-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('discussions', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: true // Nullable for replies
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: false
      },
      user_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'users', // Table name should be 'Users' if model name is User
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL' // Or 'CASCADE' if discussions should be deleted with user
      },
      parent_id: {
        type: Sequelize.INTEGER,
        allowNull: true, // Null for main threads
        references: {
          model: 'discussions', // Self-reference
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE' // If parent thread is deleted, replies are also deleted
      },
      document_id: {
        type: Sequelize.INTEGER,
        allowNull: true, // Null if not linked to a document
        references: {
          model: 'documents',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('discussions');
  }
};

================
File: backend/migrations/20250531214251-create-announcements-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('announcements', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: false
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: false
      },
      created_by: {
        type: Sequelize.INTEGER,
        allowNull: true,
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('announcements');
  }
};

================
File: backend/migrations/20250531214312-create-audit-logs-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('audit_logs', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      admin_id: {
        type: Sequelize.INTEGER,
        allowNull: true, // As admin user might be deleted
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      action: {
        type: Sequelize.STRING,
        allowNull: false
      },
      details: {
        type: Sequelize.TEXT // Can store JSON string or plain text
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
      // No updated_at for audit logs
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('audit_logs');
  }
};

================
File: backend/migrations/20250531221950-add-expires_at-to-announcements.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.addColumn('Announcements', 'expires_at', {
      type: Sequelize.DATE,
      allowNull: true,
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.removeColumn('Announcements', 'expires_at');
  }
};

================
File: backend/models/announcement.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Announcement extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Announcement.belongsTo(models.User, {
        foreignKey: 'created_by',
        as: 'creator',
        onDelete: 'SET NULL', // If user is deleted, announcement's creator is set to null
      });
    }
  }
  Announcement.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false
    },
    content: {
      type: DataTypes.TEXT,
      allowNull: false
    },
    created_by: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if creator user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    },
    expires_at: {
      type: DataTypes.DATE,
      allowNull: true
    }
  }, {
    sequelize,
    modelName: 'Announcement',
    tableName: 'announcements',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Announcement;
};

================
File: backend/models/auditLog.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class AuditLog extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      AuditLog.belongsTo(models.User, {
        foreignKey: 'admin_id',
        as: 'adminUser', // Alias for the admin user who performed the action
        onDelete: 'SET NULL', // If admin user is deleted, keep the log but set admin_id to null
      });
    }
  }
  AuditLog.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    admin_id: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if admin user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    },
    action: {
      type: DataTypes.STRING,
      allowNull: false
    },
    details: {
      type: DataTypes.TEXT // Can store JSON string or plain text
    }
  }, {
    sequelize,
    modelName: 'AuditLog',
    tableName: 'audit_logs',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: false // Audit logs are typically immutable after creation
  });
  return AuditLog;
};

================
File: backend/models/config.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Config extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
    }
  }
  Config.init({
    key: {
      type: DataTypes.STRING,
      primaryKey: true,
      allowNull: false
    },
    value: {
      type: DataTypes.TEXT
    }
  }, {
    sequelize,
    modelName: 'Config',
    tableName: 'config',
    timestamps: false // No createdAt/updatedAt for config table as per original schema
  });
  return Config;
};

================
File: backend/models/discussion.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Discussion extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Discussion.belongsTo(models.User, {
        foreignKey: 'user_id',
        as: 'author',
        onDelete: 'SET NULL', // If user is deleted, discussion's author is set to null
      });
      Discussion.belongsTo(models.Discussion, {
        foreignKey: 'parent_id',
        as: 'parentThread',
        onDelete: 'CASCADE', // If parent thread is deleted, replies are also deleted
      });
      Discussion.hasMany(models.Discussion, {
        foreignKey: 'parent_id',
        as: 'replies',
      });
      Discussion.belongsTo(models.Document, {
        foreignKey: 'document_id',
        as: 'relatedDocument',
        onDelete: 'SET NULL', // If document is deleted, link is removed
      });
    }
  }
  Discussion.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: true // Nullable for replies
    },
    content: {
      type: DataTypes.TEXT,
      allowNull: false
    },
    user_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'users',
        key: 'id'
      }
    },
    parent_id: {
      type: DataTypes.INTEGER,
      allowNull: true, // Null for main threads
      references: {
        model: 'discussions', // Self-reference
        key: 'id'
      }
    },
    document_id: {
      type: DataTypes.INTEGER,
      allowNull: true, // Null if not linked to a document
      references: {
        model: 'documents',
        key: 'id'
      }
    }
  }, {
    sequelize,
    modelName: 'Discussion',
    tableName: 'discussions',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Discussion;
};

================
File: backend/models/document.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Document extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Document.belongsTo(models.User, {
        foreignKey: 'uploaded_by',
        as: 'uploader',
        onDelete: 'SET NULL', // If user is deleted, document's uploader is set to null
      });
      // If discussions can be linked to documents
      Document.hasMany(models.Discussion, {
        foreignKey: 'document_id',
        as: 'relatedDiscussions'
      });
    }
  }
  Document.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false
    },
    description: {
      type: DataTypes.TEXT
    },
    file_name: { // Stored unique name
      type: DataTypes.STRING,
      allowNull: false
    },
    file_path: { // Server path
      type: DataTypes.STRING,
      allowNull: false
    },
    original_file_name: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    uploaded_by: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if uploader user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    },
    approved: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    is_public: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    }
  }, {
    sequelize,
    modelName: 'Document',
    tableName: 'documents',
    timestamps: true,
    createdAt: 'uploaded_at', // Map createdAt to uploaded_at
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Document;
};

================
File: backend/models/event.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Event extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Event.belongsTo(models.User, {
        foreignKey: 'created_by',
        as: 'creator',
        onDelete: 'SET NULL', // If user is deleted, event's creator is set to null
      });
    }
  }
  Event.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false
    },
    description: {
      type: DataTypes.TEXT
    },
    start_date: {
      type: DataTypes.DATE,
      allowNull: false
    },
    end_date: {
      type: DataTypes.DATE,
      allowNull: false
    },
    location: {
      type: DataTypes.STRING,
      allowNull: false
    },
    created_by: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if creator user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    }
  }, {
    sequelize,
    modelName: 'Event',
    tableName: 'events',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Event;
};

================
File: backend/models/index.js
================
'use strict';

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../config/config.json')[env];
const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(config.database, config.username, config.password, config);
}

fs
  .readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 &&
      file !== basename &&
      file.slice(-3) === '.js' &&
      file.indexOf('.test.js') === -1
    );
  })
  .forEach(file => {
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;

================
File: backend/models/user.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class User extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      User.hasMany(models.Event, { foreignKey: 'created_by', as: 'events' });
      User.hasMany(models.Document, { foreignKey: 'uploaded_by', as: 'documents' });
      User.hasMany(models.Discussion, { foreignKey: 'created_by', as: 'discussions' });
      User.hasMany(models.Announcement, { foreignKey: 'created_by', as: 'announcements' });
      User.hasMany(models.AuditLog, { foreignKey: 'admin_id', as: 'auditLogs' });
      User.hasMany(models.VerificationToken, { foreignKey: 'user_id', as: 'verificationTokens' });
    }
  }
  User.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false
    },
    role: {
      type: DataTypes.STRING,
      allowNull: false,
      defaultValue: 'member'
    },
    status: {
      type: DataTypes.STRING,
      allowNull: false,
      defaultValue: 'pending'
    },
    email_verified: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    is_system_user: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    }
  }, {
    sequelize,
    modelName: 'User',
    tableName: 'users', // Explicitly define table name
    timestamps: true, // Enables createdAt and updatedAt
    createdAt: 'created_at', // Map createdAt to created_at
    updatedAt: 'updated_at' // Map updatedAt to updated_at (if needed, or set to false)
  });
  return User;
};

================
File: backend/models/verificationToken.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class VerificationToken extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      VerificationToken.belongsTo(models.User, {
        foreignKey: 'user_id',
        as: 'user',
        onDelete: 'CASCADE', // If a user is deleted, their tokens are also deleted
      });
    }
  }
  VerificationToken.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    user_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'users', // Name of the target table
        key: 'id'
      }
    },
    token: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    type: {
      type: DataTypes.STRING, // e.g., 'email_verification', 'password_reset'
      allowNull: false
    },
    expires_at: {
      type: DataTypes.DATE,
      allowNull: false
    }
  }, {
    sequelize,
    modelName: 'VerificationToken',
    tableName: 'verification_tokens',
    timestamps: true, // Enables createdAt and updatedAt
    createdAt: 'created_at', // Map createdAt to created_at
    updatedAt: false // No updatedAt for verification tokens
  });
  return VerificationToken;
};

================
File: backend/seeders/20250531214351-initial-admin-user.js
================
'use strict';
const bcrypt = require('bcrypt');

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    const adminEmail = process.env.ADMIN_EMAIL || 'admin@example.com';
    const adminPassword = process.env.ADMIN_PASSWORD || 'password123'; // Fallback for local dev if not set

    if (!process.env.ADMIN_EMAIL || !process.env.ADMIN_PASSWORD) {
      console.warn('ADMIN_EMAIL or ADMIN_PASSWORD environment variables not set. Using default credentials for seeder.');
    }

    const hashedPassword = await bcrypt.hash(adminPassword, 10);

    const existingAdmin = await queryInterface.rawSelect('users', {
      where: { email: adminEmail },
    }, ['id']);

    if (!existingAdmin) {
      await queryInterface.bulkInsert('users', [{
        name: 'System Administrator',
        email: adminEmail,
        password: hashedPassword,
        role: 'admin',
        status: 'active',
        email_verified: true, // Admin email is considered verified
        is_system_user: true,
        created_at: new Date(),
        updated_at: new Date()
      }], {});
    } else {
      console.log(`Admin user with email ${adminEmail} already exists. Skipping admin user seed.`);
    }
  },

  async down (queryInterface, Sequelize) {
    const adminEmail = process.env.ADMIN_EMAIL || 'admin@example.com';
    await queryInterface.bulkDelete('users', { email: adminEmail }, {});
  }
};

================
File: backend/seeders/20250531214406-initial-site-config.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    const configs = [
      { key: 'hoa_name', value: process.env.DEFAULT_HOA_NAME || 'Sanderson Creek HOA' },
      { key: 'hoa_description', value: process.env.DEFAULT_HOA_DESCRIPTION || 'Sanderson Creek HOA Community Management System' },
      { key: 'hoa_logo', value: process.env.DEFAULT_HOA_LOGO || '/images/logo.png' }
    ];

    for (const config of configs) {
      const existingConfig = await queryInterface.rawSelect('config', {
        where: { key: config.key },
      }, ['key']);

      if (!existingConfig) {
        await queryInterface.bulkInsert('config', [config], {});
      } else {
        // Optionally update if it exists, or just skip
        console.log(`Config key ${config.key} already exists. Skipping config seed for this key.`);
        // await queryInterface.bulkUpdate('config', { value: config.value }, { key: config.key });
      }
    }
  },

  async down (queryInterface, Sequelize) {
    const configKeys = ['hoa_name', 'hoa_description', 'hoa_logo'];
    await queryInterface.bulkDelete('config', { key: { [Sequelize.Op.in]: configKeys } }, {});
  }
};

================
File: backend/src/controllers/admin.user.controller.js
================
const userService = require('../services/user.service');
const { updateUserStatusSchema, updateUserRoleSchema, changePasswordSchema } = require('../validators/admin.user.validator');

/**
 * Handles listing all non-system users for admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function listUsers(req, res, next) {
  try {
    const { limit, offset } = req.query; // For pagination
    const result = await userService.listNonSystemUsers({ limit, offset });
    return res.status(200).json(result);
  } catch (err) {
    next(err);
  }
}

/**
 * Handles retrieving a specific non-system user by ID for admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function getUserById(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const user = await userService.getNonSystemUserById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found or is a system user.' });
    }
    return res.status(200).json(user);
  } catch (err) {
    next(err);
  }
}

/**
 * Handles updating a user's status by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function updateUserStatus(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const { error, value } = updateUserStatusSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    const updatedUser = await userService.updateUserStatus(userId, value.status, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json(updatedUser);

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles updating a user's role by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function updateUserRole(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const { error, value } = updateUserRoleSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    const updatedUser = await userService.updateUserRole(userId, value.role, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json(updatedUser);

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles deleting a user by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function deleteUser(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    await userService.deleteUser(userId, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json({ message: 'User and associated data deleted successfully.' });
    // Or return res.status(204).send(); for No Content response

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles changing a user's password by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function changeUserPasswordByAdmin(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const { error, value } = changePasswordSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    await userService.changeUserPasswordByAdmin(userId, value.newPassword, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json({ message: 'User password changed successfully.' });

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

module.exports = {
  listUsers,
  getUserById,
  updateUserStatus,
  updateUserRole,
  deleteUser,
  changeUserPasswordByAdmin,
};

================
File: backend/src/controllers/announcement.controller.js
================
const announcementService = require('../services/announcement.service.js');

/**
 * Handles the creation of a new announcement.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function createAnnouncement(req, res, next) {
  try {
    const announcementData = req.body; // Contains title, content, expiresAt (optional)
    const userId = req.user.id; // Assuming auth middleware sets req.user

    const newAnnouncement = await announcementService.createAnnouncement(announcementData, userId);

    res.status(201).json(newAnnouncement);
  } catch (error) {
    next(error); // Pass error to centralized error handler
  }
}

/**
 * Handles listing announcements with pagination, filtering, and sorting.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function listAnnouncements(req, res, next) {
  try {
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const status = req.query.status || 'active';
    const sortBy = req.query.sortBy || 'created_at';
    const sortOrder = req.query.sortOrder || 'DESC';

    if (page <= 0) {
      return res.status(400).json({ message: 'Page must be a positive integer.' });
    }
    if (limit <= 0) {
      return res.status(400).json({ message: 'Limit must be a positive integer.' });
    }

    const allowedSortOrders = ['ASC', 'DESC'];
    if (!allowedSortOrders.includes(sortOrder.toUpperCase())) {
      return res.status(400).json({ message: `sortOrder must be one of: ${allowedSortOrders.join(', ')}` });
    }
    // TODO: Add validation for allowed values of status and sortBy if specified in plan
    // Example: const allowedSortByFields = ['createdAt', 'title', 'expires_at'];
    // if (!allowedSortByFields.includes(sortBy)) {
    //   return res.status(400).json({ message: `sortBy must be one of: ${allowedSortByFields.join(', ')}` });
    // }

    const options = { page, limit, status, sortBy, sortOrder };

    const result = await announcementService.listAnnouncements(options);
    // Ensure the controller correctly uses the key returned by the service.
    // If the service now returns data, the controller should reflect that
    // when constructing the response.
    res.status(200).json({
      data: result.data,
      pagination: {
        totalItems: result.totalItems,
        totalPages: result.totalPages,
        currentPage: result.currentPage,
        limit: result.limit,
      }
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Handles updating an existing announcement.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function updateAnnouncement(req, res, next) {
  try {
    const { id: announcementId } = req.params;
    const updateData = req.body; // Contains optional title, content, expires_at
    const adminUserId = req.user.id; // Assuming auth middleware sets req.user

    // Input validation for req.body is handled by Joi middleware via routes
    // Sanitization for content (if HTML) would be here or in service. Assuming plain text.

    const updatedAnnouncement = await announcementService.updateAnnouncement(announcementId, updateData, adminUserId);
    res.status(200).json(updatedAnnouncement);
  } catch (error) {
    if (error.statusCode === 404) {
      return res.status(404).json({ message: error.message });
    }
    // For other errors, including potential validation errors from service if not caught by Joi
    // or other DB errors.
    // The technical spec mentions 400 for validation errors, but Joi middleware handles that before this controller.
    // If service layer throws a validation error (e.g. invalid date format not caught by Joi),
    // it might not have a statusCode.
    // For simplicity, passing to generic error handler which might result in 500.
    // A more robust error handling might map specific error types to 400 here.
    next(error);
  }
}

/**
 * Handles deleting an announcement.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function deleteAnnouncement(req, res, next) {
  try {
    const { id: announcementId } = req.params;
    const adminUserId = req.user.id; // Assuming auth middleware sets req.user

    await announcementService.deleteAnnouncement(announcementId, adminUserId);
    res.status(204).send(); // No content to send back
  } catch (error) {
    if (error.statusCode === 404) {
      return res.status(404).json({ message: error.message });
    }
    next(error); // Pass to generic error handler
  }
}

module.exports = {
  createAnnouncement,
  listAnnouncements,
  updateAnnouncement,
  deleteAnnouncement,
};

================
File: backend/src/controllers/audit.controller.js
================
'use strict';

const auditService = require('../services/audit.service');

async function getAuditLogsController(req, res, next) {
  try {
    const { page, limit } = req.query;
    const result = await auditService.getAuditLogs({ page: parseInt(page, 10), limit: parseInt(limit, 10) });
    res.status(200).json(result);
  } catch (error) {
    next(error);
  }
}

module.exports = {
  getAuditLogsController,
};

================
File: backend/src/controllers/auth.controller.js
================
const authService = require('../services/auth.service');
const { registerSchema, loginSchema, forgotPasswordSchema, resetPasswordSchema } = require('../validators/auth.validator');

/**
 * Handles user registration.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function register(req, res, next) {
  try {
    // Validate request body
    const { error, value } = registerSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    // Call registration service
    const user = await authService.registerUser(value);

    // Send response
    return res.status(201).json({
      message: 'Registration successful. Your account is pending approval.',
      user // Excludes password as handled by service
    });

  } catch (err) {
    // Handle errors from service (e.g., email conflict) or other unexpected errors
    if (err.statusCode) {
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Pass to a generic error handler if one is set up
    next(err); 
  }
}

/**
 * Handles user login.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function login(req, res, next) {
  try {
    // Validate request body
    const { error, value } = loginSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    // Call login service
    const { token, user } = await authService.loginUser(value);

    // Send response
    return res.status(200).json({
      message: 'Login successful.',
      token,
      user // Excludes password as handled by service
    });

  } catch (err) {
    // Handle errors from service (e.g., invalid credentials, account not approved)
    if (err.statusCode) {
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Pass to a generic error handler
    next(err);
  }
}

/**
 * Handles forgot password request.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function forgotPassword(req, res, next) {
  try {
    const { error, value } = forgotPasswordSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        // error: 'Invalid email format.' // More specific as per requirements
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    await authService.requestPasswordReset(value.email);

    return res.status(200).json({
      message: 'Password reset email sent. Please check your inbox.'
    });

  } catch (err) {
    if (err.statusCode) {
      // Specific error messages based on service layer logic
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Default error for invalid email format if not caught by Joi (though Joi should catch it)
    if (err.message.toLowerCase().includes('email')) { // Basic check
        return res.status(400).json({ error: 'Invalid email format.' });
    }
    next(err);
  }
}

/**
 * Handles verification of a password reset token.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function verifyResetToken(req, res, next) {
  try {
    const { token } = req.query;

    if (!token) {
        return res.status(400).json({ error: 'Invalid or expired password reset token.' });
    }

    await authService.verifyPasswordResetToken(token);

    return res.status(200).json({ message: 'Token is valid.' });

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Default error for token issues
    return res.status(400).json({ error: 'Invalid or expired password reset token.' });
    // next(err); // Or pass to generic error handler
  }
}

/**
 * Handles resetting a user's password.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function resetPassword(req, res, next) {
  try {
    const { error, value } = resetPasswordSchema.validate(req.body);
    if (error) {
      // Check for password complexity error specifically
      if (error.details.some(d => d.path.includes('newPassword') && d.type === 'string.pattern.base')) {
        return res.status(400).json({
          error: "Password does not meet complexity requirements. Minimum 8 characters, including uppercase, lowercase, number, and special character."
        });
      }
      // Generic validation error for missing fields or other issues
      return res.status(400).json({
        error: error.details.map(d => d.message).join(', ') || "Token and newPassword are required."
      });
    }

    await authService.resetPassword(value.token, value.newPassword);

    return res.status(200).json({ message: 'Password has been reset successfully.' });

  } catch (err) {
    if (err.statusCode) {
      // Specific error messages from service layer (e.g., invalid token)
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Default error for other issues
    // Log the error for debugging if it's unexpected
    console.error('Unexpected error in resetPassword controller:', err);
    return res.status(500).json({ error: 'An unexpected error occurred.' });
    // next(err); // Or pass to generic error handler
  }
}

module.exports = {
  register,
  login,
  forgotPassword,
  verifyResetToken,
  resetPassword,
};

================
File: backend/src/controllers/config.controller.js
================
const configService = require('../services/config.service');
const ApiError = require('../utils/ApiError'); // Assuming ApiError utility for error handling

const getAllConfigsController = async (req, res, next) => {
  try {
    const configs = await configService.getAllConfigs();
    res.status(200).json(configs);
  } catch (error) {
    // Assuming a centralized error handler or ApiError can be caught by it
    next(error instanceof ApiError ? error : new ApiError(500, 'Failed to retrieve configurations'));
  }
};

const updateConfigController = async (req, res, next) => {
  try {
    const { key } = req.params;
    const { value } = req.body;
    const adminUserId = req.user.id; // Assuming verifyToken and isAdmin middlewares populate req.user

    if (!adminUserId) {
        // This check is more for robustness, as isAdmin should ensure req.user.id exists
        return next(new ApiError(403, 'User ID not found, authorization issue.'));
    }

    const updatedConfig = await configService.upsertConfig(key, value, adminUserId);
    res.status(200).json(updatedConfig);
  } catch (error) {
    next(error instanceof ApiError ? error : new ApiError(500, `Failed to update configuration for key: ${req.params.key}`));
  }
};

module.exports = {
  getAllConfigsController,
  updateConfigController,
};

================
File: backend/src/controllers/discussion.controller.js
================
const httpStatus = require('http-status');
const discussionService = require('../services/discussion.service');
const catchAsync = require('../utils/catchAsync'); // Assuming catchAsync utility for error handling

const createThreadController = catchAsync(async (req, res) => {
  const { title, content } = req.body;
  const userId = req.user.id;
  const thread = await discussionService.createThread({ title, content }, userId);
  res.status(httpStatus.CREATED).send(thread);
});

const createReplyController = catchAsync(async (req, res) => {
  const { threadId } = req.params;
  const { content } = req.body;
  const userId = req.user.id;
  const reply = await discussionService.createReply({ content }, threadId, userId);
  res.status(httpStatus.CREATED).send(reply);
});

const listThreadsController = catchAsync(async (req, res) => {
  const { page, limit } = req.query;
  const threads = await discussionService.listThreads({ page, limit });
  res.send(threads);
});

const viewThreadController = catchAsync(async (req, res) => {
  const { threadId } = req.params;
  const thread = await discussionService.viewThread(threadId);
  if (!thread) {
    return res.status(httpStatus.NOT_FOUND).send({ message: 'Thread not found or is not a main thread' });
  }
  res.send(thread);
});

const deleteThreadController = catchAsync(async (req, res) => {
  const { threadId } = req.params;
  const adminUserId = req.user.id;
  await discussionService.deleteThread(threadId, adminUserId);
  res.status(httpStatus.NO_CONTENT).send();
});

const deleteReplyController = catchAsync(async (req, res) => {
  const { replyId } = req.params;
  const adminUserId = req.user.id;
  await discussionService.deleteReply(replyId, adminUserId);
  res.status(httpStatus.NO_CONTENT).send();
});

module.exports = {
  createThreadController,
  createReplyController,
  listThreadsController,
  viewThreadController,
  deleteThreadController,
  deleteReplyController,
};

================
File: backend/src/controllers/document.controller.js
================
const documentService = require('../services/document.service');
const { uploadDocumentSchema } = require('../validators/document.validator');
const multer = require('multer'); // To handle Multer errors specifically

/**
 * Handles document upload by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function uploadDocument(req, res, next) {
  try {
    // File is already handled by multer middleware if this controller is reached
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded or file type not allowed.' });
    }

    // Validate text fields
    const { error, value } = uploadDocumentSchema.validate(req.body);
    if (error) {
      // If validation fails, and a file was uploaded, it's good practice to remove the orphaned file.
      // However, fs.unlink can be complex here due to async nature and error paths.
      // For simplicity, this example doesn't remove orphaned files on validation error.
      // In a production app, consider a cleanup strategy.
      return res.status(400).json({
        message: 'Validation failed for document metadata.',
        errors: error.details.map(d => d.message)
      });
    }

    const documentData = {
      title: value.title,
      description: value.description,
      // originalFileName: req.file.originalname, // Available if needed
      storedFileName: req.file.filename,    // Name generated by Multer
      filePath: req.file.path,              // Full path where Multer stored the file
      uploadedBy: req.user.id,              // Assuming req.user is populated by auth middleware
      isPublic: value.is_public,
    };

    const newDocument = await documentService.createDocument(documentData);

    return res.status(201).json({
      message: 'Document uploaded successfully.',
      document: newDocument
    });

  } catch (err) {
    // Handle Multer-specific errors (like file size limit)
    if (err instanceof multer.MulterError) {
      if (err.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({ message: `File too large. Max size is ${process.env.MAX_FILE_SIZE_MB || 10}MB.` });
      }
      return res.status(400).json({ message: `File upload error: ${err.message}` });
    }
    // Handle other errors
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles listing documents for users/admins.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function listDocuments(req, res, next) {
  try {
    const { limit, offset } = req.query;
    // req.user might be undefined if the route is public and token is not provided
    const result = await documentService.listDocuments(req.user, { limit, offset });
    return res.status(200).json(result);
  } catch (err) {
    next(err);
  }
}

/**
 * Handles retrieving a specific document's metadata.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function getDocumentMetadata(req, res, next) {
  try {
    const documentId = parseInt(req.params.documentId, 10);
    if (isNaN(documentId)) {
      return res.status(400).json({ error: 'Invalid document ID format.' });
    }

    const document = await documentService.getDocumentMetadataById(documentId, req.user);
    // The service now throws specific errors, so a !document check is less likely here
    // unless the service is changed to return null for some cases again.
    // For now, we rely on the catch block.
    return res.status(200).json(document);
  } catch (err) {
    if (err.statusCode) {
      // Use 'error' key as requested
      return res.status(err.statusCode).json({ error: err.message });
    }
    next(err); // For unexpected errors
  }
}

/**
 * Handles downloading a specific document.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function downloadDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.documentId, 10);
    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    const document = await documentService.getDocumentForDownload(documentId, req.user);
    
    // The service throws an error if access is denied or document not found.
    // If we reach here, download is permitted.
    
    // Use res.download to trigger file download.
    // The 'file_name' from the DB should be the user-facing filename.
    // The 'file_path' from the DB is the actual path on the server.
    // Ensure file_path is secure and not subject to path traversal.
    // The documentService should ideally return the original filename if stored,
    // or use title as a fallback. For now, using document.file_name (stored unique name)
    // might not be user-friendly. Let's assume document.title is a good fallback.
    // The plan mentions: "assume file_name in DB is the user-facing filename for download."
    // This implies the original filename should be stored, perhaps in a field like `original_file_name`.
    // For now, using the stored `file_name` as the download name.
    
    // IMPORTANT: Ensure `document.file_path` is an absolute path or correctly resolved
    // to prevent security vulnerabilities. The Multer setup stores absolute paths.
    res.download(document.file_path, document.original_file_name, (err) => {
      if (err) {
        // Handle errors that occur after headers have been sent, like network issues
        // or if the file is missing (though getDocumentForDownload should catch this)
        console.error('Error during file download:', err);
        if (!res.headersSent) {
          return res.status(500).json({ message: 'Could not download the file.' });
        }
      }
    });

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles approving a document by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function adminApproveDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.id, 10);
    const adminUserId = req.user.id; // Assuming verifyToken middleware sets req.user

    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    const updatedDocument = await documentService.approveDocumentById(documentId, adminUserId);
    return res.status(200).json(updatedDocument);
  } catch (err) {
    // Pass errors to the error handling middleware
    // Specific error handling (e.g., for not found or permission issues)
    // should ideally be done in the service layer and result in custom error objects
    // that the global error handler can interpret.
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles deleting a document by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function adminDeleteDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.id, 10);
    const adminUserId = req.user.id; // Assuming verifyToken middleware sets req.user

    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    await documentService.deleteDocumentById(documentId, adminUserId);
    return res.status(204).send();
  } catch (err) {
    // Pass errors to the error handling middleware
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}
module.exports = {
  uploadDocument,
  listDocuments,
  getDocumentMetadata,
  downloadDocument,
  adminApproveDocument,
  adminDeleteDocument,
};

================
File: backend/src/controllers/event.controller.js
================
const eventService = require('../services/event.service');

const listEvents = async (req, res, next) => {
  try {
    // Query parameters are already validated and sanitized by express-validator
    // and will be available in req.query
    const queryParams = req.query;

    const result = await eventService.getAllEvents(queryParams);

    res.status(200).json(result);
  } catch (error) {
    // Log the error for server-side inspection
    console.error('Error in listEvents controller:', error);

    // Check if the error is a known service layer error or a generic one
    if (error.message === 'Error fetching events from database.') {
      // Pass to a generic error handler or return a 500
      // For now, let's assume a generic error handler will catch it
      // or we can send a 500 directly.
      return res.status(500).json({ error: 'Internal Server Error' });
    }
    // For other types of errors, or if you want more specific error handling
    // you can add more checks here.
    
    // Fallback to a generic 500 error if not handled specifically
    // and not already sent by a more specific catch.
    // This next(error) will typically be caught by a global error handler in app.js
    next(error); 
  }
};

const adminUpdateEvent = async (req, res, next) => {
  try {
    const eventId = req.params.id;
    const updateData = req.body;
    const adminUserId = req.user.id; // Assuming JWT middleware adds user to req

    const updatedEvent = await eventService.updateEvent(eventId, updateData, adminUserId);
    res.status(200).json(updatedEvent);
  } catch (error) {
    console.error(`Error in adminUpdateEvent controller for event ${req.params.id}:`, error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({ error: error.message });
    }
    next(error); // Pass to global error handler
  }
};

const adminDeleteEvent = async (req, res, next) => {
  try {
    const eventId = req.params.id;
    const adminUserId = req.user.id; // Assuming JWT middleware adds user to req

    await eventService.deleteEvent(eventId, adminUserId);
    res.status(204).send();
  } catch (error) {
    console.error(`Error in adminDeleteEvent controller for event ${req.params.id}:`, error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({ error: error.message });
    }
    next(error); // Pass to global error handler
  }
};

const createEvent = async (req, res, next) => {
  try {
    const { title, description, event_date, location } = req.body;
    const adminUserId = req.user.id; // Assuming JWT middleware adds user to req

    const eventData = { title, description, event_date, location };
    const newEvent = await eventService.createEvent(eventData, adminUserId);

    res.status(201).json(newEvent);
  } catch (error) {
    console.error('Error in createEvent controller:', error);
    // If the service layer threw an error with a statusCode, use it
    if (error.statusCode) {
      // Construct a more informative error response if service provides details
      const errorResponse = { error: error.message };
      if (error.errors) { // For validation errors from service
        errorResponse.details = error.errors;
      }
      return res.status(error.statusCode).json(errorResponse);
    }
    // Pass to global error handler for unhandled/generic errors
    next(error);
  }
};

module.exports = {
  listEvents,
  adminUpdateEvent,
  adminDeleteEvent,
  createEvent,
};

================
File: backend/src/controllers/user.controller.js
================
const userService = require('../services/user.service');
const { validationResult } = require('express-validator');

/**
 * Controller to get the authenticated user's own profile.
 */
const getOwnProfile = async (req, res) => {
  try {
    const userId = req.user.id; // Assuming auth.middleware sets req.user.id
    if (!userId) {
      // This case should ideally be caught by auth middleware, but as a safeguard:
      return res.status(401).json({ error: 'Unauthorized - User ID not found in token' });
    }

    const userProfile = await userService.fetchOwnProfile(userId);

    if (!userProfile) {
      // This case implies the user ID from a valid token doesn't exist in DB, which is unusual.
      return res.status(404).json({ error: 'User profile not found.' });
    }

    res.status(200).json(userProfile);
  } catch (error) {
    console.error('Error in getOwnProfile controller:', error);
    // Generic error for unexpected issues
    res.status(500).json({ error: 'Failed to retrieve user profile.' });
  }
};

/**
 * Controller to update the authenticated user's own profile.
 */
const updateOwnProfile = async (req, res) => {
  try {
    const userId = req.user.id; // Assuming auth.middleware sets req.user.id
    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized - User ID not found in token' });
    }

    // Validate request body
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      // Map errors to the specified format: { "errors": [ { "field": "name", "message": "..." } ] }
      const formattedErrors = errors.array().map(err => ({
        field: err.path, // express-validator uses 'path' for field name
        message: err.msg,
      }));
      return res.status(400).json({ errors: formattedErrors });
    }

    const updateData = req.body;

    // The service layer will handle which fields are actually updatable (e.g., only 'name')
    const updatedUserProfile = await userService.modifyOwnProfile(userId, updateData);

    if (!updatedUserProfile) {
      // This could happen if the user was deleted between auth and this call, or if service validation fails internally
      return res.status(404).json({ error: 'User profile not found or update failed.' });
    }

    res.status(200).json(updatedUserProfile);
  } catch (error) {
    console.error('Error in updateOwnProfile controller:', error);
    if (error.isValidationError) { // Check for custom validation error from service
        return res.status(400).json({ errors: [{ field: error.field || 'general', message: error.message }] });
    }
    res.status(500).json({ error: 'Failed to update user profile.' });
  }
};

/**
 * Controller to change the authenticated user's own password.
 */
const changeOwnPassword = async (req, res) => {
  try {
    const userId = req.user.id;
    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized - User ID not found in token' });
    }

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      // Check for specific "currentPassword" or "newPassword" missing errors first
      const missingCurrentPassword = errors.array().find(err => err.path === 'currentPassword' && err.msg.includes('required'));
      const missingNewPassword = errors.array().find(err => err.path === 'newPassword' && err.msg.includes('required'));

      if (missingCurrentPassword || missingNewPassword) {
        return res.status(400).json({ error: 'Current password and new password are required.' });
      }
      
      // Handle password complexity error specifically
      const complexityError = errors.array().find(err => err.path === 'newPassword' && err.msg.includes('complexity') || err.msg.includes('must include'));
      if (complexityError) {
          return res.status(400).json({ error: "New password does not meet complexity requirements. Minimum 8 characters, including uppercase, lowercase, number, and special character." });
      }

      // Fallback for other validation errors (though schema is specific)
      const formattedErrors = errors.array().map(err => ({ field: err.path, message: err.msg, }));
      return res.status(400).json({ errors: formattedErrors });
    }

    const { currentPassword, newPassword } = req.body;

    await userService.updateOwnPassword(userId, currentPassword, newPassword);

    res.status(200).json({ message: 'Password changed successfully.' });

  } catch (error) {
    console.error('Error in changeOwnPassword controller:', error);
    if (error.statusCode === 403) {
      return res.status(403).json({ error: 'Incorrect current password.' });
    }
    if (error.statusCode === 400) { // For service-level validation errors if any
        return res.status(400).json({ error: error.message || "Failed to change password due to invalid input." });
    }
    // Default to 500 for other errors
    res.status(500).json({ error: 'Failed to change password.' });
  }
};

module.exports = {
  getOwnProfile,
  updateOwnProfile,
  changeOwnPassword,
};

================
File: backend/src/middlewares/auth.middleware.js
================
const jwt = require('jsonwebtoken');
const { User } = require('../../models'); // Adjust path if models are not in root/models

/**
 * Middleware to verify JWT token from Authorization header.
 * Attaches user information to req.user if token is valid.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function verifyToken(req, res, next) {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Access token is required.' });
  }

  const token = authHeader.split(' ')[1];

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Optionally, fetch user from DB to ensure they still exist and are active
    // This adds a DB hit but increases security. For this example, we'll trust the token payload.
    // const user = await User.findByPk(decoded.userId);
    // if (!user || user.status !== 'approved') {
    //   return res.status(401).json({ message: 'Invalid token or user not active.' });
    // }

    req.user = {
      id: decoded.userId, // Ensure this matches the payload key (userId or id)
      role: decoded.role,
      // Add other non-sensitive user details from token if needed
    };
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'Token expired.' });
    }
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ error: 'Invalid token.' });
    }
    // For other errors, pass to generic error handler
    console.error('JWT verification error:', error);
    return res.status(403).json({ message: 'Forbidden: Token verification failed.' });
  }
}

/**
 * Middleware factory to authorize users based on roles.
 * @param  {...string} allowedRoles - List of roles allowed to access the route.
 * @returns {function} Express middleware function.
 */
function authorizeRoles(...allowedRoles) {
  return (req, res, next) => {
    if (!req.user || !req.user.role) {
      // This should ideally not happen if verifyToken runs first and sets req.user
      return res.status(403).json({ message: 'Forbidden: User role not available.' });
    }

    const rolesArray = [...allowedRoles];
    if (!rolesArray.includes(req.user.role)) {
      return res.status(403).json({ message: 'Forbidden: You do not have permission to access this resource.' });
    }
    next();
  };
}

/**
 * Middleware to optionally verify JWT token.
 * If a token is provided and valid, req.user is populated.
 * If no token or an invalid token is provided, it proceeds without error, and req.user remains undefined.
 * This is useful for routes that behave differently for guests vs. authenticated users.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function optionalAuth(req, res, next) {
  const authHeader = req.headers.authorization;

  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.split(' ')[1];
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = {
        id: decoded.userId,
        role: decoded.role,
      };
    } catch (error) {
      // Invalid token, but we don't block the request, just don't set req.user
      console.warn('Optional auth: Invalid token received, proceeding as guest.', error.name);
    }
  }
  next();
}

module.exports = {
  verifyToken,
  authorizeRoles,
  optionalAuth,
};

================
File: backend/src/middlewares/upload.middleware.js
================
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Define allowed MIME types and a max file size
const ALLOWED_MIME_TYPES = [
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // .docx
  'image/jpeg',
  'image/png',
  'image/gif',
];
const MAX_FILE_SIZE_MB = 10;
const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;

// Ensure the upload directory exists
const uploadDir = path.join(__dirname, '../../uploads/documents'); // Relative to this file, goes up to backend/ then uploads/documents
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

// Multer disk storage configuration
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const extension = path.extname(file.originalname);
    cb(null, file.fieldname + '-' + uniqueSuffix + extension);
  }
});

// Multer file filter
const fileFilter = (req, file, cb) => {
  if (ALLOWED_MIME_TYPES.includes(file.mimetype)) {
    cb(null, true); // Accept file
  } else {
    cb(new multer.MulterError('LIMIT_UNEXPECTED_FILE', `File type not allowed. Allowed types: ${ALLOWED_MIME_TYPES.join(', ')}`), false); // Reject file
  }
};

const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: MAX_FILE_SIZE_BYTES // 10 MB limit
  }
});

module.exports = upload;

================
File: backend/src/middlewares/validate.middleware.js
================
const Joi = require('joi');
const ApiError = require('../utils/ApiError'); // Assuming ApiError utility

const validate = (schema) => (req, res, next) => {
  const validSchema = Joi.compile(schema);
  const object = {};
  if (req.method === 'GET' || req.method === 'DELETE') {
    Object.assign(object, req.params, req.query);
  } else { // POST, PUT, PATCH
    Object.assign(object, req.params, req.query, req.body);
  }

  const { value, error } = validSchema.validate(object, {
    abortEarly: false, // return all errors
    allowUnknown: true, // allow properties not defined in schema
    stripUnknown: true, // remove properties not defined in schema
  });

  if (error) {
    const errorMessage = error.details.map((details) => details.message).join(', ');
    return next(new ApiError(400, errorMessage));
  }
  Object.assign(req, value); // Assign validated (and potentially transformed) data back to req
  return next();
};

module.exports = validate;

================
File: backend/src/routes/admin.user.routes.js
================
const express = require('express');
const adminUserController = require('../controllers/admin.user.controller');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware');

const router = express.Router();

// All routes in this file are protected and require admin role
router.use(verifyToken);
router.use(authorizeRoles('admin'));

/**
 * @swagger
 * /api/admin/users:
 *   get:
 *     summary: List all non-system users (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of users to return
 *       - in: query
 *         name: offset
 *         schema:
 *           type: integer
 *           default: 0
 *         description: Number of users to skip for pagination
 *     responses:
 *       200:
 *         description: A list of non-system users.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 count:
 *                   type: integer
 *                   example: 1
 *                 users:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/UserResponse' # Defined in auth.routes.js or a common place
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.get('/', adminUserController.listUsers);

/**
 * @swagger
 * /api/admin/users/{userId}:
 *   get:
 *     summary: Get a specific non-system user by ID (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user to retrieve
 *     responses:
 *       200:
 *         description: Details of the non-system user.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid user ID format
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Invalid user ID format.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       404:
 *         description: User not found or is a system user
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User not found or is a system user.
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.get('/:userId', adminUserController.getUserById);

/**
 * @swagger
 * /api/admin/users/{userId}/status:
 *   put:
 *     summary: Update a user's status (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user whose status is to be updated
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - status
 *             properties:
 *               status:
 *                 type: string
 *                 enum: [approved, pending, rejected]
 *                 example: approved
 *     responses:
 *       200:
 *         description: User status updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid user ID format or validation failed for status
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to update a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot modify system user status.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put('/:userId/status', adminUserController.updateUserStatus);

/**
 * @swagger
 * /api/admin/users/{userId}/role:
 *   put:
 *     summary: Update a user's role (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user whose role is to be updated
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - role
 *             properties:
 *               role:
 *                 type: string
 *                 enum: [admin, member]
 *                 example: admin
 *     responses:
 *       200:
 *         description: User role updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid user ID format or validation failed for role
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to update a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot modify system user role.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put('/:userId/role', adminUserController.updateUserRole);

/**
 * @swagger
 * /api/admin/users/{userId}:
 *   delete:
 *     summary: Delete a non-system user and their associated data (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user to delete
 *     responses:
 *       200:
 *         description: User and associated data deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User and associated data deleted successfully.
 *       204:
 *         description: User and associated data deleted successfully (No Content).
 *       400:
 *         description: Invalid user ID format
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to delete a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot delete system user.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.delete('/:userId', adminUserController.deleteUser);

/**
 * @swagger
 * /api/admin/users/{userId}/password:
 *   put:
 *     summary: Change a user's password (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user whose password is to be changed
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - newPassword
 *             properties:
 *               newPassword:
 *                 type: string
 *                 format: password
 *                 minLength: 8
 *                 example: newSecurePassword123
 *     responses:
 *       200:
 *         description: User password changed successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User password changed successfully.
 *       400:
 *         description: Invalid user ID format or validation failed for newPassword
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to change password for a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot change password for a system user.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put('/:userId/password', adminUserController.changeUserPasswordByAdmin);

module.exports = router;

================
File: backend/src/routes/announcement.routes.js
================
const express = require('express');
const router = express.Router();
const { verifyToken: authenticateToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin'); // Create isAdmin middleware
const { createAnnouncementSchema, updateAnnouncementSchema } = require('../validators/announcement.validator');
const announcementController = require('../controllers/announcement.controller'); // Or import specific function
const validate = require('../middlewares/validate.middleware'); // Import validate middleware

// POST / (will be /api/admin/announcements/ when mounted) - Create a new announcement
router.post(
  '/',
  authenticateToken,
  isAdmin,
  validate(createAnnouncementSchema), // Wrap schema with validate middleware
  announcementController.createAnnouncement // Ensure this matches your controller export
);

// GET / (will be /api/announcements/ when mounted) - List announcements for users
router.get(
  '/',
  authenticateToken, // Assuming authenticated users can list
  announcementController.listAnnouncements
);

module.exports = router;

// PUT /:id - Update an announcement (Admin only)
router.put(
  '/:id',
  authenticateToken,
  isAdmin,
  validate(updateAnnouncementSchema), // Wrap schema with validate middleware
  announcementController.updateAnnouncement
);

// DELETE /:id - Delete an announcement (Admin only)
router.delete(
  '/:id',
  authenticateToken,
  isAdmin,
  announcementController.deleteAnnouncement
);

================
File: backend/src/routes/audit.routes.js
================
'use strict';

const express = require('express');
const auditController = require('../controllers/audit.controller');
const validate = require('../middlewares/validate.middleware');
const { getAuditLogsSchema } = require('../validators/audit.validator');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin');

const router = express.Router();

router.get(
  '/',
  verifyToken,
  isAdmin,
  validate(getAuditLogsSchema),
  auditController.getAuditLogsController
);

module.exports = router;

================
File: backend/src/routes/auth.routes.js
================
const express = require('express');
const authController = require('../controllers/auth.controller');
const { registerSchema, loginSchema, forgotPasswordSchema, resetPasswordSchema } = require('../validators/auth.validator.js');
const validate = require('../middlewares/validate.middleware');

const router = express.Router();

/**
 * @swagger
 * /api/auth/register:
 *   post:
 *     summary: Register a new user
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - email
 *               - password
 *             properties:
 *               name:
 *                 type: string
 *                 example: John Doe
 *               email:
 *                 type: string
 *                 format: email
 *                 example: john.doe@example.com
 *               password:
 *                 type: string
 *                 format: password
 *                 minLength: 8
 *                 example: password123
 *     responses:
 *       201:
 *         description: Registration successful. Account pending approval.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Registration successful. Your account is pending approval.
 *                 user:
 *                   $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Validation failed
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorValidation'
 *       409:
 *         description: Email already registered
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorConflict'
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorServer'
 */
router.post('/register', validate(registerSchema), authController.register);

/**
 * @swagger
 * /api/auth/login:
 *   post:
 *     summary: Log in an existing user
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 example: john.doe@example.com
 *               password:
 *                 type: string
 *                 format: password
 *                 example: password123
 *     responses:
 *       200:
 *         description: Login successful
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Login successful.
 *                 token:
 *                   type: string
 *                   example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 *                 user:
 *                   $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Validation failed
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorValidation'
 *       401:
 *         description: Invalid email or password
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorUnauthorized'
 *       403:
 *         description: Account not approved or access denied
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorForbidden'
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorServer'
 */
router.post('/login', validate(loginSchema), authController.login);

/**
 * @swagger
 * /api/auth/forgot-password:
 *   post:
 *     summary: Request a password reset token
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 example: user@example.com
 *     responses:
 *       200:
 *         description: Password reset email sent.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Password reset email sent. Please check your inbox.
 *       400:
 *         description: Invalid email format or user account not active/eligible.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Invalid email format.
 *       404:
 *         description: Email not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Email not found.
 *       500:
 *         description: Internal server error
 */
router.post('/forgot-password', validate(forgotPasswordSchema), authController.forgotPassword);

/**
 * @swagger
 * /api/auth/verify-reset-token:
 *   get:
 *     summary: Verify a password reset token
 *     tags: [Auth]
 *     parameters:
 *       - in: query
 *         name: token
 *         schema:
 *           type: string
 *         required: true
 *         description: The password reset token.
 *         example: abc123xyz789
 *     responses:
 *       200:
 *         description: Token is valid.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Token is valid.
 *       400:
 *         description: Invalid or expired password reset token.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Invalid or expired password reset token.
 *       500:
 *         description: Internal server error
 */
router.get('/verify-reset-token', authController.verifyResetToken);

/**
 * @swagger
 * /api/auth/reset-password:
 *   post:
 *     summary: Reset user password with a token
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - token
 *               - newPassword
 *             properties:
 *               token:
 *                 type: string
 *                 example: "THE_GENERATED_TOKEN_FROM_EMAIL"
 *                 description: The password reset token received by the user.
 *               newPassword:
 *                 type: string
 *                 format: password
 *                 minLength: 8
 *                 example: "NewSecurePassword123!"
 *                 description: The new password for the user account. Must meet complexity requirements.
 *     responses:
 *       200:
 *         description: Password has been reset successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Password has been reset successfully.
 *       400:
 *         description: Bad Request - Invalid/expired token, password complexity not met, or missing fields.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   examples:
 *                     invalidToken: "Invalid or expired password reset token."
 *                     passwordComplexity: "Password does not meet complexity requirements. Minimum 8 characters, including uppercase, lowercase, number, and special character."
 *                     missingFields: "Token and newPassword are required."
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorServer'
 */
router.post('/reset-password', validate(resetPasswordSchema), authController.resetPassword);


// Placeholder for UserResponse schema (to be defined in Swagger setup)
// components:
//   schemas:
//     UserResponse:
//       type: object
//       properties:
//         id:
//           type: integer
//         name:
//           type: string
//         email:
//           type: string
//         role:
//           type: string
//         status:
//           type: string
//         email_verified:
//           type: boolean
//         is_system_user:
//           type: boolean
//         created_at:
//           type: string
//           format: date-time
//         updated_at:
//           type: string
//           format: date-time
//     ErrorValidation:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Validation failed.
//         errors:
//           type: array
//           items:
//             type: string
//           example: ["Name is required."]
//     ErrorConflict:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Email already registered.
//     ErrorUnauthorized:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Invalid email or password.
//     ErrorForbidden:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Account pending approval.
//     ErrorServer:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Internal server error

module.exports = router;

================
File: backend/src/routes/config.routes.js
================
const express = require('express');
const configController = require('../controllers/config.controller');
const validate = require('../middlewares/validate.middleware');
const { updateConfigSchema } = require('../validators/config.validator');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware'); // Assuming auth middlewares
const isAdmin = authorizeRoles('admin');

const router = express.Router();

// GET /api/admin/config - Get all configurations
router.get(
  '/',
  verifyToken,
  isAdmin,
  configController.getAllConfigsController
);

// PUT /api/admin/config/:key - Upsert a configuration key-value
router.put(
  '/:key',
  verifyToken,
  isAdmin,
  validate(updateConfigSchema),
  configController.updateConfigController
);

module.exports = router;

================
File: backend/src/routes/discussion.routes.js
================
const express = require('express');
const discussionController = require('../controllers/discussion.controller');
const validate = require('../middlewares/validate.middleware');
const { createThreadSchema, createReplySchema, listThreadsSchema } = require('../validators/discussion.validator');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin');

const router = express.Router();

router.post(
  '/',
  verifyToken,
  validate(createThreadSchema),
  discussionController.createThreadController
);

router.post(
  '/:threadId/replies',
  verifyToken,
  validate(createReplySchema),
  discussionController.createReplyController
);

// GET /api/discussions - List all main discussion threads
router.get(
  '/',
  verifyToken,
  validate(listThreadsSchema, 'query'), // Validate query parameters
  discussionController.listThreadsController
);

// GET /api/discussions/:threadId - View a specific thread with its replies
router.get(
  '/:threadId',
  verifyToken,
  discussionController.viewThreadController
);

// DELETE a discussion thread (Admin only)
router.delete(
  '/:threadId',
  verifyToken,
  isAdmin,
  discussionController.deleteThreadController
);

// DELETE a specific reply (Admin only)
router.delete(
  '/replies/:replyId',
  verifyToken,
  isAdmin,
  discussionController.deleteReplyController
);

module.exports = router;

================
File: backend/src/routes/document.routes.js
================
const express = require('express');
const documentController = require('../controllers/document.controller');
const { verifyToken, authorizeRoles, optionalAuth } = require('../middlewares/auth.middleware');
const upload = require('../middlewares/upload.middleware'); // Multer upload middleware

const router = express.Router();

// --- Admin Document Routes ---

/**
 * @swagger
 * /api/admin/documents: // This path is for admin actions, distinct from public /api/documents
 *   post:
 *     summary: Upload a new document (Admin only)
 *     tags: [Documents Admin]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - documentFile
 *               - title
 *               - is_public
 *             properties:
 *               documentFile:
 *                 type: string
 *                 format: binary
 *                 description: The document file to upload.
 *               title:
 *                 type: string
 *                 example: Meeting Minutes Q1
 *               description:
 *                 type: string
 *                 example: Detailed minutes from the first quarter HOA meeting.
 *               is_public:
 *                 type: boolean
 *                 example: true
 *     responses:
 *       201:
 *         description: Document uploaded successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 document:
 *                   $ref: '#/components/schemas/DocumentResponse' # To be defined
 *       400:
 *         description: Validation failed, no file uploaded, file type not allowed, or file too large.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.post(
  '/',
  verifyToken,
  authorizeRoles('admin'),
  upload.single('documentFile'), // 'documentFile' is the field name in the form-data
  documentController.uploadDocument
);

// Other admin document routes (approve, delete) will be added here later.

/**
 * @swagger
 * /api/documents/{id}/approve:
 *   put:
 *     summary: Approve a document (Admin only)
 *     tags: [Documents Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the document to approve
 *     responses:
 *       200:
 *         description: Document approved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DocumentResponse'
 *       400:
 *         description: Invalid document ID format.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       404:
 *         description: Document not found.
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put(
  '/:id/approve',
  verifyToken,
  authorizeRoles('admin'),
  documentController.adminApproveDocument
);

/**
 * @swagger
 * /api/documents/{id}:
 *   delete:
 *     summary: Delete a document (Admin only)
 *     tags: [Documents Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the document to delete
 *     responses:
 *       204:
 *         description: Document deleted successfully.
 *       400:
 *         description: Invalid document ID format.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       404:
 *         description: Document not found.
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.delete(
  '/:id',
  verifyToken,
  authorizeRoles('admin'),
  documentController.adminDeleteDocument
);


// --- Public/User Document Routes ---

// Middleware to make authentication optional for the following routes
// The controller/service will handle logic based on whether req.user exists
router.use(optionalAuth);

/**
 * @swagger
 * /api/documents:
 *   get:
 *     summary: List available documents
 *     tags: [Documents]
 *     security:
 *       - bearerAuth: [] # Optional
 *     parameters:
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of documents to return
 *       - in: query
 *         name: offset
 *         schema:
 *           type: integer
 *           default: 0
 *         description: Number of documents to skip
 *     responses:
 *       200:
 *         description: A list of documents.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 count:
 *                   type: integer
 *                 documents:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/DocumentResponse'
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.get('/', documentController.listDocuments);

/**
 * @swagger
 * /api/documents/{documentId}:
 *   get:
 *     summary: Get a specific document's metadata
 *     tags: [Documents]
 *     security:
 *       - bearerAuth: [] # Optional
 *     parameters:
 *       - in: path
 *         name: documentId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the document
 *     responses:
 *       200:
 *         description: Document metadata.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DocumentResponse'
 *       400:
 *         description: Invalid document ID format
 *       404:
 *         description: Document not found or access denied
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.get('/:documentId', documentController.getDocumentMetadata);

/**
 * @swagger
 * /api/documents/{documentId}/download:
 *   get:
 *     summary: Download a specific document file
 *     tags: [Documents]
 *     security:
 *       - bearerAuth: [] # Optional, but required for non-public or unapproved (for admin)
 *     parameters:
 *       - in: path
 *         name: documentId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the document to download
 *     responses:
 *       200:
 *         description: Document file. Content-Type will vary.
 *         content:
 *           application/*: # Represents various file types
 *             schema:
 *               type: string
 *               format: binary
 *       400:
 *         description: Invalid document ID format
 *       401:
 *         description: Authentication required for this document
 *       403:
 *         description: Access denied to this document
 *       404:
 *         description: Document not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.get('/:documentId/download', documentController.downloadDocument);


// Placeholder for DocumentResponse schema (to be defined in Swagger setup or a common schemas file)
// components:
//   schemas:
//     DocumentResponse:
//       type: object
//       properties:
//         id:
//           type: integer
//         title:
//           type: string
//         description:
//           type: string
//         file_name:
//           type: string
//         file_path:
//           type: string
//         uploaded_by:
//           type: integer
//         uploaded_at:
//           type: string
//           format: date-time
//         approved:
//           type: boolean
//         is_public:
//           type: boolean
//         updated_at:
//           type: string
//           format: date-time


module.exports = router;

================
File: backend/src/routes/event.routes.js
================
const express = require('express');
const router = express.Router();
const { verifyToken: authenticateToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin');
const { createEventSchema, listEventsSchema, adminUpdateEventSchema } = require('../validators/event.validator');
const validate = require('../middlewares/validate.middleware'); // Correct import for validate
const eventController = require('../controllers/event.controller');

// GET / (will be /api/events/ when mounted) - List events
router.get(
  '/',
  authenticateToken,
  validate(listEventsSchema), // Correctly wrap schema
  eventController.listEvents
);

// POST / (will be /api/events/ when mounted) - Create a new event (Admin only)
router.post(
  '/',
  authenticateToken,
  isAdmin,
  validate(createEventSchema), // Correctly wrap schema
  eventController.createEvent
);

// PUT /api/events/:id - Update an existing event (Admin only)
router.put(
  '/:id',
  authenticateToken,
  isAdmin,
  validate(adminUpdateEventSchema), // Correctly wrap schema
  eventController.adminUpdateEvent
);

// DELETE /api/events/:id - Delete an event (Admin only)
router.delete(
  '/:id',
  authenticateToken,
  isAdmin,
  eventController.adminDeleteEvent
);

module.exports = router;

================
File: backend/src/routes/user.routes.js
================
const express = require('express');
const router = express.Router();
const userController = require('../controllers/user.controller');
const authMiddleware = require('../middlewares/auth.middleware');
const { updateProfileSchema, changePasswordSchema, validate } = require('../validators/user.validator');

// Route to get the authenticated user's own profile
// GET /api/users/me
router.get(
  '/me',
  authMiddleware.verifyToken, // Protects the route, ensures req.user is populated
  userController.getOwnProfile
);

// Route to update the authenticated user's own profile
// PUT /api/users/me
router.put(
  '/me',
  authMiddleware.verifyToken, // Protects the route
  updateProfileSchema,        // Apply validation rules
  validate,                   // Middleware to handle validation results
  userController.updateOwnProfile
);

// Route to change the authenticated user's own password
// PUT /api/users/me/password
router.put(
  '/me/password',
  authMiddleware.verifyToken,    // Protects the route
  changePasswordSchema,       // Apply validation rules for password change
  validate,                   // Middleware to handle validation results
  userController.changeOwnPassword
);

module.exports = router;

================
File: backend/src/services/announcement.service.js
================
const { Announcement, User, Sequelize } = require('../../models'); // Adjust path if models are not in root/models
const Op = Sequelize.Op; // Get Op from the Sequelize class/constructor
const createDOMPurify = require('dompurify');
const { JSDOM } = require('jsdom');
const auditService = require('./audit.service');

const window = new JSDOM('').window;
const DOMPurify = createDOMPurify(window);

/**
 * Creates a new announcement record in the database.
 * @param {object} announcementData - Data for the new announcement.
 * @param {string} announcementData.title - Title of the announcement.
 * @param {string} announcementData.content - Content of the announcement.
 * @param {string} [announcementData.expiresAt] - Optional expiration date in ISO format.
 * @param {number|string} userId - The ID of the admin user creating the announcement.
 * @returns {Promise<object>} The created announcement object.
 * @throws {Error} If there's an error during database interaction.
 */
async function createAnnouncement(announcementData, userId) {
  try {
    const { title, content, expiresAt } = announcementData;

    const sanitizedContent = DOMPurify.sanitize(content);

    const dataToCreate = {
      title,
      content: sanitizedContent,
      created_by: userId,
    };

    if (expiresAt) {
      dataToCreate.expires_at = expiresAt; // Assuming model field is expires_at
    }
    // Note: The announcement.model.js provided does not have an 'expires_at' field.
    // If it's intended to be stored, the model and migration need to be updated.
    // For now, this code includes it conditionally based on the task description.
    // If 'expiresAt' is not a field in the DB, Sequelize will ignore it or error depending on strictness.

    const newAnnouncement = await Announcement.create(dataToCreate);

    try {
      await auditService.logAdminAction(userId, 'announcement_create', { announcementId: newAnnouncement.id, title: newAnnouncement.title });
    } catch (auditError) {
      console.error('Failed to log admin action for announcement_create:', auditError);
    }

    return newAnnouncement.toJSON(); // Return plain JSON object
  } catch (error) {
    // Log the error for server-side debugging if necessary
    // console.error('Error creating announcement:', error);
    throw error; // Re-throw the error to be handled by the controller
  }
}

/**
 * Lists announcements with pagination, filtering, and sorting.
 * @param {object} options - Options for listing announcements.
 * @param {number} [options.page=1] - The current page number.
 * @param {number} [options.limit=10] - The number of items per page.
 * @param {string} [options.status] - Filter by status (e.g., 'active').
 * @param {string} [options.sortBy='createdAt'] - Field to sort by.
 * @param {string} [options.sortOrder='DESC'] - Sort order ('ASC' or 'DESC').
 * @returns {Promise<object>} An object containing the list of announcements and pagination details.
 * @throws {Error} If there's an error during database interaction.
 */
async function listAnnouncements(options) {
  try {
    const {
      page = 1,
      limit = 10,
      status,
      sortBy = 'createdAt', // Default sort field
      sortOrder = 'DESC', // Default sort order
    } = options;

    // Ensure page and limit are positive integers
    const numPage = parseInt(page, 10);
    const numLimit = parseInt(limit, 10);

    if (isNaN(numPage) || numPage < 1) {
      // Consider throwing a specific error type or handling as per project conventions
      throw new Error('Page number must be a positive integer.');
    }
    if (isNaN(numLimit) || numLimit < 1) {
      throw new Error('Limit must be a positive integer.');
    }

    const offset = (numPage - 1) * numLimit;
    const whereClause = {};

    if (status === 'active') {
      whereClause[Op.or] = [
        { expires_at: { [Op.is]: null } },
        { expires_at: { [Op.gt]: new Date() } },
      ];
    }

    // Validate sortOrder
    const validSortOrder = ['ASC', 'DESC'].includes(sortOrder.toUpperCase()) ? sortOrder.toUpperCase() : 'DESC';
    const orderClause = [[sortBy, validSortOrder]];

    const { count, rows } = await Announcement.findAndCountAll({
      where: whereClause,
      limit: numLimit,
      offset,
      order: orderClause,
      include: [{
        model: User,
        as: 'creator', // This alias must match the association in Announcement model
        attributes: ['id', 'name'], // Specify desired user fields
      }],
      distinct: true, // Important for correct count with include and limit
    });

    return {
      data: rows.map(row => row.toJSON()), // Return plain JSON objects
      totalItems: count,
      totalPages: Math.ceil(count / numLimit),
      currentPage: numPage,
      limit: numLimit,
    };
  } catch (error) {
    // Optional: Log error for server-side debugging
    // console.error('Error listing announcements:', error);
    throw error; // Re-throw the error to be handled by the controller/error middleware
  }
}

/**
 * Updates an existing announcement.
 * @param {number|string} announcementId - The ID of the announcement to update.
 * @param {object} updateData - Data to update the announcement with.
 * @param {string} [updateData.title] - New title for the announcement.
 * @param {string} [updateData.content] - New content for the announcement.
 * @param {string|null} [updateData.expires_at] - New expiration date (ISO format) or null to clear.
 * @param {number|string} adminUserId - The ID of the admin user performing the update.
 * @returns {Promise<object>} The updated announcement object.
 * @throws {Error} If announcement not found (statusCode 404) or other database error.
 */
async function updateAnnouncement(announcementId, updateData, adminUserId) {
  try {
    const announcement = await Announcement.findByPk(announcementId);

    if (!announcement) {
      const error = new Error('Announcement not found');
      error.statusCode = 404;
      throw error;
    }

    const updatedFields = [];
    if (updateData.hasOwnProperty('title') && updateData.title !== announcement.title) {
      announcement.title = updateData.title;
      updatedFields.push('title');
    }
    if (updateData.hasOwnProperty('content')) {
      const sanitizedNewContent = DOMPurify.sanitize(updateData.content);
      if (sanitizedNewContent !== announcement.content) {
        announcement.content = sanitizedNewContent;
        updatedFields.push('content');
      }
    }
    // For expires_at, handle explicit null to clear the date
    if (updateData.hasOwnProperty('expires_at') && updateData.expires_at !== announcement.expires_at) {
      // Ensure null is correctly handled if the current value is a date string or vice-versa
      if (updateData.expires_at === null && announcement.expires_at !== null) {
        announcement.expires_at = null;
        updatedFields.push('expires_at');
      } else if (updateData.expires_at !== null && new Date(updateData.expires_at).toISOString() !== (announcement.expires_at ? new Date(announcement.expires_at).toISOString() : null)) {
        announcement.expires_at = updateData.expires_at; // This can be null or a date string
        updatedFields.push('expires_at');
      }
    }

    if (updatedFields.length > 0) {
      await announcement.save();
      // Audit Log
      try {
        await auditService.logAdminAction(adminUserId, 'announcement_update', { announcementId, updatedFields: updatedFields });
      } catch (auditError) {
        console.error('Failed to log admin action for announcement_update:', auditError);
      }
    }

    return announcement.toJSON();
  } catch (error) {
    // console.error('Error updating announcement:', error);
    throw error;
  }
}

/**
 * Deletes an announcement by its ID.
 * @param {number|string} announcementId - The ID of the announcement to delete.
 * @param {number|string} adminUserId - The ID of the admin user performing the deletion.
 * @returns {Promise<boolean>} True if deletion was successful.
 * @throws {Error} If announcement not found (statusCode 404) or other database error.
 */
async function deleteAnnouncement(announcementId, adminUserId) {
  try {
    const announcement = await Announcement.findByPk(announcementId);

    if (!announcement) {
      const error = new Error('Announcement not found');
      error.statusCode = 404;
      throw error;
    }

    await announcement.destroy();
    // Audit Log
    try {
      await auditService.logAdminAction(adminUserId, 'announcement_delete', { announcementId });
    } catch (auditError) {
      console.error('Failed to log admin action for announcement_delete:', auditError);
    }
    return true; // Or return nothing for a 204 No Content response handling in controller
  } catch (error) {
    // console.error('Error deleting announcement:', error);
    throw error;
  }
}

module.exports = {
  createAnnouncement,
  listAnnouncements,
  updateAnnouncement,
  deleteAnnouncement,
};

================
File: backend/src/services/audit.service.js
================
'use strict';

const { AuditLog, User } = require('../../models'); // Adjust path as necessary if models/index.js is elsewhere
const { Op } = require('sequelize');

/**
 * Logs an administrative action to the audit_logs table.
 * @param {number} adminId - The ID of the admin user performing the action.
 * @param {string} action - A string describing the action (e.g., 'user_update', 'document_delete').
 * @param {object|string} [details] - Optional details about the action, can be an object or a pre-formatted string.
 */
async function logAdminAction(adminId, action, details) {
  try {
    let detailsToStore = details;
    if (details && typeof details === 'object') {
      // Assuming the 'details' column in the database is TEXT, we need to stringify.
      // If it's a JSON/JSONB type, stringification might not be needed or handled by Sequelize.
      detailsToStore = JSON.stringify(details);
    }

    await AuditLog.create({
      admin_id: adminId,
      action: action,
      details: detailsToStore,
      // created_at is handled by defaultValue in the model/database
    });
  } catch (error) {
    console.error('Failed to log admin action:', {
      adminId,
      action,
      details,
      error: error.message,
    });
    // Do not let audit logging failure block the main operation.
    // Depending on requirements, you might want to notify an admin or use a more robust logging system here.
  }
}

async function getAuditLogs(options) {
  const offset = (options.page - 1) * options.limit;

  const { count, rows } = await AuditLog.findAndCountAll({
    include: [{
      model: User,
      as: 'adminUser', // Ensure this alias matches the association in AuditLog model
      attributes: ['id', 'name', 'username'], // Select only needed user fields
    }],
    order: [['created_at', 'DESC']],
    limit: options.limit,
    offset: offset,
  });

  const formattedLogs = rows.map(log => {
    let parsedDetails = log.details;
    if (typeof log.details === 'string') {
      try {
        parsedDetails = JSON.parse(log.details);
      } catch (e) {
        // Keep as string if not valid JSON, or handle error
        // console.error('Failed to parse audit log details:', e);
      }
    }
    return {
      id: log.id,
      admin_name: log.adminUser ? (log.adminUser.name || log.adminUser.username) : 'N/A',
      action: log.action,
      details: parsedDetails,
      created_at: log.created_at,
    };
  });

  const totalPages = Math.ceil(count / options.limit);

  return {
    data: formattedLogs,
    pagination: {
      totalItems: count,
      totalPages,
      currentPage: options.page,
      limit: options.limit,
    },
  };
}

module.exports = {
  logAdminAction,
  getAuditLogs,
};

================
File: backend/src/services/auth.service.js
================
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { User, VerificationToken } = require('../../models'); // Adjust path as necessary if models are not in root/models
const { v4: uuidv4 } = require('uuid');
const crypto = require('crypto'); // For a more secure plain token, though UUIDv4 is generally good.

/**
 * Registers a new user.
 * @param {object} userData - User data including name, email, and password.
 * @returns {Promise<object>} The created user object or throws an error.
 */
async function registerUser(userData) {
  const { name, email, password } = userData;

  // Check if email already exists
  const existingUser = await User.findOne({ where: { email } });
  if (existingUser) {
    const error = new Error('Email already registered.');
    error.statusCode = 409; // Conflict
    throw error;
  }

  // Hash password
  const hashedPassword = await bcrypt.hash(password, 10); // Salt rounds: 10

  // Create user
  // role defaults to 'member' and status to 'pending' as per model definition
  const newUser = await User.create({
    name,
    email,
    password: hashedPassword,
    // email_verified and is_system_user will use their default values from the model
  });

  // Exclude password from the returned user object
  const userJson = newUser.toJSON();
  delete userJson.password;
  return userJson;
}

/**
 * Logs in an existing user.
 * @param {object} loginData - User login data including email and password.
 * @returns {Promise<object>} An object containing the JWT and user details (excluding password).
 * @throws {Error} If authentication fails or account is not approved.
 */
async function loginUser(loginData) {
  const { email, password } = loginData;

  const user = await User.findOne({ where: { email } });
  if (!user) {
    const error = new Error('Invalid email or password.');
    error.statusCode = 401; // Unauthorized
    throw error;
  }

  const isPasswordValid = await bcrypt.compare(password, user.password);
  if (!isPasswordValid) {
    const error = new Error('Invalid email or password.');
    error.statusCode = 401; // Unauthorized
    throw error;
  }

  if (user.status !== 'approved') {
    let message = 'Account access denied.';
    if (user.status === 'pending') {
      message = 'Account pending approval.';
    } else if (user.status === 'rejected') {
      message = 'Your account has been rejected.';
    }
    const error = new Error(message);
    error.statusCode = 403; // Forbidden
    throw error;
  }

  // Generate JWT
  const tokenPayload = {
    userId: user.id,
    role: user.role,
  };

  const token = jwt.sign(tokenPayload, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || '1h', // Default to 1 hour
  });

  // Exclude password from the returned user object
  const userJson = user.toJSON();
  delete userJson.password;

  return {
    token,
    user: userJson,
  };
}

/**
 * Requests a password reset token for a user.
 * @param {string} email - The user's email address.
 * @returns {Promise<void>}
 * @throws {Error} If email is not found, user is not active, or other issues occur.
 */
async function requestPasswordReset(email) {
  const user = await User.findOne({ where: { email } });

  if (!user) {
    const error = new Error('Email not found.');
    error.statusCode = 404;
    throw error;
  }

  if (user.status !== 'approved') {
    const error = new Error('User account is not active or eligible for password reset.');
    error.statusCode = 400;
    throw error;
  }

  // Generate a unique token
  const plainToken = uuidv4(); // Or crypto.randomBytes(32).toString('hex');
  const hashedToken = await bcrypt.hash(plainToken, 10);

  // Set token expiry (e.g., 1 hour from now)
  const expiresAt = new Date();
  expiresAt.setHours(expiresAt.getHours() + 1);

  // Store the verification token
  await VerificationToken.create({
    userId: user.id,
    token: hashedToken,
    type: 'password_reset',
    expiresAt,
  });

  // Prepare email content (log instead of sending)
  const resetLink = `https://your-frontend-domain.com/reset-password?token=${plainToken}`;
  const emailContent = {
    to: user.email,
    subject: 'Password Reset Request',
    body: `
      <p>Hello ${user.name},</p>
      <p>You requested a password reset. Please click the link below to reset your password:</p>
      <p><a href="${resetLink}">${resetLink}</a></p>
      <p>This link will expire in 1 hour.</p>
      <p>If you did not request a password reset, please ignore this email.</p>
    `,
  };

  console.log('--- Password Reset Email ---');
  console.log(`Recipient: ${emailContent.to}`);
  console.log(`Subject: ${emailContent.subject}`);
  console.log(`Body: ${emailContent.body}`);
  console.log('-----------------------------');
}

/**
 * Verifies a password reset token.
 * @param {string} token - The password reset token from the query parameter.
 * @returns {Promise<boolean>} True if the token is valid.
 * @throws {Error} If the token is invalid, expired, or not found.
 */
async function verifyPasswordResetToken(token) {
  if (!token) {
    const error = new Error('Invalid or expired password reset token.');
    error.statusCode = 400; // Bad Request
    throw error;
  }

  // Find all non-expired password_reset tokens
  const potentialTokens = await VerificationToken.findAll({
    where: {
      type: 'password_reset',
      expiresAt: {
        [require('sequelize').Op.gt]: new Date(), // Check if expiresAt is greater than current time
      },
    },
    include: [{ model: User, attributes: ['id', 'email'] }], // Optional: include user for context
  });

  let isValidToken = false;
  let matchedUser = null;

  for (const vt of potentialTokens) {
    const isMatch = await bcrypt.compare(token, vt.token);
    if (isMatch) {
      isValidToken = true;
      matchedUser = vt.User; // Store user if needed for further steps (e.g. actual reset)
      // Optionally, delete the token after successful verification to prevent reuse
      // await vt.destroy();
      break;
    }
  }

  if (!isValidToken) {
    const error = new Error('Invalid or expired password reset token.');
    // Determine if 404 (not found) or 400 (bad request, e.g. expired)
    // For simplicity, using 400 for all invalid/expired cases here.
    error.statusCode = 400;
    throw error;
  }

  // If you need to return user details or a specific message:
  // return { message: "Token is valid.", userId: matchedUser.id };
  return true; // Or simply return true/false
}

/**
 * Resets a user's password using a valid token.
 * @param {string} token - The password reset token.
 * @param {string} newPassword - The new password.
 * @returns {Promise<void>}
 * @throws {Error} If token is invalid, password complexity fails, or other issues.
 */
async function resetPassword(token, newPassword) {
  if (!token || !newPassword) {
    const error = new Error('Token and newPassword are required.');
    error.statusCode = 400;
    throw error;
  }

  // Password complexity is handled by Joi validator, but can be double-checked here if desired.
  // For this implementation, we assume Joi validation has passed if this function is reached.

  // Find all non-expired password_reset tokens
  const potentialTokens = await VerificationToken.findAll({
    where: {
      type: 'password_reset',
      expiresAt: {
        [require('sequelize').Op.gt]: new Date(),
      },
    },
  });

  let validVerificationToken = null;
  for (const vt of potentialTokens) {
    const isMatch = await bcrypt.compare(token, vt.token);
    if (isMatch) {
      validVerificationToken = vt;
      break;
    }
  }

  if (!validVerificationToken) {
    const error = new Error('Invalid or expired password reset token.');
    error.statusCode = 400;
    throw error;
  }

  const user = await User.findByPk(validVerificationToken.userId);
  if (!user) {
    // This case should ideally not happen if token integrity is maintained
    const error = new Error('User associated with token not found.');
    error.statusCode = 500; // Internal server error, as this indicates data inconsistency
    throw error;
  }

  // Hash the new password
  const hashedPassword = await bcrypt.hash(newPassword, 10);

  // Update user's password
  user.password = hashedPassword;
  await user.save();

  // Invalidate/delete the token
  await validVerificationToken.destroy();

  // Log the event (basic console log for now)
  console.log(`Password reset successfully for user ID: ${user.id}`);

  // Optional: Invalidate other active sessions (future enhancement)
}


module.exports = {
  registerUser,
  loginUser,
  requestPasswordReset,
  verifyPasswordResetToken,
  resetPassword,
};

================
File: backend/src/services/config.service.js
================
const { Config } = require('../../models'); // Assuming index.js in models exports Config
const auditService = require('./audit.service');
// const ApiError = require('../utils/ApiError'); // Not strictly needed for this service based on current plan

const getAllConfigs = async () => {
  const configs = await Config.findAll();
  const configObject = {};
  configs.forEach(item => {
    configObject[item.key] = item.value;
  });
  return configObject;
};

const upsertConfig = async (key, value, adminUserId) => {
  const [configItem, created] = await Config.upsert({ key, value });
  // In Sequelize, 'upsert' might not return the instance directly in all dialects or versions.
  // It often returns [instance, created] or just a boolean indicating creation.
  // For simplicity and consistency, we'll return the input key/value.
  // If the actual instance data (like timestamps) is needed, a findOrCreate or separate find would be better.

  try {
    await auditService.logAdminAction(adminUserId, 'config_update', { configKey: key, newValue: value });
  } catch (auditError) {
    console.error('Failed to log admin action for config_update:', auditError);
  }
  
  // Return the data that was upserted, as the direct return from upsert can vary.
  return { key, value };
};

module.exports = {
  getAllConfigs,
  upsertConfig,
};

================
File: backend/src/services/discussion.service.js
================
const { Discussion, User, sequelize } = require('../../models'); // Assuming User model is in the same directory
const { Op, fn, col } = require('sequelize');
const createDOMPurify = require('dompurify');
const { JSDOM } = require('jsdom');
const ApiError = require('../utils/ApiError'); // Assuming ApiError utility
const auditService = require('./audit.service');

const window = new JSDOM('').window;
const DOMPurify = createDOMPurify(window);

/**
 * Create a discussion thread
 * @param {Object} threadData
 * @param {ObjectId} userId
 * @returns {Promise<Discussion>}
 */
const createThread = async (threadData, userId) => {
  const sanitizedContent = DOMPurify.sanitize(threadData.content);
  const thread = await Discussion.create({
    title: threadData.title,
    content: sanitizedContent,
    user_id: userId,
    parent_id: null,
  });
  return thread;
};

/**
 * Create a reply to a discussion thread
 * @param {Object} replyData
 * @param {ObjectId} threadId
 * @param {ObjectId} userId
 * @returns {Promise<Discussion>}
 */
const createReply = async (replyData, threadId, userId) => {
  const sanitizedContent = DOMPurify.sanitize(replyData.content);

  const parentThread = await Discussion.findOne({ where: { id: threadId, parent_id: null } });
  if (!parentThread) {
    throw new ApiError(404, 'Parent thread not found or is not a main thread');
  }

  const reply = await Discussion.create({
    content: sanitizedContent,
    user_id: userId,
    parent_id: threadId,
    title: null, // Replies don't have titles
  });
  return reply;
};

/**
 * List all main discussion threads with author and reply count
 * @param {Object} options - Query options
 * @param {number} [options.page=1] - Current page
 * @param {number} [options.limit=10] - Maximum number of results per page
 * @returns {Promise<Object>} - Paginated list of thread objects
 */
const listThreads = async (options) => {
  const page = parseInt(options.page, 10) || 1;
  const limit = parseInt(options.limit, 10) || 10;
  const offset = (page - 1) * limit;

  const { count, rows } = await Discussion.findAndCountAll({
    where: { parent_id: null },
    order: [['created_at', 'DESC']],
    limit,
    offset,
    include: [
      {
        model: User,
        as: 'author',
        attributes: ['id', 'name'],
      },
    ],
    attributes: [
      'id',
      'title',
      'content',
      'created_at',
      [
        sequelize.literal(`(
          SELECT COUNT(*)
          FROM discussions AS reply
          WHERE
            reply.parent_id = discussions.id
        )`),
        'reply_count'
      ]
    ],
    distinct: true, // Important for correct count with includes
  });

  const threads = rows.map(thread => ({
    id: thread.id,
    title: thread.title,
    content: thread.content, // Consider snippet vs full content based on requirements
    created_at: thread.created_at,
    author: thread.author ? { id: thread.author.id, name: thread.author.name } : null,
    reply_count: parseInt(thread.get('reply_count'), 10) || 0,
  }));

  return {
    totalItems: count,
    totalPages: Math.ceil(count / limit),
    currentPage: page,
    threads,
  };
};

/**
 * View a specific thread along with all its replies
 * @param {ObjectId} threadId
 * @returns {Promise<Object|null>} - Thread object with replies, or null if not found
 */
const viewThread = async (threadId) => {
  const mainThread = await Discussion.findOne({
    where: { id: threadId, parent_id: null },
    include: [
      {
        model: User,
        as: 'author',
        attributes: ['id', 'name'],
      },
    ],
  });

  if (!mainThread) {
    return null; // Or throw ApiError(httpStatus.NOT_FOUND, 'Thread not found or is not a main thread');
  }

  const replies = await Discussion.findAll({
    where: { parent_id: threadId },
    order: [['created_at', 'ASC']],
    include: [
      {
        model: User,
        as: 'author',
        attributes: ['id', 'name'],
      },
    ],
  });

  return {
    mainThread: {
      id: mainThread.id,
      title: mainThread.title,
      content: mainThread.content,
      created_at: mainThread.created_at,
      author: mainThread.author ? { id: mainThread.author.id, name: mainThread.author.name } : null,
    },
    replies: replies.map(reply => ({
      id: reply.id,
      content: reply.content,
      created_at: reply.created_at,
      author: reply.author ? { id: reply.author.id, name: reply.author.name } : null,
    })),
  };
};


/**
 * Delete a discussion thread
 * @param {ObjectId} threadId
 * @param {ObjectId} adminUserId
 * @returns {Promise<void>}
 */
const deleteThread = async (threadId, adminUserId) => {
  const thread = await Discussion.findOne({ where: { id: threadId, parent_id: null } });
  if (!thread) {
    throw new ApiError(404, 'Discussion thread not found or is not a main thread');
  }
  const threadTitle = thread.title; // Store title before destroying
  await thread.destroy();
  // eslint-disable-next-line no-console
  // console.log(`Audit: Admin User ID ${adminUserId} deleted discussion thread ID ${threadId} titled '${thread.title}'`);
  try {
    await auditService.logAdminAction(adminUserId, 'discussion_thread_delete', { threadId, title: threadTitle });
  } catch (auditError) {
    console.error('Failed to log admin action for discussion_thread_delete:', auditError);
  }
};

/**
 * Delete a discussion reply
 * @param {ObjectId} replyId
 * @param {ObjectId} adminUserId
 * @returns {Promise<void>}
 */
const deleteReply = async (replyId, adminUserId) => {
  const reply = await Discussion.findOne({ where: { id: replyId, parent_id: { [Op.ne]: null } } });
  if (!reply) {
    throw new ApiError(404, 'Discussion reply not found or is not a reply');
  }
  await reply.destroy();
  // eslint-disable-next-line no-console
  // console.log(`Audit: Admin User ID ${adminUserId} deleted discussion reply ID ${replyId}`);
  try {
    await auditService.logAdminAction(adminUserId, 'discussion_reply_delete', { replyId });
  } catch (auditError) {
    console.error('Failed to log admin action for discussion_reply_delete:', auditError);
  }
};

module.exports = {
  createThread,
  createReply,
  listThreads,
  viewThread,
  deleteThread,
  deleteReply,
};

================
File: backend/src/services/document.service.js
================
const { Document, User, sequelize } = require('../../models'); // Adjust path if models are not in root/models
const { Op } = require('sequelize');
const fs = require('fs').promises;
const path = require('path');
const ApiError = require('../utils/ApiError');
const auditService = require('./audit.service');

/**
 * Creates a new document record in the database.
 * @param {object} documentData - Data for the new document.
 * @param {string} documentData.title - Title of the document.
 * @param {string} [documentData.description] - Optional description.
 * @param {string} documentData.originalFileName - The original name of the uploaded file (from Multer's `req.file.originalname`).
 * @param {string} documentData.storedFileName - The unique name of the file as stored on the server (from Multer's `req.file.filename`).
 * @param {string} documentData.filePath - The path to the file on the server.
 * @param {number} documentData.uploadedBy - The ID of the user who uploaded the document.
 * @param {boolean} documentData.isPublic - Whether the document is public.
 * @returns {Promise<object>} The created document object.
 */
async function createDocument(documentData) {
  const {
    title,
    description,
    originalFileName,
    storedFileName, // This is req.file.filename from Multer
    filePath,       // This is req.file.path from Multer
    uploadedBy,
    isPublic,
  } = documentData;

  // Determine 'approved' status based on 'is_public' as per plan
  const approved = !!isPublic; // Converts boolean isPublic to 0 or 1 if DB expects integer, or true/false

  const newDocument = await Document.create({
    title,
    description: description || null, // Ensure null if empty, or handle in model
    file_name: storedFileName, // This is the unique name for storage
    original_file_name: originalFileName, // Added to store the original filename
    file_path: filePath,       // Full path to the file on server
    uploaded_by: uploadedBy,
    is_public: isPublic,
    approved: approved,
    // uploaded_at will be set by Sequelize's `createdAt`
  });

  try {
    await auditService.logAdminAction(uploadedBy, 'document_upload', { documentId: newDocument.id, originalName: newDocument.original_file_name, uploaderUserId: uploadedBy });
  } catch (auditError) {
    console.error('Failed to log admin action for document_upload:', auditError);
  }

  return newDocument.toJSON(); // Return plain JSON object
}

/**
 * Lists documents based on user authentication and role.
 * @param {object} [user] - Optional user object (from req.user).
 * @param {object} options - Pagination options { limit, offset }.
 * @returns {Promise<object>} An object containing the list of documents and count.
 */
async function listDocuments(user, { limit = 10, offset = 0 }) {
  const whereClause = {};
  const includeClause = [{
    model: User,
    as: 'uploader',
    attributes: ['id', 'name'] // Only include uploader's ID and name
  }];

  if (!user) { // Guest user
    whereClause.is_public = true;
    whereClause.approved = true;
  } else if (user.role === 'admin') {
    // Admin sees all documents
  } else { // Authenticated member
    whereClause.approved = true;
    // Members see all approved documents (public and non-public)
  }

  const { count, rows } = await Document.findAndCountAll({
    where: whereClause,
    include: includeClause,
    limit: parseInt(limit, 10),
    offset: parseInt(offset, 10),
    order: [['uploaded_at', 'DESC']],
    attributes: { exclude: ['uploaded_by'] } // Exclude direct foreign key, use include for uploader info
  });

  return { count, documents: rows };
}

/**
 * Retrieves a specific document's metadata by ID, respecting access permissions.
 * @param {number} documentId - The ID of the document.
 * @param {object} [user] - Optional user object (from req.user).
 * @returns {Promise<object|null>} The document metadata or null if not found/not allowed.
 */
async function getDocumentMetadataById(documentId, user) {
  const document = await Document.findByPk(documentId, {
    include: [{
      model: User,
      as: 'uploader',
      attributes: ['id', 'name']
    }],
    attributes: { exclude: ['uploaded_by'] }
  });

  if (!document) {
    const error = new Error('Document not found.');
    error.statusCode = 404;
    throw error;
  }

  // Access Control
  if (!user) { // Guest
    if (!document.is_public || !document.approved) {
      const error = new Error('Access denied to this document.');
      error.statusCode = 403;
      throw error;
    }
  } else if (user.role !== 'admin') { // Member
    if (!document.approved) {
      const error = new Error('Access denied to this document.');
      error.statusCode = 403;
      throw error;
    }
    // Members can see all approved documents (public or not)
    // If a document is approved, a member can see it.
    // If it's also public, a guest can see it.
    // If it's not public but approved, only members and admins can see it.
    // This logic seems correct.
  }
  // Admin can see everything, no explicit check needed here if previous conditions handle others.

  return document.toJSON();
}

/**
 * Retrieves a document for download, checking permissions.
 * @param {number} documentId - The ID of the document.
 * @param {object} [user] - Optional user object (from req.user).
 * @returns {Promise<object|null>} The document object if download is permitted, otherwise null or throws error.
 * @throws {Error} If access is denied with a specific status code.
 */
async function getDocumentForDownload(documentId, user) {
  const document = await Document.findByPk(documentId);

  if (!document) {
    const error = new Error('Document not found.');
    error.statusCode = 404;
    throw error;
  }

  // Access Control based on download_document.php logic (User Story 9)
  // 1. If document approved != 1 AND user is not 'admin': Deny access (403).
  // 2. If document is_public != 1 AND user is not authenticated: Deny access (401/403).
  // 3. Otherwise, allow download.

  if (!document.approved && (!user || user.role !== 'admin')) {
    const error = new Error('Access Denied: Document not approved for download.');
    error.statusCode = 403;
    throw error;
  }

  if (!document.is_public && !user) {
    const error = new Error('Access Denied: Authentication required to download this document.');
    error.statusCode = 401; // Or 403, 401 is more specific for "auth required"
    throw error;
  }

  // If all checks pass, return the document object (contains file_path, file_name)
  return document.toJSON();
}


/**
 * Approves a document by its ID.
 * @param {number} documentId - The ID of the document to approve.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<object>} The updated document object.
 * @throws {ApiError} If the document is not found.
 */
async function approveDocumentById(documentId, adminUserId) {
  const document = await Document.findByPk(documentId);

  if (!document) {
    throw new ApiError(404, 'Document not found');
  }

  document.approved = true;
  await document.save();

  try {
    await auditService.logAdminAction(adminUserId, 'document_approve', { documentId });
  } catch (auditError) {
    console.error('Failed to log admin action for document_approve:', auditError);
  }

  return document.toJSON();
}

/**
 * Deletes a document by its ID.
 * This includes deleting the physical file if it exists.
 * @param {number} documentId - The ID of the document to delete.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<boolean>} True if deletion was successful.
 * @throws {ApiError} If the document is not found.
 */
async function deleteDocumentById(documentId, adminUserId) {
  const document = await Document.findByPk(documentId);

  if (!document) {
    throw new ApiError(404, 'Document not found');
  }

  if (document.file_path) {
    // document.file_path is expected to be an absolute path from Multer (req.file.path).
    try {
      await fs.unlink(document.file_path);
      console.log(`Successfully deleted physical file: ${document.file_path}`);
    } catch (err) {
      console.error(`Error deleting physical file ${document.file_path}: `, err);
      // Log error but proceed with DB deletion as per requirements.
    }
  }

  await document.destroy();
  try {
    await auditService.logAdminAction(adminUserId, 'document_delete', { documentId });
  } catch (auditError) {
    console.error('Failed to log admin action for document_delete:', auditError);
  }

  return true;
}


module.exports = {
  createDocument,
  listDocuments,
  getDocumentMetadataById,
  getDocumentForDownload,
  approveDocumentById,
  deleteDocumentById,
};

================
File: backend/src/services/event.service.js
================
const { Event, User, sequelize } = require('../../models');
const { Op } = require('sequelize');
const auditService = require('./audit.service');

const getAllEvents = async (queryParams) => {
  const {
    status = 'upcoming', // Default status
    page = 1,
    limit = 10,
    sortBy = 'event_date', // Default sort by event_date (which is start_date in model)
    sortOrder: initialSortOrder, // Will be determined based on sortBy and status
  } = queryParams;

  // Determine default sortOrder based on sortBy and status
  let sortOrder = initialSortOrder;
  if (!sortOrder) {
    if (sortBy === 'event_date') {
      sortOrder = status === 'past' ? 'DESC' : 'ASC';
    } else if (sortBy === 'created_at') {
      sortOrder = 'DESC';
    } else { // title
      sortOrder = 'ASC';
    }
  }

  const offset = (page - 1) * limit;

  const whereClause = {};
  const now = new Date();

  if (status === 'upcoming') {
    whereClause.start_date = { [Op.gt]: now };
  } else if (status === 'past') {
    whereClause.start_date = { [Op.lte]: now };
  }
  
  // Adjust sortBy to match model field name if 'event_date' is used
  const actualSortBy = sortBy === 'event_date' ? 'start_date' : sortBy;

  try {
    const { count, rows } = await Event.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
      ],
      order: [[actualSortBy, sortOrder.toUpperCase()]],
      limit,
      offset,
      distinct: true, // Important for correct count with includes
    });

    const totalItems = count;
    const totalPages = Math.ceil(totalItems / limit);
    const hasNextPage = page < totalPages;
    const hasPrevPage = page > 1;

    // Map to desired response structure, especially event_date
    const formattedEvents = rows.map(event => ({
      id: event.id,
      title: event.title,
      description: event.description,
      event_date: event.start_date, // Map start_date to event_date
      end_date: event.end_date, // Add end_date to the response
      location: event.location,
      created_by: event.creator ? { id: event.creator.id, name: event.creator.name } : null,
      created_at: event.created_at,
      updated_at: event.updated_at,
    }));


    return {
      data: formattedEvents,
      pagination: {
        totalItems,
        totalPages,
        currentPage: parseInt(page, 10),
        limit: parseInt(limit, 10),
        hasNextPage,
        hasPrevPage,
      },
    };
  } catch (error) {
    console.error('Error fetching events:', error);
    throw new Error('Error fetching events from database.');
  }
};

const updateEvent = async (eventId, updateData, adminUserId) => {
  try {
    const event = await Event.findByPk(eventId);
    if (!event) {
      const error = new Error('Event not found');
      error.statusCode = 404;
      throw error;
    }

    // Validate start_date and end_date
    const { start_date, end_date, ...otherUpdateData } = updateData;
    let validatedStartDate = event.start_date;
    let validatedEndDate = event.end_date;

    if (start_date !== undefined) {
      validatedStartDate = new Date(start_date);
    }
    if (end_date !== undefined) {
      validatedEndDate = new Date(end_date);
    }

    // If both dates are present (either from input or existing event data), validate them
    if (validatedStartDate && validatedEndDate && validatedEndDate <= validatedStartDate) {
      const error = new Error('End date must be after start date.');
      error.statusCode = 400; // Bad Request
      throw error;
    }
    
    // Prepare fields for update, only including those provided in updateData
    const fieldsToUpdate = {};
    if (updateData.title !== undefined) fieldsToUpdate.title = updateData.title;
    if (updateData.description !== undefined) fieldsToUpdate.description = updateData.description;
    if (start_date !== undefined) fieldsToUpdate.start_date = validatedStartDate;
    if (end_date !== undefined) fieldsToUpdate.end_date = validatedEndDate;
    if (updateData.location !== undefined) fieldsToUpdate.location = updateData.location;


    // Only update if there are fields to update
    if (Object.keys(fieldsToUpdate).length > 0) {
        await event.update(fieldsToUpdate);
    }
    
    // Audit Logging
    try {
      await auditService.logAdminAction(adminUserId, 'event_update', { eventId, updatedFields: Object.keys(fieldsToUpdate) });
    } catch (auditError) {
      console.error('Failed to log admin action for event_update:', auditError);
    }

    // Fetch the updated event with creator info to match getAllEvents structure
    const updatedEventWithCreator = await Event.findByPk(eventId, {
      include: [
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
      ],
    });
    
    return {
        id: updatedEventWithCreator.id,
        title: updatedEventWithCreator.title,
        description: updatedEventWithCreator.description,
        event_date: updatedEventWithCreator.start_date, // Map start_date to event_date
        end_date: updatedEventWithCreator.end_date,
        location: updatedEventWithCreator.location,
        created_by: updatedEventWithCreator.creator ? { id: updatedEventWithCreator.creator.id, name: updatedEventWithCreator.creator.name } : null,
        created_at: updatedEventWithCreator.created_at,
        updated_at: updatedEventWithCreator.updated_at,
      };

  } catch (error) {
    console.error(`Error updating event ${eventId}:`, error);
    if (!error.statusCode) { // Default to 500 if no specific status code is set
        error.statusCode = 500;
        error.message = 'Error updating event in database.';
    }
    throw error;
  }
};

const deleteEvent = async (eventId, adminUserId) => {
  try {
    const event = await Event.findByPk(eventId);
    if (!event) {
      const error = new Error('Event not found');
      error.statusCode = 404;
      throw error;
    }

    await event.destroy();

    // Audit Logging
    try {
      await auditService.logAdminAction(adminUserId, 'event_delete', { eventId });
    } catch (auditError) {
      console.error('Failed to log admin action for event_delete:', auditError);
    }

  } catch (error) {
    console.error(`Error deleting event ${eventId}:`, error);
    if (!error.statusCode) { // Default to 500 if no specific status code is set
        error.statusCode = 500;
        error.message = 'Error deleting event from database.';
    }
    throw error;
  }
};


const createEvent = async (eventData, adminUserId) => {
  const { title, description, event_date, location } = eventData;

  try {
    // Assumption: event_date from request maps to start_date.
    // Assumption: end_date is set to start_date as it's NOT NULL in DB but not in US14 request.
    const newEventRecord = await Event.create({
      title,
      description,
      start_date: event_date,
      end_date: event_date, // Setting end_date same as start_date
      location,
      created_by: adminUserId,
    });

    // Audit Logging
    try {
      await auditService.logAdminAction(adminUserId, 'event_create', { eventId: newEventRecord.id, title: newEventRecord.title });
    } catch (auditError) {
      console.error('Failed to log admin action for event_create:', auditError);
    }

    // Fetch the event again to include creator details for a consistent response structure
    const populatedEvent = await Event.findByPk(newEventRecord.id, {
      include: [
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
      ],
    });

    // Format the response to match the User Story and other event service responses
    return {
      id: populatedEvent.id,
      title: populatedEvent.title,
      description: populatedEvent.description,
      event_date: populatedEvent.start_date, // Map start_date back to event_date for response
      end_date: populatedEvent.end_date, // Add end_date to the response
      location: populatedEvent.location,
      created_by: populatedEvent.creator ? { id: populatedEvent.creator.id, name: populatedEvent.creator.name } : null,
      createdAt: populatedEvent.created_at,
      updatedAt: populatedEvent.updated_at,
    };

  } catch (error) {
    console.error(`Error creating event:`, error);
    // Allowing Sequelize validation errors to propagate with their structure,
    // or re-throwing a generic error for other DB issues.
    if (error.name === 'SequelizeValidationError' || error.name === 'SequelizeUniqueConstraintError') {
        const simplifiedErrors = error.errors.map(e => ({ message: e.message, path: e.path }));
        const err = new Error('Validation failed or constraint violation.');
        err.statusCode = 400; // Bad Request
        err.errors = simplifiedErrors;
        throw err;
    }
    
    const serviceError = new Error('Error creating event in database.');
    serviceError.statusCode = error.statusCode || 500;
    throw serviceError;
  }
};

module.exports = {
  getAllEvents,
  updateEvent,
  deleteEvent,
  createEvent,
};

================
File: backend/src/services/user.service.js
================
const fs = require('fs');
const path = require('path');
const { User, Document, sequelize } = require('../../models'); // Adjust path as necessary
const { Op } = require('sequelize');
const bcrypt = require('bcrypt');
const ApiError = require('../utils/ApiError'); // Added for custom error handling
const auditService = require('./audit.service');

/**
 * Selects and returns publicly safe user profile fields.
 * @param {Object} user - The Sequelize user object.
 * @returns {Object} - An object containing safe user profile fields.
 */
const selectUserProfileFields = (user) => {
  if (!user) {
    return null;
  }
  return {
    id: user.id,
    name: user.name,
    email: user.email,
    role: user.role,
    status: user.status,
    created_at: user.created_at,
    updated_at: user.updated_at,
  };
};

/**
 * Fetches the profile of the currently authenticated user.
 * @param {number} userId - The ID of the user.
 * @returns {Promise<Object|null>} - The user profile or null if not found.
 */
const fetchOwnProfile = async (userId) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      return null; // Or throw an error to be caught by the controller
    }
    return selectUserProfileFields(user);
  } catch (error) {
    console.error('Error fetching own profile:', error);
    throw error;
  }
};

/**
 * Modifies the profile of the currently authenticated user.
 * @param {number} userId - The ID of the user.
 * @param {Object} updateData - The data to update (e.g., { name: "New Name" }).
 * @returns {Promise<Object|null>} - The updated user profile or null if user not found.
 */
const modifyOwnProfile = async (userId, updateData) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      return null; // Or throw an error
    }

    // Only allow 'name' to be updated for now
    if (updateData.name !== undefined) {
      // Basic validation: ensure name is not empty if provided
      if (typeof updateData.name !== 'string' || updateData.name.trim() === '') {
        const error = new Error('Name cannot be empty.');
        error.isValidationError = true; // Custom flag for validation errors
        error.field = 'name';
        throw error;
      }
      user.name = updateData.name.trim();
    }

    // Potentially add more updatable fields here in the future,
    // ensuring proper validation for each.
    // For example:
    // if (updateData.bio !== undefined) {
    //   user.bio = updateData.bio;
    // }

    await user.save();
    return selectUserProfileFields(user);
  } catch (error) {
    console.error('Error modifying own profile:', error);
    throw error;
  }
};

/**
 * Updates the password for the currently authenticated user.
 * @param {number} userId - The ID of the user.
 * @param {string} currentPassword - The user's current password.
 * @param {string} newPassword - The new password to set.
 * @returns {Promise<void>}
 * @throws {Error} - Throws error if user not found, current password incorrect, or new password invalid.
 */
const updateOwnPassword = async (userId, currentPassword, newPassword) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      const error = new Error('User not found.');
      error.statusCode = 404; // Or handle as per your app's error strategy
      throw error;
    }

    const isMatch = await bcrypt.compare(currentPassword, user.password);
    if (!isMatch) {
      const error = new Error('Incorrect current password.');
      error.statusCode = 403; // Forbidden
      throw error;
    }

    // Password complexity validation is handled by express-validator,
    // but a service-level check could be added here if desired for extra safety
    // or if the service is used outside of a validated controller context.

    const salt = await bcrypt.genSalt(10);
    user.password = await bcrypt.hash(newPassword, salt);
    await user.save();

  } catch (error) {
    console.error('Error updating own password:', error);
    // Re-throw with a more generic message or specific status code if needed
    if (!error.statusCode) {
        // Default to a server error if not already set
        const serviceError = new Error('Could not update password.');
        serviceError.statusCode = error.isValidationError ? 400 : 500; // Keep 400 for validation
        throw serviceError;
    }
    throw error;
  }
};


/**
 * Lists non-system users with pagination.
 * @param {Object} options - Pagination options.
 * @param {number} [options.limit=10] - Number of users to fetch.
 * @param {number} [options.offset=0] - Number of users to skip.
 * @returns {Promise<Object>} - An object containing 'rows' (users) and 'count' (total non-system users).
 */
const listNonSystemUsers = async ({ limit = 10, offset = 0 }) => {
  try {
    const { count, rows } = await User.findAndCountAll({
      where: {
        is_system_user: false,
      },
      attributes: {
        exclude: ['password'],
        include: ['id', 'name', 'email', 'role', 'status', 'created_at', 'updated_at'],
      },
      limit: parseInt(limit, 10),
      offset: parseInt(offset, 10),
      order: [['created_at', 'DESC']],
    });
    return { rows: rows.map(selectUserProfileFields), count };
  } catch (error) {
    console.error('Error listing non-system users:', error);
    throw error;
  }
};

/**
 * Retrieves a single non-system user by their ID.
 * @param {number} userId - The ID of the user to retrieve.
 * @returns {Promise<Object|null>} - The user object or null if not found or is a system user.
 */
const getNonSystemUserById = async (userId) => {
  try {
    const user = await User.findOne({
      where: {
        id: userId,
        is_system_user: false,
      },
      attributes: {
        exclude: ['password'],
        include: ['id', 'name', 'email', 'role', 'status', 'created_at', 'updated_at'],
      },
    });

    if (!user) {
      return null; // User not found or is a system user
    }

    return selectUserProfileFields(user);
  } catch (error) {
    console.error('Error retrieving non-system user by ID:', error);
    throw error;
  }
};


/**
 * Updates the status of a target user. (Admin operation)
 * @param {number} targetUserId - The ID of the user whose status is to be updated.
 * @param {string} newStatus - The new status to set.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<Object>} - The updated user profile (excluding password).
 * @throws {ApiError} - Throws error if user not found or is a system user.
 */
const updateUserStatus = async (targetUserId, newStatus, adminUserId) => {
  const targetUser = await User.findByPk(targetUserId);
  if (!targetUser) {
    throw new ApiError(404, 'User not found');
  }
  if (targetUser.is_system_user === true) {
    throw new ApiError(403, 'System users cannot be modified.');
  }

  targetUser.status = newStatus;
  await targetUser.save();

  try {
    await auditService.logAdminAction(adminUserId, 'user_status_update', { targetUserId: targetUserId, newStatus: newStatus });
  } catch (auditError) {
    console.error('Failed to log admin action for user_status_update:', auditError);
  }

  return selectUserProfileFields(targetUser.toJSON());
};

/**
 * Updates the role of a target user. (Admin operation)
 * @param {number} targetUserId - The ID of the user whose role is to be updated.
 * @param {string} newRole - The new role to set.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<Object>} - The updated user profile (excluding password).
 * @throws {ApiError} - Throws error if user not found or is a system user.
 */
const updateUserRole = async (targetUserId, newRole, adminUserId) => {
  const targetUser = await User.findByPk(targetUserId);
  if (!targetUser) {
    throw new ApiError(404, 'User not found');
  }
  if (targetUser.is_system_user === true) {
    throw new ApiError(403, 'System users cannot be modified.');
  }

  targetUser.role = newRole;
  await targetUser.save();

  try {
    await auditService.logAdminAction(adminUserId, 'user_role_update', { targetUserId: targetUserId, newRole: newRole });
  } catch (auditError) {
    console.error('Failed to log admin action for user_role_update:', auditError);
  }

  return selectUserProfileFields(targetUser.toJSON());
};

/**
 * Deletes a user and their associated documents. (Admin operation)
 * @param {number} targetUserId - The ID of the user to delete.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<Object>} - Success object.
 * @throws {ApiError} - Throws error if user not found, is a system user, or deletion fails.
 */
const deleteUser = async (targetUserId, adminUserId) => {
  const t = await sequelize.transaction();

  try {
    const targetUser = await User.findByPk(targetUserId, { transaction: t });

    if (!targetUser) {
      throw new ApiError(404, 'User not found');
    }

    if (targetUser.is_system_user === true) {
      throw new ApiError(403, 'System users cannot be deleted.');
    }

    // Handle Associated Documents
    const userDocuments = await Document.findAll({
      where: { uploaded_by_id: targetUserId },
      transaction: t,
    });

    for (const doc of userDocuments) {
      if (doc.file_path) {
        // Assuming 'uploads/' is at the project root.
        // backend/src/services -> backend/src -> backend -> project_root
        const filePath = path.join(__dirname, '../../../uploads', doc.file_path);
        try {
          await fs.promises.unlink(filePath);
          console.log(`Successfully deleted physical file: ${filePath}`);
        } catch (fileError) {
          console.error(`Failed to delete physical file ${filePath}:`, fileError.message);
          // IMPORTANT: Re-throw to trigger transaction rollback
          throw new ApiError(500, `Failed to delete associated file ${doc.file_path}. User deletion rolled back.`);
        }
      }
      await doc.destroy({ transaction: t });
    }

    // Delete the User
    await targetUser.destroy({ transaction: t });

    // Commit the transaction
    await t.commit();

    // Audit Log
    try {
      await auditService.logAdminAction(adminUserId, 'user_delete', { targetUserId: targetUserId });
    } catch (auditError) {
      console.error('Failed to log admin action for user_delete:', auditError);
    }

    return { success: true, message: 'User and associated documents deleted successfully.' };
  } catch (error) {
    // Rollback transaction
    await t.rollback();

    // Log the original error for debugging
    console.error(`Failed to delete user [${targetUserId}]:`, error);

    // Re-throw the original ApiError or a new one for other errors
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(500, `Failed to delete user. ${error.message}`);
  }
};

/**
 * Changes a user's password by an admin.
 * @param {number} targetUserId - The ID of the user whose password is to be changed.
 * @param {string} newPassword - The new password.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise&lt;Object&gt;} - Success object.
 * @throws {ApiError} - Throws error if user not found, is a system user, or update fails.
 */
const changeUserPasswordByAdmin = async (targetUserId, newPassword, adminUserId) => {
  const targetUser = await User.findByPk(targetUserId);
  if (!targetUser) {
    throw new ApiError(404, 'User not found');
  }

  if (targetUser.is_system_user === true) {
    throw new ApiError(403, 'System users cannot have their password changed by an admin.');
  }

  const hashedPassword = await bcrypt.hash(newPassword, 10);
  targetUser.password = hashedPassword;
  await targetUser.save();

  try {
    await auditService.logAdminAction(adminUserId, 'admin_change_user_password', { targetUserId: targetUserId });
  } catch (auditError) {
    console.error('Failed to log admin action for admin_change_user_password:', auditError);
  }

  return { success: true, message: 'Password changed successfully by admin.' };
};

module.exports = {
  fetchOwnProfile,
  modifyOwnProfile,
  updateOwnPassword,
  selectUserProfileFields, // Exporting for potential use in other services/controllers if needed
  listNonSystemUsers,
  getNonSystemUserById,
  updateUserStatus,
  updateUserRole,
  deleteUser,
  changeUserPasswordByAdmin,
};

================
File: backend/src/utils/ApiError.js
================
class ApiError extends Error {
  constructor(statusCode, message, isOperational = true, stack = '') {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

module.exports = ApiError;

================
File: backend/src/utils/catchAsync.js
================
const catchAsync = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch((err) => next(err));
};

module.exports = catchAsync;

================
File: backend/src/validators/admin.user.validator.js
================
const Joi = require('joi');

const updateUserStatusSchema = Joi.object({
  status: Joi.string().trim().valid('approved', 'pending', 'rejected').required().messages({
    'string.base': 'Status must be a string.',
    'string.empty': 'Status is required.',
    'any.only': 'Status must be one of [approved, pending, rejected].',
    'any.required': 'Status is required.'
  })
});

const updateUserRoleSchema = Joi.object({
  role: Joi.string().trim().valid('admin', 'member').required().messages({
    'string.base': 'Role must be a string.',
    'string.empty': 'Role is required.',
    'any.only': 'Role must be one of [admin, member].',
    'any.required': 'Role is required.'
  })
});

const changePasswordSchema = Joi.object({
  newPassword: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?]).{8,}$'))
    .required()
    .messages({
      'string.base': 'New password must be a string.',
      'string.empty': 'New password is required.',
      'string.min': 'New password must be at least 8 characters long.',
      'string.pattern.base': 'New password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one number, and one special character.',
      'any.required': 'New password is required.'
    })
});

module.exports = {
  updateUserStatusSchema,
  updateUserRoleSchema,
  changePasswordSchema, // Added for User Story 7, will be used later
};

================
File: backend/src/validators/announcement.validator.js
================
const Joi = require('joi');

const createAnnouncementSchema = Joi.object({
  title: Joi.string().trim().max(255).required().messages({
    'string.base': 'Title must be a string.',
    'string.empty': 'Title is required.',
    'string.max': 'Title cannot exceed 255 characters.',
    'any.required': 'Title is required.'
  }),
  content: Joi.string().trim().required().messages({
    'string.base': 'Content must be a string.',
    'string.empty': 'Content is required.',
    'any.required': 'Content is required.'
  }),
  expiresAt: Joi.date().iso().greater('now').optional().messages({
    'date.base': 'Expiration date must be a valid date.',
    'date.format': 'Expiration date must be in ISO 8601 format.',
    'date.greater': 'Expiration date must be in the future.'
  })
});

const updateAnnouncementSchema = Joi.object({
  title: Joi.string().trim().min(1).max(255).optional().messages({
    'string.base': 'Title must be a string.',
    'string.min': 'Title must not be empty if provided.',
    'string.max': 'Title cannot exceed 255 characters.'
  }),
  content: Joi.string().trim().min(1).optional().messages({
    'string.base': 'Content must be a string.',
    'string.min': 'Content must not be empty if provided.'
  }),
  expires_at: Joi.date().iso().allow(null).optional().messages({
    'date.base': 'expires_at must be a valid date or null.',
    'date.format': 'expires_at must be a valid ISO 8601 date or null.'
  })
}).or('title', 'content', 'expires_at').messages({
  'object.missing': 'At least one field (title, content, or expires_at) must be provided for update.'
});

const listAnnouncementsSchema = Joi.object({
  page: Joi.number().integer().min(1).optional().messages({
    'number.base': 'Page must be a number.',
    'number.integer': 'Page must be an integer.',
    'number.min': 'Page must be at least 1.'
  }),
  limit: Joi.number().integer().min(1).max(100).optional().messages({
    'number.base': 'Limit must be a number.',
    'number.integer': 'Limit must be an integer.',
    'number.min': 'Limit must be at least 1.',
    'number.max': 'Limit must be between 1 and 100.'
  }),
  sortOrder: Joi.string().valid('asc', 'desc').optional().messages({
    'string.base': 'Sort order must be a string.',
    'any.only': 'Sort order must be one of "asc" or "desc".'
  }),
  status: Joi.string().valid('active').optional().messages({
    'string.base': 'Status must be a string.',
    'any.only': 'Status must be "active" if provided.'
  }),
  sortBy: Joi.string().valid('created_at').optional().messages({
    'string.base': 'Sort by must be a string.',
    'any.only': 'Sort by must be "created_at" if provided.'
  })
});

module.exports = {
  createAnnouncementSchema,
  updateAnnouncementSchema,
  listAnnouncementsSchema,
};

================
File: backend/src/validators/audit.validator.js
================
const Joi = require('joi');

const getAuditLogsSchema = Joi.object({
  page: Joi.number().integer().min(1).optional().default(1),
  limit: Joi.number().integer().min(1).max(100).optional().default(10),
});

module.exports = {
  getAuditLogsSchema,
};

================
File: backend/src/validators/auth.validator.js
================
const Joi = require('joi');

const registerSchema = Joi.object({
  name: Joi.string().trim().min(1).required().messages({
    'string.base': 'Name must be a string.',
    'string.empty': 'Name is required.',
    'string.min': 'Name is required.',
    'any.required': 'Name is required.'
  }),
  email: Joi.string().trim().email().required().messages({
    'string.base': 'Email must be a string.',
    'string.empty': 'Email is required.',
    'string.email': 'Email must be a valid email address.',
    'any.required': 'Email is required.'
  }),
  password: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?]).*$'))
    .required()
    .messages({
      'string.base': 'Password must be a string.',
      'string.empty': 'Password is required.',
      'string.min': 'Password must be at least 8 characters long.',
      'string.pattern.base': 'Password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one number, and one special character.',
      'any.required': 'Password is required.'
    })
  // passwordConfirmation: Joi.string().valid(Joi.ref('password')).required().messages({
  //   'any.only': 'Password confirmation must match password.',
  //   'any.required': 'Password confirmation is required.'
  // })
});

const loginSchema = Joi.object({
  email: Joi.string().trim().email().required().messages({
    'string.base': 'Email must be a string.',
    'string.empty': 'Email is required.',
    'string.email': 'Email must be a valid email address.',
    'any.required': 'Email is required.'
  }),
  password: Joi.string().required().messages({
    'string.base': 'Password must be a string.',
    'string.empty': 'Password is required.',
    'any.required': 'Password is required.'
  })
});

const forgotPasswordSchema = Joi.object({
  email: Joi.string().trim().email().required().messages({
    'string.base': 'Email must be a string.',
    'string.empty': 'Email is required.',
    'string.email': 'Email must be a valid email address.',
    'any.required': 'Email is required.'
  })
});

const resetPasswordSchema = Joi.object({
  token: Joi.string().allow('').messages({
    'string.base': 'Token must be a string.'
  }),
  newPassword: Joi.string().allow('')
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?]).*$'))
    .messages({
      'string.base': 'New password must be a string.',
      'string.min': 'New password must be at least 8 characters long.',
      'string.pattern.base': 'Password must include uppercase, lowercase, number, and special character.'
    })
})
.custom((value, helpers) => {
  const { token, newPassword } = value;
  const tokenIsEffectivelyMissing = token === undefined || token === '';
  const newPasswordIsEffectivelyMissing = newPassword === undefined || newPassword === '';

  if (tokenIsEffectivelyMissing && newPasswordIsEffectivelyMissing) {
    return helpers.error('custom.bothMissing');
  }
  if (tokenIsEffectivelyMissing) {
    return helpers.error('custom.tokenMissing');
  }
  if (newPasswordIsEffectivelyMissing) {
    return helpers.error('custom.newPasswordMissing');
  }
  return value;
})
.messages({
  'custom.bothMissing': 'Token and newPassword are required.',
  'custom.tokenMissing': 'Token is required.',
  'custom.newPasswordMissing': 'New password is required.'
});

module.exports = {
  registerSchema,
  loginSchema,
  forgotPasswordSchema,
  resetPasswordSchema,
};

================
File: backend/src/validators/config.validator.js
================
const Joi = require('joi');

const updateConfigSchema = {
  body: Joi.object().keys({
    value: Joi.string().min(1).required(),
  }),
  params: Joi.object().keys({
    key: Joi.string().required(),
  }),
};

module.exports = {
  updateConfigSchema,
};

================
File: backend/src/validators/discussion.validator.js
================
const Joi = require('joi');

const createThreadSchema = Joi.object({
  title: Joi.string().min(3).max(255).required(),
  content: Joi.string().min(1).required(),
});

const createReplySchema = Joi.object({
  content: Joi.string().min(1).required(),
});

const listThreadsSchema = Joi.object({
  page: Joi.number().integer().min(1).default(1),
  limit: Joi.number().integer().min(1).max(50).default(10),
});

module.exports = {
  createThreadSchema,
  createReplySchema,
  listThreadsSchema,
};

================
File: backend/src/validators/document.validator.js
================
const Joi = require('joi');

const uploadDocumentSchema = Joi.object({
  title: Joi.string().trim().min(1).required().messages({
    'string.base': 'Title must be a string.',
    'string.empty': 'Title is required.',
    'string.min': 'Title is required.',
    'any.required': 'Title is required.'
  }),
  description: Joi.string().trim().allow('').optional().messages({ // Allow empty string for optional description
    'string.base': 'Description must be a string.'
  }),
  is_public: Joi.boolean().required().messages({
    'boolean.base': 'Is Public flag must be a boolean.',
    'any.required': 'Is Public flag is required.'
  })
});

// Schema for when a document is being updated (if needed later)
// const updateDocumentSchema = Joi.object({
//   title: Joi.string().trim().min(1).optional(),
//   description: Joi.string().trim().allow('').optional(),
//   is_public: Joi.boolean().optional(),
//   approved: Joi.boolean().optional() // Admins might also update approval status directly
// });

module.exports = {
  uploadDocumentSchema,
  // updateDocumentSchema,
};

================
File: backend/src/validators/event.validator.js
================
const { query, body, validationResult } = require('express-validator');

const listEventsSchema = [
  query('status')
    .optional()
    .isIn(['upcoming', 'past'])
    .withMessage('Invalid status value. Allowed: upcoming, past.'),
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer.')
    .toInt(),
  query('limit')
    .optional()
    .isInt({ min: 1, max: 50 }) // Max 50 as recommended
    .withMessage('Limit must be a positive integer (1-50).')
    .toInt(),
  query('sortBy')
    .optional()
    .isIn(['event_date', 'title', 'created_at'])
    .withMessage('Invalid sortBy value. Allowed: event_date, title, created_at.'),
  query('sortOrder')
    .optional()
    .isIn(['asc', 'desc'])
    .withMessage('Invalid sortOrder value. Allowed: asc, desc.'),
];

const adminUpdateEventSchema = [
  body('title')
    .optional()
    .isString()
    .withMessage('Title must be a string.')
    .trim(),
  body('description')
    .optional()
    .isString()
    .withMessage('Description must be a string.')
    .trim(),
  body('start_date')
    .optional()
    .isISO8601()
    .withMessage('Start date must be a valid ISO8601 date.')
    .toDate(),
  body('end_date')
    .optional()
    .isISO8601()
    .withMessage('End date must be a valid ISO8601 date.')
    .toDate(),
  body('location')
    .optional()
    .isString()
    .withMessage('Location must be a string.')
    .trim(),
];

const createEventSchema = [
  body('title')
    .isString()
    .withMessage('Title must be a string.')
    .trim()
    .notEmpty()
    .withMessage('Title is required.')
    .isLength({ min: 3, max: 255 })
    .withMessage('Title must be between 3 and 255 characters.'),
  body('description')
    .isString()
    .withMessage('Description must be a string.')
    .trim()
    .notEmpty()
    .withMessage('Description is required.')
    .isLength({ min: 10 })
    .withMessage('Description must be at least 10 characters long.'),
  body('event_date')
    .isISO8601()
    .withMessage('Event date must be a valid ISO8601 date.')
    .custom((value) => {
      const date = new Date(value);
      const now = new Date();
      if (date <= now) {
        throw new Error('Event date must be in the future.');
      }
      return true;
    })
    .toDate(),
  body('location')
    .isString()
    .withMessage('Location must be a string.')
    .trim()
    .notEmpty()
    .withMessage('Location is required.')
    .isLength({ max: 255 })
    .withMessage('Location must be at most 255 characters.'),
];

const validate = (req, res, next) => {
  const errors = validationResult(req);
  if (errors.isEmpty()) {
    return next();
  }
  const extractedErrors = [];
  errors.array().map(err => extractedErrors.push({ param: err.param, message: err.msg }));

  return res.status(400).json({
    errors: extractedErrors,
  });
};

module.exports = {
  listEventsSchema,
  adminUpdateEventSchema,
  createEventSchema,
  validate,
};

================
File: backend/src/validators/user.validator.js
================
const { body, validationResult } = require('express-validator');

const updateProfileSchema = [
  body('name')
    .optional()
    .notEmpty().withMessage('Name cannot be empty.')
    .isString().withMessage('Name must be a string.')
    .trim()
    .escape(),
  ];
  
  const changePasswordSchema = [
    body('currentPassword')
      .notEmpty().withMessage('Current password is required.')
      .isString().withMessage('Current password must be a string.'),
    body('newPassword')
      .notEmpty().withMessage('New password is required.')
      .isString().withMessage('New password must be a string.')
      .isLength({ min: 8 }).withMessage('New password must be at least 8 characters long.')
      .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?~`]).*$/)
      .withMessage('New password must include uppercase, lowercase, number, and special character.'),
  ];
  
  const validate = (req, res, next) => {
    const errors = validationResult(req);
  if (errors.isEmpty()) {
    return next();
  }
  const extractedErrors = [];
  errors.array().map(err => extractedErrors.push({ [err.path]: err.msg }));

  return res.status(400).json({
    errors: extractedErrors,
  });
};

module.exports = {
  updateProfileSchema,
  changePasswordSchema,
  validate,
};

================
File: backend/src/app.js
================
require('dotenv').config(); // Load environment variables from .env file
const express = require('express');
const path = require('path'); // Required for serving static files if needed later
const db = require('../models'); // Sequelize instance and models

// Import routes
const authRoutes = require('./routes/auth.routes');
const adminUserRoutes = require('./routes/admin.user.routes');
const adminDocumentRoutes = require('./routes/document.routes'); // For admin document operations
const announcementRoutes = require('./routes/announcement.routes.js');
const eventRoutes = require('./routes/event.routes.js');
const userRoutes = require('./routes/user.routes'); // Routes for user self-management
const discussionRoutes = require('./routes/discussion.routes');
const configRoutes = require('./routes/config.routes'); // Routes for admin config management
const auditRoutes = require('./routes/audit.routes'); // Routes for admin audit log management
// Public document routes will be separate, e.g., publicDocumentRoutes

const app = express();

// Middleware
app.use(express.json()); // for parsing application/json
app.use(express.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded

// Basic Route for testing
app.get('/', (req, res) => {
  res.json({ message: 'Welcome to the HOA Management API!' });
});

// API Routes
app.use('/api/auth', authRoutes);
app.use('/api/admin/users', adminUserRoutes);
app.use('/api/admin/documents', adminDocumentRoutes); // Admin-specific document routes
app.use('/api/announcements', announcementRoutes);
app.use('/api/events', eventRoutes);
app.use('/api/users', userRoutes); // Mount user self-management routes
app.use('/api/discussions', discussionRoutes);
app.use('/api/admin/config', configRoutes); // Mount admin config routes
app.use('/api/admin/audit-logs', auditRoutes); // Mount admin audit log routes
// app.use('/api/documents', publicDocumentRoutes); // For public listing/downloading

// Global error handler (optional, can be more sophisticated)
app.use((err, req, res, next) => {
  console.error(err.stack);
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';
  res.status(statusCode).json({ message });
});

const PORT = process.env.PORT || 3001; // Default to 3001 if PORT not in .env

async function startServer() {
  try {
    await db.sequelize.authenticate();
    console.log('Database connection has been established successfully.');
    // await db.sequelize.sync(); // { alter: true } or { force: true } during dev if needed
    // console.log('All models were synchronized successfully.'); // Uncomment if using sync

    app.listen(PORT, () => {
      console.log(`Server is running on port ${PORT}.`);
      console.log(`Access it at http://localhost:${PORT}`);
    });
  } catch (error) {
    console.error('Unable to connect to the database or start server:', error);
    process.exit(1); // Exit if cannot connect to DB
  }
}

// Only start server if this file is run directly (not when imported as a module)
if (require.main === module) {
  startServer();
}

module.exports = app; // Export for testing or other purposes

================
File: backend/package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node src/app.js",
    "db:migrate": "npx sequelize-cli db:migrate",
    "db:seed": "npx sequelize-cli db:seed:all",
    "db:seed:undo": "npx sequelize-cli db:seed:undo:all"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^6.0.0",
    "dompurify": "^3.2.6",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "joi": "^17.13.3",
    "jsdom": "^26.1.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.0",
    "sequelize": "^6.37.7",
    "sqlite3": "^5.1.7",
    "express-validator": "^7.0.1",
    "http-status": "^1.5.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.10",
    "sequelize-cli": "^6.6.3"
  }
}

================
File: .dockerignore
================
# Git specific
.git
.gitignore

# Node modules (for both backend and potentially frontend if it exists here)
backend/node_modules/
frontend/node_modules/ # If frontend directory exists at root
node_modules/ # General node_modules at root, if any

# Environment files (should be passed at runtime)
.env
.env.*
!.env.example

# Docker specific files
Dockerfile
backend.Dockerfile # If you named it differently
frontend.Dockerfile # If you add a frontend Dockerfile
docker-compose.yml
docker-compose.*.yml

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Local database files (will be mounted as a volume)
# These paths are relative to the project root, where .dockerignore resides
backend/database/*.db
backend/database/*.db-journal

# Local uploads (will be mounted as a volume)
backend/uploads/

# IDE specific
.vscode/
.idea/

# OS specific
.DS_Store
Thumbs.db

# Other build artifacts or temporary files
# Example:
# frontend/dist/
# frontend/build/

================
File: .env.example
================
# Server Configuration
PORT=3000
NODE_ENV=development

# JWT Configuration
JWT_SECRET=your-jwt-secret-here
JWT_EXPIRATION=1h

# Admin Account (for seeding)
ADMIN_EMAIL=admin@example.com
ADMIN_PASSWORD=change-this-password

# HOA Configuration (for seeding)
HOA_NAME=Sanderson Creek HOA
HOA_DESCRIPTION=Sanderson Creek HOA Community Management System
HOA_LOGO=/images/logo.png

# File Upload Configuration
MAX_FILE_SIZE=5242880  # 5MB in bytes
UPLOAD_PATH=./uploads/documents

# Allowed File Types (comma-separated)
ALLOWED_FILE_TYPES=pdf,doc,docx,jpg,jpeg,png
APP_PORT=3001

================
File: .gitignore
================
# Dependencies
node_modules/

# Environment
.env
.env.*
!.env.example

# Database
src/database/*.db
src/database/*.db-journal

# Logs
logs/
*.log
npm-debug.log*

# IDE
.vscode/
.idea/

# Misc
.DS_Store
coverage/

================
File: back-end-plan.md
================
# Back-end Development Plan (Node.js)

## Technology Stack Assumptions

*   **Runtime Environment:** Node.js (LTS version, e.g., v18.x or v20.x)
*   **Web Framework:** Express.js
*   **Database:** SQLite (retaining from the original application for initial migration simplicity)
*   **Object-Relational Mapper (ORM):** Sequelize
*   **Authentication Strategy:** JSON Web Tokens (JWT)
*   **Password Hashing:** bcrypt
*   **API Documentation Standard:** OpenAPI Specification (Swagger)
*   **File Upload Handling:** Multer middleware for Express.js
*   **Development Language:** JavaScript (ES6+) or TypeScript (if preferred by the team, for this plan we'll assume JavaScript for simplicity in description, but TypeScript is a strong recommendation for new Node.js projects)
*   **Data Validation:** A library like Joi or express-validator.
*   **HTML Sanitization:** A library like DOMPurify (used server-side if applicable, or ensuring input that becomes HTML is handled safely).

## Goal

To develop a robust, scalable, and secure Node.js API that replicates all backend functionalities of the current PHP application. This API will serve as the single source of truth for data and business logic, ready to be consumed by the new React frontend.

## Expected Output

A fully functional set of RESTful API endpoints, complete with authentication, authorization, data validation, and business logic for all HOA application features. The API will be well-documented using OpenAPI/Swagger. The codebase will follow best practices for Node.js/Express.js development, including modular design and comprehensive error handling.

---

## Epic: User Authentication & Authorization

### User Story 1: Implement User Registration API
*   **As a** prospective user,
*   **I want** to register for an account via an API endpoint, providing my name, email, and password,
*   **So that** my details are securely stored, and my account is created in a 'pending' state awaiting administrator approval, enabling me to eventually access the HOA platform features.

    **Technical Requirements:**
    This story involves creating a public API endpoint (e.g., `POST /api/auth/register`). The backend will receive user details (`name`, `email`, `password`) in the request body.
    1.  **Controller (`auth.controller.js`):** This controller will handle the incoming request. It will utilize a validation service/middleware (e.g., using Joi or express-validator) to ensure `name` is non-empty, `email` is a valid email format and unique, and `password` meets defined complexity requirements (Minimum 8 characters, including at least one uppercase letter, one lowercase letter, one number, and one special character).
        *   DONE: [`backend/src/validators/auth.validator.js`](./backend/src/validators/auth.validator.js) created and integrated for request validation.
    2.  **Service (`auth.service.js` or `user.service.js`):** This service will contain the core business logic. It will check if an email already exists in the `users` table using the Sequelize model.
    3.  **Password Hashing:** If the email is unique and validation passes, the `password` will be securely hashed using `bcrypt` (with an appropriate salt round, e.g., 10-12).
    4.  **Database Interaction (`user.model.js` via Sequelize):** A new record will be created in the `users` table with the provided `name`, `email`, the hashed password, a default `role` of 'member', and a `status` of 'pending'. The `created_at` timestamp will be set automatically.
    5.  **Response:** The API will return a success message (e.g., "Registration successful. Your account is pending approval.") and an appropriate HTTP status code (e.g., 201 Created). If registration fails (e.g., email exists, validation error), an appropriate error message and status code (e.g., 409 Conflict for duplicate email, 400 Bad Request for validation errors) will be returned.
    6.  **Security:** Ensure no sensitive information (like password hashes) is inadvertently leaked in error responses. Sanitize inputs to prevent injection attacks, though ORM helps.

*   `[x] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `auth.controller.js` (or similar controller handling registration) and any associated `auth.service.js` or `user.service.js`:**
            *   Instruction: Verify that an API endpoint, such as `POST /api/auth/register`, is defined and mapped to a controller function.
            *   Instruction: Check the controller function to confirm it expects `name`, `email`, and `password` in the request body (e.g., `req.body`).
        2.  **Inspect the registration service logic and `user.model.js` (Sequelize model):**
            *   Instruction: Verify that the `password` received from the request is hashed using `bcrypt.hash()` or a similar method before any database operation.
            *   Instruction: Examine the Sequelize `User.create()` or equivalent call to ensure new users are created with a `role` property set to 'member' and a `status` property set to 'pending' by default.
        3.  **Inspect the response handling in the registration controller function:**
            *   Instruction: Confirm that upon successful user creation, the API responds with a JSON object containing a success message (e.g., `{ "message": "Registration successful. Your account is pending approval." }`) and an HTTP status code of 201.
        4.  **Inspect error handling for duplicate emails and validation failures:**
            *   Instruction: Verify that if a registration attempt is made with an email that already exists in the `users` table, the API responds with an HTTP status code of 409 and an appropriate error message (e.g., `{ "error": "Email already registered." }`).
            *   Instruction: Verify that if input validation fails (e.g., missing name, invalid email format, short password), the API responds with an HTTP status code of 400 and an error message detailing the validation failures.
        5.  **Inspect input validation logic (e.g., using Joi, express-validator, or custom middleware):**
            *   Instruction: Review the validation rules to ensure `name` is checked for non-emptiness.
            *   Instruction: Review the validation rules to ensure `email` is checked for a valid email format.
            *   Instruction: Review the validation rules to ensure `password` is checked for minimum 8 characters, including at least one uppercase letter, one lowercase letter, one number, and one special character.

### User Story 2: Implement User Login API
*   **As a** registered user,
*   **I want** to log in via an API endpoint using my email and password,
*   **So that** I can receive a JSON Web Token (JWT) if my credentials are valid and my account is approved, allowing me to authenticate subsequent requests and access protected parts of the application.

    **Technical Requirements:**
    This story involves creating a public API endpoint (e.g., `POST /api/auth/login`).
    1.  **Controller (`auth.controller.js`):** Handles the incoming request with `email` and `password` in the body. Input validation will ensure both fields are present.
        *   DONE: [`backend/src/validators/auth.validator.js`](./backend/src/validators/auth.validator.js) created and integrated for request validation.
    2.  **Service (`auth.service.js` or `user.service.js`):**
        *   Fetches the user record from the `users` table by `email` using the Sequelize model. If no user is found, it's an authentication failure.
        *   Compares the provided `password` with the stored hashed password using `bcrypt.compare()`. If it doesn't match, it's an authentication failure.
        *   Checks the user's `status`. If the status is not 'approved' (e.g., 'pending', 'rejected'), an appropriate error (e.g., "Account not approved" or "Account pending approval") should be returned, even if credentials are correct.
    3.  **JWT Generation:** If authentication is successful and the account is approved, a JWT will be generated. The JWT payload should include essential, non-sensitive user identifiers like `userId` and `role`. The token should be signed with a secret key stored securely in environment variables and have a defined expiration time (e.g., 1 hour for access token, longer for a refresh token if implemented).
    4.  **Response:** The API will return the JWT (e.g., `{ "token": "your.jwt.here", "user": { "id": "...", "name": "...", "role": "..." } }`) and an HTTP status code 200 OK. For authentication failures or non-approved accounts, appropriate error messages and status codes (e.g., 401 Unauthorized, 403 Forbidden) will be returned.
    5.  **Security:** The JWT secret must be strong and kept confidential. Avoid including sensitive data in the JWT payload.

*   `[x] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `auth.controller.js` (or similar) and any associated `auth.service.js`:**
            *   Instruction: Verify an API endpoint, such as `POST /api/auth/login`, is defined.
            *   Instruction: Check that the controller function expects `email` and `password` in the request body.
        2.  **Inspect the login service logic for user lookup and password verification:**
            *   Instruction: Verify the service attempts to find a user in the `users` table based on the provided `email`.
            *   Instruction: Confirm that `bcrypt.compare()` (or equivalent) is used to compare the plaintext password from the request with the stored hashed password from the database.
        3.  **Inspect the account status check logic:**
            *   Instruction: Verify that after successful password verification, the user's `status` field is checked.
            *   Instruction: If the `status` is not 'approved', confirm the API returns an HTTP status code of 403 and an error message like `{ "error": "Account pending approval." }` or `{ "error": "Account access denied." }`.
        4.  **Inspect JWT generation logic:**
            *   Instruction: Verify that upon successful authentication and 'approved' status, a JWT is generated using a library like `jsonwebtoken`.
            *   Instruction: Check that the JWT payload includes at least `userId` (or `id`) and `role`.
            *   Instruction: Verify the JWT is signed with a secret key loaded from environment variables (e.g., `process.env.JWT_SECRET`).
            *   Instruction: Confirm the API response includes the generated JWT (e.g., in a field named `token`) and user details (excluding password) and an HTTP status code of 200.
        5.  **Inspect error handling for invalid credentials:**
            *   Instruction: Verify that if the email is not found or the password does not match, the API responds with an HTTP status code of 401 and an error message like `{ "error": "Invalid email or password." }`.

### User Story 3: Implement JWT-based Authorization Middleware
*   **As a** backend developer,
*   **I want** to implement Express.js middleware to validate JWTs present in the `Authorization` header of incoming requests and to check user roles for protected endpoints,
*   **So that** sensitive operations are restricted to authenticated and appropriately authorized users, enhancing application security.

    **Technical Requirements:**
    This involves creating one or more middleware functions.
    1.  **Authentication Middleware (`auth.middleware.js` or similar - e.g., `verifyToken`):**
        *   This middleware will be applied to routes that require authentication.
        *   It will extract the JWT from the `Authorization` header (typically in the 'Bearer [token]' format).
        *   If no token is found or the format is incorrect, it should respond with a 401 Unauthorized error.
        *   It will verify the token's signature using the same JWT secret key used for generation. If verification fails (e.g., tampered token, invalid signature, expired token), it responds with 401 Unauthorized or 403 Forbidden.
        *   Upon successful verification, it will decode the token payload and attach user information (e.g., `userId`, `role`) to the `request` object (e.g., `req.user`) so subsequent handlers can access it.
        *   If verification is successful, it calls `next()` to pass control to the next middleware or route handler.
    2.  **Role-Checking Middleware (`auth.middleware.js` or similar - e.g., `authorizeRoles(...allowedRoles)`):**
        *   This middleware factory function will take an array of allowed roles as arguments.
        *   It will be applied *after* the authentication middleware.
        *   It will check if `req.user.role` is included in the `allowedRoles` array.
        *   If the user's role is not permitted, it responds with a 403 Forbidden error.
        *   If the role is permitted, it calls `next()`.
    3.  **Integration:** These middlewares will be added to the Express route definitions for protected endpoints. For example, an admin-only endpoint would use both `verifyToken` and `authorizeRoles('admin')`.

*   `[x] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `auth.middleware.js` (or a similarly named file containing authentication middleware):**
            *   Instruction: Verify a middleware function (e.g., `verifyToken` or `authenticateJWT`) is created.
            *   Instruction: Check that this middleware attempts to extract a JWT from the `Authorization` header (e.g., from `req.headers.authorization` and expects a "Bearer" scheme).
            *   Instruction: Verify the middleware uses `jsonwebtoken.verify()` (or equivalent) with the correct secret key (from environment variables) to validate the token.
        2.  **Inspect the logic for attaching user information to the request object:**
            *   Instruction: Confirm that upon successful token verification, the decoded payload (containing at least `userId` and `role`) is attached to the `request` object (e.g., `req.user = decodedPayload;`).
        3.  **Inspect error handling for missing or invalid tokens:**
            *   Instruction: Verify that if no token is provided in the header, the middleware responds with an HTTP status code of 401 and an error message (e.g., `{ "error": "Access token is required." }`).
            *   Instruction: Verify that if the token is invalid (e.g., incorrect signature, expired), the middleware responds with an HTTP status code of 401 or 403 and an appropriate error message (e.g., `{ "error": "Invalid or expired token." }`).
        4.  **Inspect the role-checking middleware (e.g., `authorizeRoles`):**
            *   Instruction: Verify a middleware function exists that accepts one or more role strings as arguments (e.g., `authorizeRoles('admin', 'system')`).
            *   Instruction: Check that this middleware accesses `req.user.role` (set by the authentication middleware).
            *   Instruction: Verify it compares `req.user.role` against the list of allowed roles.
        5.  **Inspect error handling for insufficient role permissions:**
            *   Instruction: Confirm that if `req.user.role` is not in the list of allowed roles, the middleware responds with an HTTP status code of 403 and an error message (e.g., `{ "error": "You do not have permission to access this resource." }`).
        6.  **Inspect route definitions in relevant router files (e.g., `user.routes.js`, `admin.routes.js`):**
            *   Instruction: Verify that protected routes are configured to use the authentication middleware (e.g., `router.get('/protected', verifyToken, ...)`) and, where necessary, the role-checking middleware (e.g., `router.get('/admin/resource', verifyToken, authorizeRoles('admin'), ...)`).

### User Story 3.1: Implement Self-Service Password Reset API (Request & Verify Token)
*   **As a** registered user who has forgotten my password,
*   **I want** to request a password reset link via an API endpoint by providing my email address,
*   **So that** I can receive an email with a unique, time-sensitive token/link to initiate the password reset process.

 **Technical Requirements:**

    **1. Request Password Reset Token API**
    *   **Endpoint:** `POST /api/auth/forgot-password`
    *   **Request Body Example:**
        ```json
        {
          "email": "user@example.com"
        }
        ```
    *   **Response Body (Success - 200 OK):**
        ```json
        {
          "message": "Password reset email sent. Please check your inbox."
        }
        ```
    *   **Response Body (Error - 404 Not Found - Email not registered):**
        ```json
        {
          "error": "Email not found."
        }
        ```
    *   **Response Body (Error - 400 Bad Request - User not approved/pending):**
        ```json
        {
          "error": "User account is not active or eligible for password reset."
        }
        ```
    *   **Response Body (Error - 400 Bad Request - Invalid email format):**
        ```json
        {
          "error": "Invalid email format."
        }
        ```
    *   **Authentication/Authorization:** Public endpoint.
    *   **Key Logic:**
        1.  Validate the `email` format in the request body.
        2.  Check if the email exists in the `users` table and if the user's `status` is 'approved'. If not, return an appropriate error.
        3.  Generate a cryptographically secure, unique, and time-limited token (e.g., UUID v4 or a long random string).
        4.  Hash the generated token using `bcrypt` before storing it.
        5.  Store the hashed token in the `verification_tokens` table, associated with the `user_id`, a `type` of 'password_reset', and an `expires_at` timestamp (e.g., 1 hour from creation).
        6.  Compose an email containing a password reset link. This link should point to a frontend page and include the plain (unhashed) token as a query parameter (e.g., `https://your-frontend-domain.com/reset-password?token=THE_GENERATED_TOKEN`).
        7.  Send the email to the user's registered email address.
        8.  Return a success message indicating the email has been sent.

    **2. Verify Password Reset Token API**
    *   **Endpoint:** `GET /api/auth/verify-reset-token`
    *   **Request Query Parameter:** `token` (e.g., `/api/auth/verify-reset-token?token=THE_GENERATED_TOKEN`)
    *   **Response Body (Success - 200 OK):**
        ```json
        {
          "message": "Token is valid."
        }
        ```
    *   **Response Body (Error - 400 Bad Request / 404 Not Found - Invalid, expired, or not found token):**
        ```json
        {
          "error": "Invalid or expired password reset token."
        }
        ```
    *   **Authentication/Authorization:** Public endpoint.
    *   **Key Logic:**
        1.  Extract the `token` from the request query parameters.
        2.  Iterate through tokens in the `verification_tokens` table: hash the provided `token` and compare it against stored hashed tokens of type 'password_reset' that are not expired. (Alternatively, if storing the plain token is acceptable for this specific short-lived use case and the transport is secure, direct lookup is simpler but less secure if the DB is compromised). For better security, hash the input token and compare with stored hashes.
        3.  If a matching, valid (correct type, not expired) token is found, return a success response.
        4.  If no such token is found, or if it's expired or of the wrong type, return an error.

*   `[x] Implemented - Functionality complete and tested`
    *   **Acceptance Criteria:**
        *   **Request Reset Token:**
            1.  Given a user provides a valid email address associated with an 'approved' account, when they submit a request to `POST /api/auth/forgot-password`, then the system generates a unique password reset token, stores its hashed version with an expiry, sends an email containing the plain token in a reset link to the user, and the API returns a 200 OK response with a success message.
            2.  Given a user provides an email address not found in the system, when they request a password reset, then the API returns a 404 Not Found error.
            3.  Given a user provides an email address for an account that is 'pending' or 'rejected', when they request a password reset, then the API returns a 400 Bad Request error (or a generic message to prevent account status enumeration).
            4.  Given a user provides an improperly formatted email address, when they request a password reset, then the API returns a 400 Bad Request error.
            5.  The generated password reset token must be unique for each request and have a clearly defined, short expiration period (e.g., 1 hour).
            6.  The email sent to the user must contain a direct link to the password reset page on the frontend, including the token.
        *   **Verify Reset Token:**
            1.  Given a user navigates to `GET /api/auth/verify-reset-token` with a valid, unexpired 'password_reset' token, then the API returns a 200 OK response confirming token validity.
            2.  Given an invalid, expired, or non-existent token is provided to `GET /api/auth/verify-reset-token`, then the API returns a 400 Bad Request or 404 Not Found error.
            3.  The verification endpoint must ensure the token is specifically for 'password_reset' purposes.


### User Story 3.2: Implement Self-Service Password Reset API (Submit New Password)
*   **As a** user who has verified my password reset token,
*   **I want** to submit a new password via an API endpoint, providing the reset token and my new password,
*   **So that** my account password can be securely updated, and I can regain access.

    **Technical Requirements:**
    *   **Endpoint:** `POST /api/auth/reset-password`
    *   **Request Body Example:**
        ```json
        {
          "token": "THE_GENERATED_TOKEN_FROM_EMAIL",
          "newPassword": "NewSecurePassword123!"
        }
        ```
    *   **Response Body (Success - 200 OK):**
        ```json
        {
          "message": "Password has been reset successfully."
        }
        ```
    *   **Response Body (Error - 400 Bad Request - Invalid/Expired Token):**
        ```json
        {
          "error": "Invalid or expired password reset token."
        }
        ```
    *   **Response Body (Error - 400 Bad Request - Password Complexity):**
        ```json
        {
          "error": "Password does not meet complexity requirements. Minimum 8 characters, including uppercase, lowercase, number, and special character."
        }
        ```
    *   **Response Body (Error - 400 Bad Request - Missing fields):**
        ```json
        {
          "error": "Token and newPassword are required."
        }
        ```
    *   **Authentication/Authorization:** Public endpoint (the token itself acts as a temporary authorization for this specific action).
    *   **Key Logic:**
        1.  Validate that `token` and `newPassword` are present in the request body.
        2.  Verify the provided `token`:
            *   Hash the input `token` and search for it in the `verification_tokens` table.
            *   Ensure the found token record is of type 'password_reset', is associated with a valid `user_id`, and has not expired.
        3.  If the token is invalid, expired, or not found, return an appropriate error.
        4.  Validate the `newPassword` against the application's password complexity rules (e.g., minimum length, character types  align with registration policy). If validation fails, return an error.
        5.  Securely hash the `newPassword` using `bcrypt`.
        6.  Retrieve the `user_id` associated with the valid token.
        7.  Update the `password` field in the `users` table for the identified `user_id` with the new hashed password.
        8.  Invalidate or delete the used verification token from the `verification_tokens` table to prevent reuse.
        9.  (Optional but recommended) Consider invalidating other active sessions for the user to enhance security after a password reset.
        10. Log the successful password reset event (e.g., in an audit log if applicable for security monitoring).

*   `[x] Implemented - Functionality complete and tested`
    *   **Acceptance Criteria:**
        1.  Given a user provides a valid, unexpired 'password_reset' token and a `newPassword` that meets complexity requirements to `POST /api/auth/reset-password`, then the user's password in the `users` table is updated with the new hashed password, the used token is invalidated/deleted from `verification_tokens`, and the API returns a 200 OK response with a success message.
        2.  Given a user provides an invalid, expired, or already used token, when they attempt to reset the password, then the API returns a 400 Bad Request error.
        3.  Given a user provides a `newPassword` that does not meet the defined complexity requirements, when they attempt to reset the password, then the API returns a 400 Bad Request error detailing the password policy.
        4.  The `newPassword` must be securely hashed using `bcrypt` before being stored in the database.
        5.  A password reset token must be single-use; attempting to use it again after a successful password reset must fail.
        6.  If `token` or `newPassword` fields are missing from the request, the API returns a 400 Bad Request error.

### User Story 3.3: Implement User Profile Self-Management API (View & Update Own Details)
*   **As an** authenticated user,
*   **I want** API endpoints to view my own user profile details (excluding sensitive data like password hash) and to update my modifiable details (e.g., name),
*   **So that** I can manage my personal information.

   **Technical Requirements:**

    **1. View Own User Profile API**
    *   **Endpoint:** `GET /api/users/me`
    *   **Request Body:** None.
    *   **Response Body (Success - 200 OK):**
        ```json
        {
          "id": 123,
          "name": "Current User Name",
          "email": "current.user@example.com",
          "role": "member",
          "status": "approved",
          "created_at": "2025-01-15T10:30:00.000Z",
          "updated_at": "2025-01-16T11:00:00.000Z"
        }
        ```
        (Note: Excludes sensitive fields like `password` hash, `is_system_user`, etc.)
    *   **Response Body (Error - 401 Unauthorized):** If token is missing or invalid.
        ```json
        {
          "error": "Unauthorized"
        }
        ```
    *   **Authentication/Authorization:** Requires an active, valid JWT for an authenticated user. Accessible by any authenticated role ('member', 'admin').
    *   **Key Logic:**
        1.  The `auth.middleware` (verifyToken) validates the JWT and attaches `req.user` (containing `userId`, `role`, etc.).
        2.  Extract `userId` from `req.user`.
        3.  Fetch the user's record from the `users` table using `userId`.
        4.  If user not found (should not happen if token is valid and user exists), return 404 or 500.
        5.  Select and return only the publicly safe and relevant user profile fields.

    **2. Update Own User Profile API**
    *   **Endpoint:** `PUT /api/users/me`
    *   **Request Body Example (Only `name` is updatable in this example):**
        ```json
        {
          "name": "New User Name"
        }
        ```
        (Other fields like email might require a separate, more complex flow with verification).
    *   **Response Body (Success - 200 OK):** Returns the updated user profile object.
        ```json
        {
          "id": 123,
          "name": "New User Name",
          "email": "current.user@example.com",
          "role": "member",
          "status": "approved",
          "created_at": "2025-01-15T10:30:00.000Z",
          "updated_at": "2025-06-01T14:20:00.000Z"
        }
        ```
    *   **Response Body (Error - 400 Bad Request - Validation Error):**
        ```json
        {
          "errors": [
            { "field": "name", "message": "Name cannot be empty." }
          ]
        }
        ```
    *   **Response Body (Error - 401 Unauthorized):** If token is missing or invalid.
    *   **Authentication/Authorization:** Requires an active, valid JWT for an authenticated user.
    *   **Key Logic:**
        1.  The `auth.middleware` validates JWT and attaches `req.user`.
        2.  Extract `userId` from `req.user`.
        3.  Extract updatable fields (e.g., `name`) from `req.body`.
        4.  Validate the input data (e.g., `name` should not be empty if provided).
        5.  If validation fails, return a 400 error.
        6.  Fetch the user's record from the `users` table.
        7.  Update the allowed fields in the user's record.
        8.  Save the changes to the database.
        9.  Return the updated user profile object (selected fields).

*   `[x] Implemented - Functionality complete and tested`
    *   **Acceptance Criteria:**
        *   **View Profile:**
            1.  Given an authenticated user sends a `GET` request to `/api/users/me`, then the API returns a 200 OK response containing their own profile information (including `id`, `name`, `email`, `role`, `status`, `created_at`, `updated_at`), and excluding sensitive data like the password hash.
            2.  Given a request is made to `GET /api/users/me` without a valid authentication token, then the API returns a 401 Unauthorized error.
        *   **Update Profile:**
            1.  Given an authenticated user sends a `PUT` request to `/api/users/me` with valid data for modifiable fields (e.g., a new `name`), then the user's record in the database is updated, and the API returns a 200 OK response with the complete updated user profile.
            2.  Given an authenticated user sends a `PUT` request to `/api/users/me` with invalid data (e.g., an empty `name`), then the API returns a 400 Bad Request error with details about the validation failure.
            3.  An authenticated user must only be able to update their own profile information.
            4.  Attempting to update fields not designated as user-modifiable via this endpoint (e.g., `email` if it requires verification, `role`, `status`) should be ignored or result in a specific error if explicitly disallowed.

### User Story 3.4: Implement User API to Change Own Password
*   **As an** authenticated user,
*   **I want** an API endpoint to change my own password by providing my current password and a new password,
*   **So that** I can maintain the security of my account.

    **Technical Requirements:**
    *   **Endpoint:** `PUT /api/users/me/password`
    *   **Request Body Example:**
        ```json
        {
          "currentPassword": "OldSecurePassword123!",
          "newPassword": "BrandNewSecurePassword456$"
        }
        ```
    *   **Response Body (Success - 200 OK):**
        ```json
        {
          "message": "Password changed successfully."
        }
        ```
    *   **Response Body (Error - 400 Bad Request - Password Complexity / Missing Fields):**
        ```json
        {
          "error": "New password does not meet complexity requirements. Minimum 8 characters, including uppercase, lowercase, number, and special character."
        }
        ```
        ```json
        {
          "error": "Current password and new password are required."
        }
        ```
    *   **Response Body (Error - 401 Unauthorized):** If token is missing or invalid.
    *   **Response Body (Error - 403 Forbidden - Incorrect Current Password):**
        ```json
        {
          "error": "Incorrect current password."
        }
        ```
    *   **Authentication/Authorization:** Requires an active, valid JWT for an authenticated user.
    *   **Key Logic:**
        1.  The `auth.middleware` validates JWT and attaches `req.user`.
        2.  Extract `userId` from `req.user`.
        3.  Extract `currentPassword` and `newPassword` from `req.body`. Validate their presence.
        4.  Fetch the authenticated user's record from the `users` table (including the `password` hash).
        5.  Verify the provided `currentPassword` against the stored hashed password using `bcrypt.compare()`.
        6.  If `currentPassword` does not match, return a 403 Forbidden error.
        7.  Validate the `newPassword` against the application's password complexity rules. If validation fails, return a 400 Bad Request error.
        8.  Securely hash the `newPassword` using `bcrypt`.
        9.  Update the `password` field in the `users` table for the `userId` with the new hashed password.
        10. Return a success message.
        11. (Optional but recommended) Consider invalidating other active sessions for the user.

*   `[x] Implemented - Functionality complete and tested`
    *   **Acceptance Criteria:**
        1.  Given an authenticated user sends a `PUT` request to `/api/users/me/password` with their correct `currentPassword` and a `newPassword` that meets complexity requirements, then the user's password in the database is updated with the new hashed password, and the API returns a 200 OK response with a success message.
        2.  Given an authenticated user provides an incorrect `currentPassword`, when they attempt to change their password, then the API returns a 403 Forbidden error.
        3.  Given an authenticated user provides a `newPassword` that does not meet the defined complexity requirements, when they attempt to change their password, then the API returns a 400 Bad Request error detailing the password policy.
        4.  Given an authenticated user omits `currentPassword` or `newPassword` from the request, then the API returns a 400 Bad Request error.
        5.  The `newPassword` must be securely hashed using `bcrypt` before being stored.
        6.  Given a request is made to `PUT /api/users/me/password` without a valid authentication token, then the API returns a 401 Unauthorized error.

---

## Epic: User Management (Admin)

### User Story 4: Implement API to List and Retrieve Users (Admin)
*   **As an** administrator,
*   **I want** API endpoints to list all non-system users and retrieve a specific non-system user's details (excluding sensitive information like passwords),
*   **So that** I can effectively manage user accounts within the HOA system.

    **Technical Requirements:**
    These endpoints will be protected and accessible only to users with an 'admin' role.
    1.  **List Users Endpoint (e.g., `GET /api/admin/users`):**
        *   **Controller (`admin.user.controller.js` or similar):** Handles the request.
        *   **Service (`user.service.js`):** Fetches users from the `users` table using Sequelize.
        *   **Filtering:** Excludes users where `is_system_user` is true.
        *   **Data Projection:** Ensures that sensitive fields like `password` are *not* returned in the response. Only necessary fields like `id`, `name`, `email`, `role`, `status`, `created_at` should be included.
        *   **Pagination:** Implement pagination (e.g., using `limit` and `offset` query parameters) to handle potentially large numbers of users.
        *   **Response:** Returns a list of user objects and pagination details.
    2.  **Retrieve Specific User Endpoint (e.g., `GET /api/admin/users/:id`):**
        *   **Controller:** Handles the request, extracting `id` from path parameters.
        *   **Service:** Fetches a single user by `id`.
        *   **Security:** Ensures the user being fetched is not a system user (or handles this case appropriately, e.g., by returning 404 or 403 if admins should not view system user details this way).
        *   **Data Projection:** Excludes `password`.
        *   **Response:** Returns the user object or a 404 Not Found if the user doesn't exist or access is denied.
    3.  **Authorization:** Both endpoints must be protected by the JWT authentication and 'admin' role authorization middlewares.

*   `[x] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect the route definitions for admin user management (e.g., in `admin.routes.js` or `user.routes.js`):**
            *   Instruction: Verify an endpoint like `GET /api/admin/users` is defined and protected by authentication and 'admin' role authorization middleware.
            *   Instruction: Verify an endpoint like `GET /api/admin/users/:userId` is defined and protected similarly.
        2.  **Inspect the controller and service logic for listing users (`GET /api/admin/users`):**
            *   Instruction: Verify the service layer queries the `users` table, explicitly filtering out users where `is_system_user` is true (or an equivalent flag).
            *   Instruction: Check the Sequelize query options (e.g., `attributes: { exclude: ['password'] }`) to ensure the `password` field is never returned in the list.
            *   Instruction: Verify that the response is an array of user objects.
            *   Instruction: (Optional but recommended) Check for support for pagination query parameters (e.g., `limit`, `offset` or `page`, `pageSize`).
        3.  **Inspect the controller and service logic for retrieving a specific user (`GET /api/admin/users/:userId`):**
            *   Instruction: Verify the service layer queries the `users` table for a user with the given `userId`.
            *   Instruction: Ensure it checks if the retrieved user has `is_system_user` as true and returns a 404 or 403 if such users should not be accessible via this endpoint.
            *   Instruction: Check the Sequelize query options to ensure the `password` field is excluded from the response.
            *   Instruction: Verify that if a user is found and accessible, their details are returned. If not found, a 404 status is returned.

### User Story 5: Implement API to Update User Role and Status (Admin)
*   **As an** administrator,
*   **I want** API endpoints to update a non-system user's role (e.g., from 'member' to 'admin') and status (e.g., from 'pending' to 'approved'),
*   **So that** I can manage user access levels and activate new accounts.

    **Technical Requirements:**
    These endpoints will modify user data and must be protected for 'admin' role access.
    1.  **Update Status Endpoint (e.g., `PUT /api/admin/users/:id/status`):**
        *   **Controller (`admin.user.controller.js`):** Extracts `id` from path and new `status` from request body.
        *   **Validation:** Validates the new `status` value against allowed values (e.g., 'approved', 'pending', 'rejected').
        *   **Service (`user.service.js`):** Fetches the user by `id`.
        *   **Security Check:** Verifies the user is not a system user (`is_system_user !== true`). If so, disallow update and return 403.
        *   **Database Interaction:** Updates the `status` field for the user.
        *   **Audit Logging:** Logs this action (see Audit Log epic).
        *   **Response:** Returns the updated user object (excluding password) or success message.
    2.  **Update Role Endpoint (e.g., `PUT /api/admin/users/:id/role`):**
        *   **Controller:** Extracts `id` from path and new `role` from request body.
        *   **Validation:** Validates the new `role` value against allowed roles (e.g., 'admin', 'member'). The original PHP also has a "system" role concept for `manage_config.php`, this should be considered if distinct.
        *   **Service:** Fetches the user by `id`.
        *   **Security Check:** Verifies the user is not a system user.
        *   **Database Interaction:** Updates the `role` field for the user.
        *   **Audit Logging:** Logs this action.
        *   **Response:** Returns the updated user object (excluding password) or success message.
    3.  **Authorization:** Both endpoints protected by JWT auth and 'admin' role.

*   `[x] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect route definitions for updating user status and role:**
            *   Instruction: Verify an endpoint like `PUT /api/admin/users/:userId/status` is defined and protected by authentication and 'admin' role authorization.
            *   Instruction: Verify an endpoint like `PUT /api/admin/users/:userId/role` is defined and protected similarly.
        2.  **Inspect controller and service logic for `PUT /api/admin/users/:userId/status`:**
            *   Instruction: Verify the controller expects a `status` field in the request body.
            *   Instruction: Check that the service validates the new `status` value (e.g., against ['approved', 'pending', 'rejected']).
            *   Instruction: Verify the service fetches the user by `userId` and checks if `is_system_user` is true. If true, ensure the update is prevented and a 403 status is returned.
            *   Instruction: Confirm the `status` field of the user is updated in the database if the user is not a system user.
            *   Instruction: Verify an audit log entry is created for this action, including `adminId`, `action` type (e.g., 'user_status_update'), and relevant details (e.g., `userId`, new `status`).
        3.  **Inspect controller and service logic for `PUT /api/admin/users/:userId/role`:**
            *   Instruction: Verify the controller expects a `role` field in the request body.
            *   Instruction: Check that the service validates the new `role` value (e.g., against ['admin', 'member']).
            *   Instruction: Verify the service fetches the user by `userId` and checks if `is_system_user` is true. If true, ensure the update is prevented and a 403 status is returned.
            *   Instruction: Confirm the `role` field of the user is updated in the database if the user is not a system user.
            *   Instruction: Verify an audit log entry is created for this action, including `adminId`, `action` type (e.g., 'user_role_update'), and relevant details (e.g., `userId`, new `role`).
        4.  **Inspect the responses from both endpoints:**
            *   Instruction: Verify that upon successful update, the API returns the updated user object (excluding the password) or a success message, with an HTTP status code of 200.

### User Story 6: Implement API to Delete User (Admin)
*   **As an** administrator,
*   **I want** an API endpoint to delete a non-system user, which also handles their associated data like uploaded documents,
*   **So that** I can permanently remove accounts and their contributions from the system when necessary.

    **Technical Requirements:**
    This is a destructive operation and requires careful implementation.
    1.  **Endpoint (e.g., `DELETE /api/admin/users/:id`):**
        *   **Controller (`admin.user.controller.js`):** Extracts `id` from path.
        *   **Service (`user.service.js`):**
            *   Fetches the user by `id`. If not found, return 404.
            *   **Security Check:** Verifies the user is not a system user (`is_system_user !== true`). If so, disallow deletion and return 403.
            *   **Associated Data Handling:**
                *   **Documents:** Identify all documents uploaded by this user (from `documents` table). For each document, delete the physical file from storage (using `fs.unlink` and the stored `file_path`) and then delete the document record from the database. This matches the PHP app's behavior.
                *   **Other Content (Discussions, Announcements, Events):** Review if the PHP app cascaded deletions or anonymized. For this migration, if not explicitly cascaded, user-created content in these tables might remain but be linked to a non-existent `created_by` ID, or a decision needs to be made (e.g., set `created_by` to NULL or a special "deleted user" ID if the schema allows, or cascade delete if appropriate). The PHP code in `manage_users.php` only explicitly handles document deletion. For other content, deletion is managed by their respective admin modules. We will replicate the PHP app's document deletion logic.
            *   **Database Interaction:** Delete the user record from the `users` table. Consider using `ON DELETE SET NULL` or `ON DELETE CASCADE` for foreign keys in other tables if appropriate for the new design, defined at the ORM/DB level.
        *   **Audit Logging:** Logs this action.
        *   **Response:** Returns a success message and 200 OK or 204 No Content.
    2.  **Authorization:** Protected by JWT auth and 'admin' role.
    3.  **Transactions:** Use database transactions to ensure atomicity, especially when deleting files and multiple database records. If a file deletion fails, the user deletion should ideally be rolled back.

*   `[x] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect route definition for deleting a user:**
            *   Instruction: Verify an endpoint like `DELETE /api/admin/users/:userId` is defined and protected by authentication and 'admin' role authorization.
        2.  **Inspect controller and service logic for `DELETE /api/admin/users/:userId`:**
            *   Instruction: Verify the service fetches the user by `userId`.
            *   Instruction: Confirm the service checks if `is_system_user` is true for the fetched user. If true, ensure the deletion is prevented and a 403 status is returned.
        3.  **Inspect handling of associated documents:**
            *   Instruction: Verify the service queries the `documents` table for all documents where `uploaded_by` matches the `userId`.
            *   Instruction: For each found document, verify the code attempts to delete the corresponding physical file from the server's file system (using the `file_path` stored in the document record and `fs.unlink()`).
            *   Instruction: After attempting file deletion, verify the document record is deleted from the `documents` table.
        4.  **Inspect user deletion from the database:**
            *   Instruction: Verify that after handling associated data, the user record itself is deleted from the `users` table. (Check if foreign key constraints in other tables like `discussions`, `announcements`, `events` are handled gracefully, e.g., `ON DELETE SET NULL` if `created_by` is nullable, or if they prevent deletion if not handled).
        5.  **Inspect audit logging:**
            *   Instruction: Verify an audit log entry is created for this action, including `adminId`, `action` type (e.g., 'user_delete'), and `userId`.
        6.  **Inspect the response:**
            *   Instruction: Verify that upon successful deletion, the API returns an HTTP status code of 200 with a success message or a 204 No Content status.
        7.  **Inspect database transaction usage:**
            *   Instruction: Verify that the operations for deleting associated documents (files and DB records) and the user record are wrapped in a database transaction (e.g., `sequelize.transaction()`).

### User Story 7: Implement API for Admin to Change User Password
*   **As an** administrator,
*   **I want** an API endpoint to change a non-system user's password,
*   **So that** I can assist users who are locked out or require a password reset, without needing to know their current password.

    **Technical Requirements:**
    This endpoint allows admins to directly set a new password for a user.
    1.  **Endpoint (e.g., `PUT /api/admin/users/:id/password`):**
        *   **Controller (`admin.user.controller.js`):** Extracts `id` from path and `newPassword` from request body.
        *   **Validation:** Validates `newPassword` meets complexity requirements (e.g., min 8 characters).
        *   **Service (`user.service.js`):**
            *   Fetches the user by `id`. If not found, return 404.
            *   **Security Check:** Verifies the user is not a system user (`is_system_user !== true`). If so, disallow update and return 403.
            *   **Password Hashing:** Securely hash the `newPassword` using `bcrypt`.
            *   **Database Interaction:** Update the `password` field for the user with the new hashed password.
        *   **Audit Logging:** Logs this action.
        *   **Response:** Returns a success message and 200 OK.
    2.  **Authorization:** Protected by JWT auth and 'admin' role.

*   `[x] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect route definition for changing a user's password by admin:**
            *   Instruction: Verify an endpoint like `PUT /api/admin/users/:userId/password` is defined and protected by authentication and 'admin' role authorization.
        2.  **Inspect controller and service logic for `PUT /api/admin/users/:userId/password`:**
            *   Instruction: Verify the controller expects a `newPassword` field in the request body.
            *   Instruction: Check that the service validates the `newPassword` for minimum length/complexity.
            *   Instruction: Verify the service fetches the user by `userId`.
            *   Instruction: Confirm the service checks if `is_system_user` is true for the fetched user. If true, ensure the password change is prevented and a 403 status is returned.
            *   Instruction: Verify the `newPassword` is hashed using `bcrypt.hash()` before updating the database.
            *   Instruction: Confirm the `password` field of the user is updated in the database with the new hash.
        3.  **Inspect audit logging:**
            *   Instruction: Verify an audit log entry is created for this action, including `adminId`, `action` type (e.g., 'admin_password_change'), and `userId`.
        4.  **Inspect the response:**
            *   Instruction: Verify that upon successful password change, the API returns an HTTP status code of 200 and a success message.

---

## Epic: Document Management

### User Story 8: Implement API to Upload Document (Admin)
*   **As an** administrator,
*   **I want** an API endpoint to upload documents (e.g., PDF, DOCX, images) along with metadata like title, description, and a public access flag,
*   **So that** these documents can be stored securely and made available to HOA members as appropriate.

    **Technical Requirements:**
    This endpoint will handle file uploads and metadata storage.
    1.  **Endpoint (e.g., `POST /api/admin/documents`):**
        *   **Middleware:** Uses `Multer` for handling `multipart/form-data`. Configure Multer for file destination (secure server location, e.g., `./uploads/documents` - ensure this path is not directly web-accessible if files are to be served via a protected download endpoint), file naming (e.g., unique ID + original extension to prevent collisions and manage file types), and file size/type limits (from PHP config: `MAX_FILE_SIZE`, `ALLOWED_FILE_TYPES`).
        *   **Controller (`document.controller.js`):** Accesses uploaded file details from `req.file` (or `req.files`) and other metadata (`title`, `description`, `is_public`) from `req.body`.
        *   **Validation:** Validates `title` (non-empty). `description` is optional. `is_public` is a boolean.
        *   **Service (`document.service.js`):**
            *   **Database Interaction:** Creates a new record in the `documents` table. Store `title`, `description`, original `file_name` (from `req.file.originalname`), the Multer-generated `file_name` for storage (from `req.file.filename`), `file_path` (path to the file on server, constructed from Multer's destination and filename), `uploaded_by` (admin's `userId` from `req.user`), `is_public` flag. If `is_public` is true, `approved` status should be set to true; otherwise, `approved` is false by default (matching PHP logic: `upload_document.php` sets `approved = $is_public ? 1 : 0`).
        *   **Audit Logging:** Logs document upload.
        *   **Response:** Returns the created document metadata object and 201 Created.
    2.  **Authorization:** Protected by JWT auth and 'admin' role.
    3.  **Error Handling:** Gracefully handle file upload errors (e.g., disk full, permission issues, type/size violations from Multer).

*   `[x] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect route definition for document upload:**
            *   Instruction: Verify an endpoint like `POST /api/admin/documents` is defined and protected by authentication and 'admin' role authorization.
            *   Instruction: Verify this route uses `Multer` middleware configured for single file upload (e.g., `upload.single('documentFile')`).
        2.  **Inspect Multer configuration:**
            *   Instruction: Check Multer's `diskStorage` (or other storage) options for `destination` (points to a server directory, e.g., `uploads/documents/`) and `filename` (generates a unique name, e.g., using `Date.now()` or `uuid` along with the original extension).
            *   Instruction: Verify `fileFilter` options are set to allow specific MIME types (e.g., PDF, DOC, DOCX, common image types based on `ALLOWED_FILE_TYPES` from PHP config) and `limits` are set for file size (based on `MAX_FILE_SIZE` from PHP config).
        3.  **Inspect controller and service logic for `POST /api/admin/documents`:**
            *   Instruction: Verify the controller accesses file information from `req.file` (e.g., `req.file.filename` for stored name, `req.file.originalname` for original name, `req.file.path` for full path) and text fields like `title`, `description`, `is_public` from `req.body`.
            *   Instruction: Confirm `title` is validated as non-empty.
            *   Instruction: Verify the service creates a new record in the `documents` table. The record must include `title`, `description`, `file_name` (stored unique filename), `file_path` (full path to the uploaded file on server), `uploaded_by` (from `req.user.id`), `is_public` (boolean from request), and `approved`.
            *   Instruction: Verify that if `is_public` is true, the `approved` status is set to `true`; otherwise, `approved` is set to `false`.
        4.  **Inspect audit logging:**
            *   Instruction: Verify an audit log entry is created for the document upload, including `adminId`, `action` ('document_upload'), and document details (e.g., new document ID, title).
        5.  **Inspect the physical file system on the server after a test upload:**
            *   Instruction: Confirm the uploaded file exists in the configured Multer destination directory with the generated unique filename.
        6.  **Inspect the API response:**
            *   Instruction: Verify that upon successful upload, the API returns the newly created document's metadata (from the database) with an HTTP status code of 201.

### User Story 9: Implement API to List and Retrieve Documents (User & Admin)
*   **As a** user (member or admin),
*   **I want** API endpoints to list available documents and retrieve specific document details and download the files, respecting access permissions (public vs. authenticated, approved status),
*   **So that** I can access shared HOA information relevant to my role.

    **Technical Requirements:**
    This involves multiple endpoints with varying access logic.
    1.  **List Documents Endpoint (e.g., `GET /api/documents`):**
        *   **Controller (`document.controller.js`):**
        *   **Service (`document.service.js`):**
            *   **If user is not authenticated (guest):** Fetches only documents where `is_public = true` AND `approved = true`. (Matches `documents.php` logic for non-logged-in users).
            *   **If user is authenticated (member or admin):** Fetches all documents (both public/private, approved/unapproved). (Matches `documents.php` logic for logged-in users which simply selects all; admin view in `manage_documents.php` also shows all). For the new API, to provide more granular control, an admin flag could be used: if admin, show all; if member, show all approved. Let's align with: Guest - public & approved; Member - all approved; Admin - all.
            *   **Data Projection:** Returns relevant metadata (id, title, description, uploaded_at, is_public, approved status, uploader name).
            *   **Pagination:** Support `limit` and `offset`.
        *   **Response:** List of document metadata objects.
    2.  **Retrieve Specific Document Metadata Endpoint (e.g., `GET /api/documents/:id`):**
        *   **Controller:** Extracts `id`.
        *   **Service:** Fetches document by `id`. Applies same access logic as listing based on auth state and document properties (`is_public`, `approved`).
        *   **Response:** Single document metadata object or 404/403.
    3.  **Download Document Endpoint (e.g., `GET /api/documents/:id/download`):**
        *   **Controller:** Extracts `id`.
        *   **Service:**
            *   Fetches document by `id`. If not found, 404.
            *   **Access Control (based on `download_document.php`):**
                *   If document `approved != 1` AND user is not 'admin': Deny access (403).
                *   If document `is_public != 1` AND user is not authenticated: Deny access (redirect to login in PHP, so 401/403 for API).
                *   Otherwise, allow download. This means: admins can download anything. Authenticated members can download approved non-public docs. Anyone can download approved public docs.
            *   If allowed, construct the full server file path from stored `file_path`.
            *   **File Serving:** Use `res.download(fullFilePath, document.file_name)` (where `document.file_name` is the original filename for download prompt, though `download_document.php` used basename of stored path, implies stored name was original name). For clarity, assume `file_name` in DB is the user-facing filename for download.
        *   **Security:** Ensure the path derived from `file_path` does not allow path traversal vulnerabilities. It should be an absolute path or resolved safely.

*   `[x] Done`
    *   **Acceptance Criteria:**
        1.  **Inspect controller and service logic for `GET /api/documents` (List Documents):**
            *   Instruction: If the request is unauthenticated, verify the query to the `documents` table filters for `is_public = true` AND `approved = true`.
            *   Instruction: If the request is authenticated by a 'member', verify the query filters for `approved = true`.
            *   Instruction: If the request is authenticated by an 'admin', verify the query fetches all documents without `is_public` or `approved` filters.
            *   Instruction: Verify pagination parameters (`limit`, `offset`) are correctly applied.
            *   Instruction: Check that the response is an array of document metadata objects, including uploader's name (joined from `users` table).
        2.  **Inspect controller and service logic for `GET /api/documents/:id` (Retrieve Metadata):**
            *   Instruction: Verify the service fetches the document by `id`.
            *   Instruction: Confirm access control logic matches the listing endpoint for visibility of metadata: Guest - public & approved; Member - all approved; Admin - all.
            *   Instruction: If access is denied, verify a 403 status is returned. If not found, 404.
            *   Instruction: If access is granted, verify the document metadata is returned.
        3.  **Inspect controller and service logic for `GET /api/documents/:id/download` (Download Document):**
            *   Instruction: Verify the service fetches the document by `id`.
            *   Instruction: Confirm download access control:
                *   If `document.approved` is false AND user is not 'admin', return 403.
                *   If `document.is_public` is false AND user is not authenticated, return 401 or 403.
                *   Otherwise, proceed to download.
            *   Instruction: If download is permitted, verify `res.download(absoluteFilePath, userFacingFileName)` is used. `absoluteFilePath` should be correctly resolved from the stored `file_path` in the database. `userFacingFileName` should be the original name of the file or the `title`.
            *   Instruction: Verify the `Content-Type` header is set based on the file's type if possible.

### User Story 10: Implement API for Admin to Manage Documents (Approve/Delete)
*   **As an** administrator,
*   **I want** API endpoints to approve pending documents and to delete existing documents (including their physical files),
*   **So that** I can curate the available documents and remove outdated or inappropriate ones.

    **Technical Requirements:**
    Admin-only, destructive operations.
    1.  **Approve Document Endpoint (e.g., `PUT /api/admin/documents/:id/approve`):**
        *   **Controller (`document.controller.js`):** Extracts `id`.
        *   **Service (`document.service.js`):**
            *   Fetches document by `id`. If not found, 404.
            *   **Database Interaction:** Sets `approved = true` for the document.
        *   **Audit Logging:** Logs approval.
        *   **Response:** Updated document metadata or success message.
    2.  **Delete Document Endpoint (e.g., `DELETE /api/admin/documents/:id`):**
        *   **Controller:** Extracts `id`.
        *   **Service:**
            *   Fetches document by `id` to get `file_path`. If not found, 404.
            *   **File System Interaction:** Deletes the physical file from the server path identified by `file_path` using `fs.unlink()`. Handle errors if file not found on disk but exists in DB (log error, but proceed with DB deletion).
            *   **Database Interaction:** Deletes the document record from `documents` table.
        *   **Audit Logging:** Logs deletion.
        *   **Response:** Success message (200 OK or 204 No Content).
    3.  **Authorization:** Both protected by JWT auth and 'admin' role.

*   `[x] Done`
    *   **Acceptance Criteria:**
        1.  **Inspect route definitions for admin document management:**
            *   Instruction: Verify an endpoint like `PUT /api/admin/documents/:documentId/approve` is defined and protected for 'admin' role.
            *   Instruction: Verify an endpoint like `DELETE /api/admin/documents/:documentId` is defined and protected for 'admin' role.
        2.  **Inspect controller and service logic for `PUT /api/admin/documents/:documentId/approve`:**
            *   Instruction: Verify the service fetches the document by `documentId`. If not found, ensure 404.
            *   Instruction: Confirm the `approved` field of the document is set to `true` and saved to the database.
            *   Instruction: Verify an audit log entry is created (e.g., `action: 'document_approval'`, `details: { documentId }`).
            *   Instruction: Verify the API returns the updated document metadata or a success message.
        3.  **Inspect controller and service logic for `DELETE /api/admin/documents/:documentId`:**
            *   Instruction: Verify the service fetches the document by `documentId` to retrieve its `file_path`. If not found, ensure 404.
            *   Instruction: Verify the code uses `fs.unlink()` or similar to delete the physical file from the server using the retrieved `file_path`. Log errors from `fs.unlink()` but proceed.
            *   Instruction: Confirm the document record is deleted from the `documents` table.
            *   Instruction: Verify an audit log entry is created (e.g., `action: 'document_deletion'`, `details: { documentId }`).
            *   Instruction: Verify the API returns a success status (e.g., 200 or 204).

---

## Epic: Announcements Management

### User Story 11: Implement API for Admin to Create Announcements
*   **As an** administrator,
*   **I want** an API endpoint to create new announcements with a title and content (which may include HTML formatting),
*   **So that** I can efficiently publish important information to the HOA community.

    **Technical Requirements:**
    *   **API Endpoint**:
        *   Method: `POST`
        *   URL: `/api/admin/announcements`
    *   **Request Body Structure & Validation Rules**:
        *   `title`: `string`, required, max length 255.
        *   `content`: `text`, required. (If HTML is allowed, server-side sanitization is crucial, e.g., using DOMPurify).
        *   `userId`: This will be derived from the authenticated admin user (e.g., `req.user.id` or similar, obtained via JWT authentication middleware) and will be used as `created_by` in the database. It is not part of the direct request body from the client.
        *   `expiresAt`: `date` (ISO 8601 format), optional. If provided, must be a date in the future.
    *   **Response Structure**:
        *   **Success (HTTP 201 Created)**:
            *   Body: The newly created announcement object.
            ```json
            {
              "id": 123,
              "title": "New Maintenance Schedule",
              "content": "<p>Details about the new schedule...</p>",
              "userId": 1, // or created_by
              "createdAt": "2025-06-01T10:00:00.000Z",
              "updatedAt": "2025-06-01T10:00:00.000Z",
              "expiresAt": "2025-07-01T23:59:59.000Z" // null if not provided
            }
            ```
        *   **Error (HTTP 400 Bad Request)**: For validation errors.
            ```json
            {
              "errors": [
                { "field": "title", "message": "Title cannot exceed 255 characters." },
                { "field": "expiresAt", "message": "Expiration date must be in the future." }
              ]
            }
            ```
        *   **Error (HTTP 401 Unauthorized)**: If the user is not authenticated.
        *   **Error (HTTP 403 Forbidden)**: If the authenticated user is not an admin.
    *   **Service Layer Logic Outline (`announcement.service.js`)**:
        1.  Receive validated data (`title`, `content`, optional `expiresAt`) and `userId` (from authenticated admin) from the controller.
        2.  If `content` is HTML and requires sanitization, ensure it has been sanitized by the controller or perform sanitization here.
        3.  Prepare the announcement object for database insertion:
            *   `title`
            *   `content` (sanitized)
            *   `created_by`: `userId`
            *   `expires_at`: `expiresAt` (if provided and valid)
            *   `created_at`, `updated_at`: Will be set by Sequelize.
        4.  If `expiresAt` is provided, validate that it's a date in the future. If not, throw a validation error.
        5.  Use the `Announcement` Sequelize model to save the object to the `announcements` table.
        6.  Log the "announcement_creation" action to the audit log (e.g., `auditService.logAdminAction(userId, 'announcement_creation', { announcementId: newAnnouncement.id, title: newAnnouncement.title })`).
        7.  Return the newly created announcement object (including `id`, `createdAt`, `updatedAt`).
    *   **Controller Layer Logic Outline (`announcement.controller.js`)**:
        1.  Extract `title`, `content`, and `expiresAt` (optional) from `req.body`.
        2.  Perform input validation:
            *   `title`: required, string, max length 255.
            *   `content`: required, text.
            *   `expiresAt`: optional, valid ISO 8601 date string.
        3.  If validation fails, return an HTTP 400 response with detailed error messages.
        4.  If `content` is intended to be HTML and needs sanitization (as per application policy for rich text editors), sanitize it using a library like DOMPurify: `const sanitizedContent = DOMPurify.sanitize(content);`.
        5.  Obtain `userId` from the authenticated user object attached by the authentication middleware (e.g., `req.user.id`).
        6.  Call `announcementService.createAnnouncement({ title, content: sanitizedContent || content, expiresAt }, userId)`.
        7.  Handle the service response:
            *   On successful creation, send an HTTP 201 Created response with the new announcement object.
            *   If the service throws a validation error (e.g., `expiresAt` not in future), send an HTTP 400 response.
            *   For other unexpected service errors, send an HTTP 500 Internal Server Error response.
    *   **Authorization**:
        *   This endpoint must be protected by JWT authentication middleware (`verifyToken`).
        *   It must also be protected by role-based authorization middleware ensuring only users with the 'admin' role can access it (`authorizeRoles('admin')`).

*   `[x] Completed`
    *   - Implementation complete.
    *   **Acceptance Criteria:**
        1.  **Inspect route definition for creating announcements:**
            *   Instruction: Verify an endpoint like `POST /api/admin/announcements` is defined and protected for 'admin' role.
        2.  **Inspect controller and service logic for `POST /api/admin/announcements`:**
            *   Instruction: Verify the controller expects `title` and `content` in the request body.
            *   Instruction: Confirm validation ensures `title` and `content` are not empty.
            *   Instruction: If `content` is expected to be HTML, verify a server-side HTML sanitization step (e.g., using `DOMPurify` or a similar library) is performed on the `content` before it's saved to the database.
            *   Instruction: Verify the service creates a new record in the `announcements` table, storing `title`, (sanitized) `content`, and `created_by` (from `req.user.id`).
        3.  **Inspect audit logging:**
            *   Instruction: Verify an audit log entry is created (e.g., `action: 'announcement_creation'`, `details: { announcementId, title }`).
        4.  **Inspect the API response:**
            *   Instruction: Verify that upon successful creation, the API returns the newly created announcement object (including its ID) with an HTTP status code of 201.

### User Story 12: Implement API to List Announcements (User)
*   **As an** authenticated user,
*   **I want** an API endpoint to list recent announcements, ordered by creation date,
*   **So that** I can stay informed about community news.

    **Technical Requirements:**
    *   **API Endpoint**:
        *   Method: `GET`
        *   URL: `/api/announcements`
    *   **Query Parameters**:
        *   `page`: `integer`, optional. Represents the page number for pagination.
            *   Default: `1`.
            *   Validation: Must be a positive integer (>= 1).
        *   `limit`: `integer`, optional. Represents the number of items per page.
            *   Default: `10`.
            *   Validation: Must be a positive integer (>= 1), recommended maximum of `100`.
        *   `status`: `string`, optional. Filters announcements by their active status.
            *   Allowed values: `active`.
            *   Default: `active`.
            *   Behavior: When `active`, only returns announcements where `expires_at` IS NULL OR `expires_at` > NOW().
        *   `sortBy`: `string`, optional. Field to sort the announcements by.
            *   Allowed values: `created_at`.
            *   Default: `created_at`.
        *   `sortOrder`: `string`, optional. Order of sorting.
            *   Allowed values: `ASC`, `DESC`.
            *   Default: `DESC`.
    *   **Response Structure (Success - HTTP 200 OK)**:
        *   The response will be a JSON object containing an array of announcement objects and pagination details.
        *   **Announcement Object Fields**:
            *   `id`: `integer` - The unique identifier of the announcement.
            *   `title`: `string` - The title of the announcement.
            *   `content`: `string` - The HTML content of the announcement (sanitized during creation).
            *   `created_at`: `datetime` (ISO 8601) - Timestamp of when the announcement was created.
            *   `created_by` (optional): `object` - Details of the user who created the announcement.
                *   `id`: `integer` - User ID.
                *   `name`: `string` - User's name.
            *   `expires_at`: `datetime` (ISO 8601) or `null` - Timestamp of when the announcement expires.
        *   **Example Success Response**:
            ```json
            {
              "data": [
                {
                  "id": 123,
                  "title": "Pool Maintenance Next Week",
                  "content": "<p>The community pool will be closed for maintenance...</p>",
                  "created_at": "2025-06-05T10:00:00.000Z",
                  "created_by": {
                    "id": 2,
                    "name": "Admin User"
                  },
                  "expires_at": "2025-06-15T23:59:59.000Z"
                }
                // ...other announcement objects
              ],
              "pagination": {
                "totalItems": 42,
                "totalPages": 5,
                "currentPage": 1,
                "limit": 10
              }
            }
            ```
    *   **Service Layer Logic (`announcement.service.js`)**:
        1.  Accept validated query parameters (`page`, `limit`, `status`, `sortBy`, `sortOrder`) from the controller.
        2.  Construct the database query for the `announcements` table:
            *   **Filtering**: Apply the `status` filter (e.g., `WHERE expires_at IS NULL OR expires_at > NOW()` if `status` is `active`).
            *   **Ordering**: Apply `ORDER BY [sortBy] [sortOrder]` (e.g., `created_at DESC`).
            *   **Pagination**: Calculate `offset` as `(page - 1) * limit`. Apply `LIMIT limit` and `OFFSET offset`.
        3.  Fetch the list of announcement records matching the criteria. Optionally join with the `users` table to include `created_by.name`.
        4.  Fetch the total count of records matching the filtering criteria (before applying pagination) to calculate `totalItems` and `totalPages`.
        5.  Return the list of announcements and the pagination object (`totalItems`, `totalPages`, `currentPage`, `limit`).
    *   **Controller Layer Logic (`announcement.controller.js`)**:
        1.  Extract `page`, `limit`, `status`, `sortBy`, `sortOrder` from `req.query`.
        2.  Validate query parameters, applying defaults if not provided or if invalid:
            *   `page`: Ensure positive integer, default `1`.
            *   `limit`: Ensure positive integer (e.g., 1-100), default `10`.
            *   `status`: Ensure valid value (e.g., `active`), default `active`.
            *   `sortBy`: Ensure valid value (e.g., `created_at`), default `created_at`.
            *   `sortOrder`: Ensure valid value (e.g., `ASC`, `DESC`), default `DESC`.
            *   If critical validation fails (e.g., non-integer page), consider returning HTTP 400 Bad Request. For non-critical, use defaults.
        3.  Call `announcementService.listAnnouncements({ validated_params })`.
        4.  On success from the service, construct the HTTP 200 OK response with the `data` (announcements list) and `pagination` object.
        5.  Handle potential errors from the service (e.g., database errors) by returning an appropriate HTTP 500 Internal Server Error.
    *   **Authorization**:
        *   Protected by JWT authentication middleware (`verifyToken`).
        *   Accessible to any authenticated user (e.g., 'member' or 'admin' roles).

*   `[x] Completed`
    *   - Implementation complete.
    *   **Acceptance Criteria:**
        1.  **Inspect route definition for listing announcements:**
            *   Instruction: Verify an endpoint like `GET /api/announcements` is defined and protected by authentication middleware (accessible to all authenticated users).
        2.  **Inspect controller and service logic for `GET /api/announcements`:**
            *   Instruction: Verify the service queries the `announcements` table.
            *   Instruction: Confirm the results are ordered by `created_at` in descending order.
            *   Instruction: Verify pagination parameters (`limit`, `offset`) are correctly applied to the query.
            *   Instruction: Check the response to ensure it's an array of announcement objects, each containing fields like `id`, `title`, `content`, `created_at`. (Note: `content` should be the sanitized HTML ready for rendering).
            *   Instruction: (Optional) Verify if `created_by` information (e.g., author's name) is included by joining with the `users` table.

### User Story 13: Implement API for Admin to Update and Delete Announcements
*   **As an** administrator,
*   **I want** API endpoints to update the title and/or content of existing announcements, and to delete announcements,
*   **So that** I can correct or remove outdated information.

    **Technical Requirements:**
    1.  **Update Announcement (Admin)**
        *   **API Endpoint**:
            *   Method: `PUT`
            *   URL: `/api/announcements/:id` (Protected by `isAdmin` middleware)
        *   **Request Body Structure & Validation Rules**:
            *   `title`: `string`, optional. If provided, max length 255.
            *   `content`: `text`, optional. If provided, must not be empty. (If HTML is allowed, server-side sanitization is crucial, e.g., using DOMPurify, consistent with create).
            *   `expires_at`: `date` (ISO 8601 format), optional, nullable. If provided (and not null), must be a valid date.
        *   **Response Structure**:
            *   **Success (HTTP 200 OK)**:
                *   Body: The updated announcement object.
                ```json
                {
                  "id": 123,
                  "title": "Updated Maintenance Schedule",
                  "content": "<p>Updated details about the schedule...</p>",
                  "created_by": 1,
                  "created_at": "2025-06-01T10:00:00.000Z",
                  "updated_at": "2025-06-01T10:05:00.000Z",
                  "expires_at": "2025-07-15T23:59:59.000Z" // or null
                }
                ```
            *   **Error (HTTP 400 Bad Request)**: For validation errors (e.g., invalid date format, title too long).
                ```json
                {
                  "errors": [
                    { "field": "title", "message": "Title cannot exceed 255 characters." },
                    { "field": "expires_at", "message": "expires_at must be a valid ISO 8601 date or null." }
                  ]
                }
                ```
            *   **Error (HTTP 401 Unauthorized)**: If the user is not authenticated.
            *   **Error (HTTP 403 Forbidden)**: If the authenticated user is not an admin.
            *   **Error (HTTP 404 Not Found)**: If the announcement with the given `id` does not exist.
        *   **Service Layer Logic Outline (`announcement.service.js`)**:
            1.  Receive `announcementId`, validated optional data (`title`, `content`, `expires_at`), and `userId` (from authenticated admin) from the controller.
            2.  Fetch the announcement by `announcementId` using the `Announcement` Sequelize model. If not found, throw a "Not Found" error (404).
            3.  If `content` is provided and requires sanitization, ensure it has been sanitized by the controller or perform sanitization here.
            4.  Apply updates: If `title` is provided, update `announcement.title`. If `content` is provided, update `announcement.content` (sanitized). If `expires_at` is provided (can be `null` to clear it or a date string), update `announcement.expires_at`.
            5.  If `expires_at` is provided and is not null, validate that it's a valid date.
            6.  Save the updated announcement object using `announcement.save()`.
            7.  Log the "announcement_update" action to the audit log (e.g., `auditService.logAdminAction(userId, 'announcement_update', { announcementId: announcement.id, updatedFields: ['title', 'content', 'expires_at'] })`).
            8.  Return the updated announcement object.
        *   **Controller Layer Logic Outline (`announcement.controller.js`)**:
            1.  Extract `id` from `req.params`.
            2.  Extract optional `title`, `content`, `expires_at` from `req.body`.
            3.  Perform input validation for provided fields:
                *   `title`: optional, string, max length 255.
                *   `content`: optional, text.
                *   `expires_at`: optional, valid ISO 8601 date string or null.
            4.  If validation fails, return an HTTP 400 response with detailed error messages.
            5.  If `content` is provided and intended to be HTML, sanitize it: `const sanitizedContent = DOMPurify.sanitize(content);`.
            6.  Obtain `userId` from `req.user.id`.
            7.  Call `announcementService.updateAnnouncement(id, { title, content: (content ? sanitizedContent : undefined), expires_at }, userId)`.
            8.  Handle the service response:
                *   On success, send HTTP 200 OK with the updated announcement.
                *   If service throws "Not Found", send HTTP 404.
                *   If service throws validation error, send HTTP 400.
                *   For other errors, send HTTP 500.

    2.  **Delete Announcement (Admin)**
        *   **API Endpoint**:
            *   Method: `DELETE`
            *   URL: `/api/announcements/:id` (Protected by `isAdmin` middleware)
        *   **Response Structure**:
            *   **Success (HTTP 204 No Content)**: Standard for successful deletion.
            *   **Error (HTTP 401 Unauthorized)**: If the user is not authenticated.
            *   **Error (HTTP 403 Forbidden)**: If the authenticated user is not an admin.
            *   **Error (HTTP 404 Not Found)**: If the announcement with the given `id` does not exist.
        *   **Service Layer Logic Outline (`announcement.service.js`)**:
            1.  Receive `announcementId` and `userId` (from authenticated admin) from the controller.
            2.  Fetch the announcement by `announcementId`. If not found, throw a "Not Found" error (404) to ensure an explicit 404 is returned if the resource doesn't exist.
            3.  If found, delete the announcement record using `announcement.destroy()`.
            4.  Log the "announcement_deletion" action to the audit log (e.g., `auditService.logAdminAction(userId, 'announcement_deletion', { announcementId })`).
            5.  Return success.
        *   **Controller Layer Logic Outline (`announcement.controller.js`)**:
            1.  Extract `id` from `req.params`.
            2.  Obtain `userId` from `req.user.id`.
            3.  Call `announcementService.deleteAnnouncement(id, userId)`.
            4.  Handle the service response:
                *   On success, send HTTP 204 No Content.
                *   If service throws "Not Found", send HTTP 404.
                *   For other errors, send HTTP 500.

    3.  **Authorization**: Both endpoints must be protected by JWT authentication middleware (`verifyToken`) and role-based authorization middleware ensuring only users with the 'admin' role can access them (`authorizeRoles('admin')`). This is typically handled at the router level for `/api/announcements/:id` for `PUT` and `DELETE` methods, likely using the existing `isAdmin` middleware pattern.

*   `[x] Implemented - Functionality complete and tested`
    *   **Acceptance Criteria:**
        1.  **Inspect route definitions for admin announcement management:**
            *   Instruction: Verify an endpoint `PUT /api/announcements/:announcementId` is defined and protected for 'admin' role (e.g., via `isAdmin` middleware).
            *   Instruction: Verify an endpoint `DELETE /api/announcements/:announcementId` is defined and protected for 'admin' role (e.g., via `isAdmin` middleware).
        2.  **Inspect controller and service logic for `PUT /api/announcements/:announcementId` (Update):**
            *   Instruction: Verify the controller expects optional `title`, `content`, and `expires_at` in the request body.
            *   Instruction: Confirm validation is applied to provided fields (e.g., `title` max length 255, `content` non-empty if present, `expires_at` is a valid ISO 8601 date or null).
            *   Instruction: If `content` is updatable and HTML, verify server-side HTML sanitization.
            *   Instruction: Verify the service fetches the announcement by `announcementId`. If not found, ensure a 404 status is returned.
            *   Instruction: Confirm the specified fields (`title`, `content`, `expires_at`) are updated in the database for the announcement.
            *   Instruction: Verify an audit log entry is created (e.g., `action: 'announcement_update'`, `details: { announcementId, updatedFields: ['title', 'content', 'expires_at'] }`).
            *   Instruction: Verify the API returns the updated announcement object with HTTP 200 OK on success.
            *   Instruction: Verify appropriate error responses (400 for validation, 401 for unauthorized, 403 for forbidden, 404 for not found).
        3.  **Inspect controller and service logic for `DELETE /api/announcements/:announcementId` (Delete):**
            *   Instruction: Verify the service attempts to delete the announcement from the `announcements` table by `announcementId`.
            *   Instruction: Verify an audit log entry is created (e.g., `action: 'announcement_deletion'`, `details: { announcementId }`).
            *   Instruction: Verify the API returns an HTTP 204 No Content status on success.
            *   Instruction: Verify appropriate error responses (401 for unauthorized, 403 for forbidden, 404 for not found).

---

## Epic: Events Management

### User Story 14: Implement API for Admin to Create Events
*   **As an** administrator,
*   **I want** an API endpoint to create new events with details like title, description, start/end dates and times, and location,
*   **So that** I can schedule and publicize community activities.

    **Technical Requirements:**
    *   **API Endpoint**:
        *   Method: `POST`
        *   URL: `/api/events` (This path will be protected by `authenticateToken` and `isAdmin` middleware at the route definition level).
    *   **Request Body Structure & Validation Rules**:
        *   `title`: (string, required, e.g., min length 3, max length 255)
        *   `description`: (text, required, e.g., min length 10)
        *   `event_date`: (date, required, must be a valid date, must be in the future)
        *   `location`: (string, required, e.g., max length 255)
        *   `created_by`: (This will be derived from the authenticated admin user (`req.user.id`) and not part of the direct request body from the client).
    *   **Response Structure**:
        *   Success (HTTP 201 Created): Body should include the newly created event object (including `id`, `title`, `description`, `event_date`, `end_date`, `location`, `created_by`, `createdAt`, `updatedAt`).
        *   Error (HTTP 400 Bad Request): For validation errors, include details.
        *   Error (HTTP 401 Unauthorized / 403 Forbidden): If the user is not authenticated or not an admin.
    *   **Service Layer Logic Outline**:
        *   Receive validated data and `userId` from controller.
        *   Prepare event object (including `created_by: userId`).
        *   **Note on `end_date`**: If the `Event` model has a non-nullable `end_date` field, it should default to the same value as `event_date` during creation, as `end_date` is not part of the explicit request body for this user story.
        *   Save to `Events` table using the `Event` model.
        *   Return created event object.
    *   **Controller Layer Logic Outline**:
        *   Extract data from `req.body`.
        *   (Validation will be handled by middleware before this controller function).
        *   Get `userId` from `req.user.id`.
        *   Call the event service's `createEvent` function.
        *   Handle service response and send appropriate HTTP response (201 on success, or error).
    *   **Audit Logging:** Log event creation (e.g., `action: 'event_creation'`, details: event ID, title).

*   `[x] Completed`
    *   - Implementation complete.
    *   **Acceptance Criteria:**
        1.  **Inspect route definition for creating events:**
            *   Instruction: Verify an API endpoint `POST /api/events` is defined.
            *   Instruction: Verify this route is protected by `authenticateToken` and `isAdmin` (or equivalent 'admin' role) middleware.
        2.  **Inspect controller layer logic for `POST /api/events`:**
            *   Instruction: Verify the controller extracts `title`, `description`, `event_date`, and `location` from `req.body`.
            *   Instruction: Verify `userId` is obtained from `req.user.id`.
            *   Instruction: Verify the controller calls a service function (e.g., `eventService.createEvent`) with the validated data and `userId`.
            *   Instruction: Verify the controller sends an HTTP 201 response with the created event object on success.
            *   Instruction: Verify appropriate error responses (400, 401, 403) are handled.
        3.  **Inspect request body validation rules (likely in middleware or controller):**
            *   Instruction: Confirm `title` is required (string, min length 3, max length 255).
            *   Instruction: Confirm `description` is required (text, min length 10).
            *   Instruction: Confirm `event_date` is required (valid date, must be in the future).
            *   Instruction: Confirm `location` is required (string, max length 255).
        4.  **Inspect service layer logic for creating events:**
            *   Instruction: Verify the service receives validated data and `userId`.
            *   Instruction: Verify an event object is prepared, including `created_by: userId`.
            *   Instruction: Verify the event object is saved to the `Events` table using the `Event` model.
            *   Instruction: Verify the newly created event object (including `id`, `createdAt`, `updatedAt`) is returned.
        5.  **Inspect response structure for success (HTTP 201):**
            *   Instruction: Verify the response body includes the newly created event object with fields: `id`, `title`, `description`, `event_date`, `location`, `created_by`, `createdAt`, `updatedAt`.
        6.  **Inspect audit logging:**
            *   Instruction: Verify an audit log entry is created for event creation (e.g., `action: 'event_creation'`, `details: { eventId, title }`).

### User Story 15: Implement API to List Events (User)
*   **As an** authenticated user,
*   **I want** an API endpoint to list community events, with options to filter for upcoming events, ordered by start date,
*   **So that** I can easily find out what's happening.

    **Technical Requirements:**
    1.  **Endpoint:**
        *   `GET /api/events`
        *   **Controller (`event.controller.js`):** Handles incoming requests, validates query parameters, and calls the service layer.
        *   **Service (`event.service.js`):** Contains business logic for fetching, filtering, sorting, and paginating events.

    2.  **Query Parameters:**
        *   `status`: (string, optional) Filters events by their status.
            *   Allowed values: `upcoming`, `past`.
            *   Default: `upcoming`.
            *   Behavior:
                *   `upcoming`: Returns events where `event_date` is greater than the current date/time.
                *   `past`: Returns events where `event_date` is less than or equal to the current date/time.
        *   `page`: (integer, optional) Page number for pagination.
            *   Default: `1`.
            *   Validation: Must be a positive integer (>= 1).
        *   `limit`: (integer, optional) Number of items per page.
            *   Default: `10`.
            *   Validation: Must be a positive integer (>= 1), recommended maximum of `50`.
        *   `sortBy`: (string, optional) Field to sort events by.
            *   Allowed values: `event_date`, `title`, `created_at`. (Assuming `event_date` refers to the primary sortable date of the event, likely its start).
            *   Default: `event_date`.
        *   `sortOrder`: (string, optional) Order of sorting.
            *   Allowed values: `asc`, `desc`.
            *   Default: `asc` when `sortBy=event_date` and `status=upcoming` (or default status). `desc` when `sortBy=event_date` and `status=past`. `desc` for `created_at`. `asc` for `title`.

    3.  **Success Response Body (200 OK):**
        *   The response will be a JSON object containing an array of event objects and pagination metadata.
        *   **Structure Example:**
            ```json
            {
              "data": [
                {
                  "id": 1,
                  "title": "Community BBQ",
                  "description": "Join us for a fun community BBQ event.",
                  "event_date": "2025-07-15T18:00:00.000Z",
                  "location": "Community Park Pavilion",
                  "created_by": {
                    "id": 5,
                    "name": "Admin User"
                  },
                  "created_at": "2025-06-01T10:00:00.000Z",
                  "updated_at": "2025-06-01T10:00:00.000Z"
                }
                // ... more event objects
              ],
              "pagination": {
                "totalItems": 25,
                "totalPages": 3,
                "currentPage": 1,
                "limit": 10,
                "hasNextPage": true,
                "hasPrevPage": false
              }
            }
            ```
        *   **Event Item Fields:**
            *   `id`: (integer) Unique identifier of the event.
            *   `title`: (string) Title of the event.
            *   `description`: (text) Description of the event.
            *   `event_date`: (datetime ISO 8601) The primary date and time for the event.
            *   `location`: (string) Location of the event.
            *   `created_by` (object, optional): Details of the user who created the event.
                *   `id`: (integer) User ID of the creator.
                *   `name`: (string) Name of the creator.
            *   `created_at`: (datetime ISO 8601) Timestamp of when the event was created.
            *   `updated_at`: (datetime ISO 8601) Timestamp of the last update to the event.

    4.  **Error Responses:**
        *   **400 Bad Request:** If query parameters are invalid (e.g., non-integer `page`/`limit`, invalid `status` value, unrecognized `sortBy`/`sortOrder` values).
            ```json
            {
              "errors": [
                { "param": "page", "message": "Page must be a positive integer." },
                { "param": "status", "message": "Invalid status value. Allowed: upcoming, past." }
              ]
            }
            ```
        *   **401 Unauthorized:** If the JWT token is missing or invalid.
            ```json
            {
              "error": "Unauthorized"
            }
            ```
        *   **500 Internal Server Error:** For unexpected server-side issues.
            ```json
            {
              "error": "Internal Server Error"
            }
            ```

    5.  **Authentication/Authorization:**
        *   Requires an active, valid JWT for an authenticated user.
        *   Accessible by users with 'member' or 'admin' roles.

*   `[x] Implemented - Functionality complete and tested`
    *   **Acceptance Criteria:**
        1.  **Inspect route definition for listing events:**
            *   Instruction: Verify an endpoint `GET /api/events` is defined.
            *   Instruction: Verify this route is protected by authentication middleware (e.g., `verifyToken`), making it accessible to authenticated users ('member', 'admin').

        2.  **Default Behavior (No Query Parameters):**
            *   Instruction: When a `GET` request is made to `/api/events` without any query parameters, the API should return a paginated list of `upcoming` events.
            *   Instruction: Upcoming events should be sorted by `event_date` in ascending order by default.
            *   Instruction: Default pagination should be applied (e.g., `page=1`, `limit=10`).
            *   Instruction: The response should include pagination metadata (`totalItems`, `totalPages`, `currentPage`, `limit`, `hasNextPage`, `hasPrevPage`).

        3.  **Filtering by Status:**
            *   Instruction: Given a `GET` request to `/api/events?status=upcoming`, the API returns only events where `event_date` is in the future, sorted by `event_date` ascending.
            *   Instruction: Given a `GET` request to `/api/events?status=past`, the API returns only events where `event_date` is in the past, sorted by `event_date` descending.
            *   Instruction: Given an invalid `status` value (e.g., `/api/events?status=invalid`), the API returns a 400 Bad Request error with a descriptive message.

        4.  **Pagination:**
            *   Instruction: Given a `GET` request to `/api/events?page=2&limit=5`, the API returns the second page of events, with a maximum of 5 events per page.
            *   Instruction: Verify the `pagination` object in the response correctly reflects `currentPage=2`, `limit=5`, and accurate `totalItems`, `totalPages`, `hasNextPage`, `hasPrevPage`.
            *   Instruction: Given invalid pagination parameters (e.g., `page=0`, `limit=-5`, `page=abc`), the API returns a 400 Bad Request error with descriptive messages for each invalid parameter.

        5.  **Sorting:**
            *   Instruction: Given a `GET` request to `/api/events?sortBy=title&sortOrder=asc`, the API returns events sorted by `title` in ascending order.
            *   Instruction: Given a `GET` request to `/api/events?status=past&sortBy=created_at&sortOrder=desc`, the API returns past events sorted by their creation date in descending order.
            *   Instruction: Given invalid `sortBy` or `sortOrder` values (e.g., `/api/events?sortBy=invalidField`), the API returns a 400 Bad Request error with a descriptive message.

        6.  **Response Data Structure:**
            *   Instruction: Verify each event object in the `data` array contains `id`, `title`, `description`, `event_date`, `location`, `created_at`, `updated_at`.
            *   Instruction: (Optional) If creator details are included, verify the `created_by` object contains `id` and `name`.
            *   Instruction: Verify timestamps (`event_date`, `created_at`, `updated_at`) are in ISO 8601 format.

        7.  **Handling No Events:**
            *   Instruction: If there are no events matching the criteria (e.g., no upcoming events, or a filter results in an empty set), the API returns a 200 OK response with an empty `data` array and appropriate pagination metadata (e.g., `totalItems=0`, `totalPages=0`).

        8.  **Authentication/Authorization:**
            *   Instruction: Given a request to `/api/events` without a valid JWT, the API returns a 401 Unauthorized error.

### User Story 16: Implement API for Admin to Update and Delete Events
*   **As an** administrator,
*   **I want** API endpoints to update the details of existing events and to delete events,
*   **So that** I can manage the event schedule and correct any inaccuracies.

    **Technical Requirements:**
    1.  **Update Endpoint (e.g., `PUT /api/admin/events/:id`):**
        *   **Controller (`event.controller.js`):** Extracts `id`; receives fields for update in `req.body`.
        *   **Validation:** Validate any provided fields (e.g., date formats, `end_date` after `start_date`).
        *   **Service (`event.service.js`):**
            *   Fetches event by `id`. If not found, 404.
            *   **Database Interaction:** Updates the specified fields.
        *   **Audit Logging:** Log event update (e.g., `action: 'event_update'`, details: ID, title). PHP app was missing this.
        *   **Response:** Updated event object.
    2.  **Delete Endpoint (e.g., `DELETE /api/admin/events/:id`):**
        *   **Controller:** Extracts `id`.
        *   **Service:**
            *   Fetches event by `id`. If not found, 404.
            *   **Database Interaction:** Deletes record from `events` table.
        *   **Audit Logging:** Log event deletion (e.g., `action: 'event_deletion'`, details: ID). PHP app was missing this for `manage_events.php` specifically.
        *   **Response:** Success message (200 OK or 204 No Content).
    3.  **Authorization:** Both protected by JWT auth and 'admin' role.

*   **Status:** `[x] Implemented - Functionality complete and tested` <!-- Or [ ] To Do, [>] In Progress, [x] Done, [-] Blocked, [!] Needs Review -->
    *   **Acceptance Criteria:**
        1.  **Inspect route definitions for admin event management:**
            *   Instruction: Verify an endpoint like `PUT /api/admin/events/:eventId` is defined and protected for 'admin' role.
            *   Instruction: Verify an endpoint like `DELETE /api/admin/events/:eventId` is defined and protected for 'admin' role.
        2.  **Inspect controller and service logic for `PUT /api/admin/events/:eventId` (Update):**
            *   Instruction: Verify the controller accepts event fields (e.g., `title`, `description`, `start_date`, `end_date`, `location`) in the request body for update.
            *   Instruction: Confirm validation is applied to any provided fields.
            *   Instruction: Verify the service fetches the event by `eventId`. If not found, ensure a 404.
            *   Instruction: Confirm the specified fields are updated in the database.
            *   Instruction: Verify an audit log entry is created (e.g., `action: 'event_update'`).
            *   Instruction: Verify the API returns the updated event object.
        3.  **Inspect controller and service logic for `DELETE /api/admin/events/:eventId` (Delete):**
            *   Instruction: Verify the service attempts to delete the event from the `events` table by `eventId`. If not found, ensure a 404 status is returned. If found and deleted, verify the API returns a success status (e.g., 200 or 204).
            *   Instruction: Verify an audit log entry is created (e.g., `action: 'event_deletion'`).
            *   Instruction: Verify the API returns a success status (e.g., 200 or 204).

---

## Epic: Discussions Management

### User Story 17: Implement API to Create Discussion Threads and Replies (User)
*   **As an** authenticated user,
*   **I want** API endpoints to create new discussion threads (with a title and content) and to post replies (with content) to existing threads,
*   **So that** I can actively participate in community conversations by initiating topics and responding to others.

    **Technical Requirements:**
    1.  **Create Thread Endpoint (e.g., `POST /api/discussions`):**
        *   **Controller (`discussion.controller.js`):** Receives `title` and `content` from `req.body`.
        *   **Validation:** `title` and `content` are required and non-empty.
        *   **Sanitization:** If `content` can be HTML, sanitize it server-side (e.g., DOMPurify).
        *   **Service (`discussion.service.js`):**
            *   **Database Interaction:** Creates a new record in `discussions` table with `title`, sanitized `content`, `created_by` (user's ID from `req.user`), and `parent_id` set to `NULL`. `document_id` is also `NULL` unless linked.
        *   **Response:** Returns the created discussion thread object and 201 Created.
    2.  **Post Reply Endpoint (e.g., `POST /api/discussions/:threadId/replies`):**
        *   **Controller:** Extracts `threadId` from path; receives `content` from `req.body`.
        *   **Validation:** `content` is required and non-empty. `threadId` must correspond to an existing main discussion thread (where `parent_id` is `NULL`).
        *   **Sanitization:** Sanitize `content` if HTML.
        *   **Service:**
            *   **Database Interaction:** Creates a new record in `discussions` table with `title` set to `NULL`, sanitized `content`, `created_by` (user's ID), and `parent_id` set to `threadId`.
        *   **Response:** Returns the created reply object and 201 Created.
    3.  **Authorization:** Both endpoints protected by JWT auth (accessible to 'member' or 'admin').

*   `[x] Done`
    *   **Acceptance Criteria:**
        1.  **Inspect route definition for creating discussion threads:**
            *   Instruction: Verify an endpoint like `POST /api/discussions` is defined and protected by authentication.
        2.  **Inspect controller and service logic for `POST /api/discussions` (Create Thread):**
            *   Instruction: Verify the controller expects `title` and `content` in `req.body`.
            *   Instruction: Confirm validation for non-empty `title` and `content`.
            *   Instruction: If `content` is HTML, verify server-side sanitization.
            *   Instruction: Verify a new record is inserted into `discussions` with `title`, `content`, `created_by` (current user's ID), and `parent_id` as `NULL`.
            *   Instruction: Verify the API returns the created thread object with status 201.
        3.  **Inspect route definition for posting replies:**
            *   Instruction: Verify an endpoint like `POST /api/discussions/:threadId/replies` is defined and protected by authentication.
        4.  **Inspect controller and service logic for `POST /api/discussions/:threadId/replies` (Post Reply):**
            *   Instruction: Verify the controller extracts `threadId` from path and expects `content` in `req.body`.
            *   Instruction: Confirm validation for non-empty `content`. Verify `threadId` is validated to exist and be a main thread.
            *   Instruction: If `content` is HTML, verify server-side sanitization.
            *   Instruction: Verify a new record is inserted into `discussions` with `content`, `created_by` (current user's ID), `parent_id` as `threadId`, and `title` as `NULL`.
            *   Instruction: Verify the API returns the created reply object with status 201.

### User Story 18: Implement API to List Discussion Threads and View a Thread with Replies (User)
*   **As an** authenticated user,
*   **I want** API endpoints to list all main discussion threads (with author and reply count) and to view a specific thread along with all its replies (with authors), ordered chronologically,
*   **So that** I can browse, read, and follow community conversations.

    **Technical Requirements:**
    1.  **List Threads Endpoint (e.g., `GET /api/discussions`):**
        *   **Controller (`discussion.controller.js`):**
        *   **Service (`discussion.service.js`):**
            *   **Database Interaction:** Fetches records from `discussions` where `parent_id IS NULL`. Order by `created_at` DESC.
            *   **Data Augmentation:** For each thread, include author's name (join `users` on `created_by`) and a count of replies (subquery or a join with aggregation on `discussions` where `parent_id` matches the thread's ID).
            *   **Pagination:** Support `limit` and `offset`.
            *   **Response:** List of thread objects, each including `id`, `title`, `content` (snippet or full), `created_at`, `author_name`, `reply_count`.
    2.  **View Thread with Replies Endpoint (e.g., `GET /api/discussions/:threadId`):**
        *   **Controller:** Extracts `threadId`.
        *   **Service:**
            *   **Fetch Main Thread:** Fetches the main discussion record by `threadId` (where `parent_id IS NULL`). Include author's name. If not found, 404.
            *   **Fetch Replies:** Fetches all records from `discussions` where `parent_id = threadId`. Order by `created_at` ASC. Include author's name for each reply.
            *   **Response:** An object containing the main thread details and an array of its replies.
    3.  **Authorization:** Both protected by JWT auth.

*   `[x] Done`
    *   **Acceptance Criteria:**
        1.  **Inspect route definition for listing discussion threads:**
            *   Instruction: Verify an endpoint like `GET /api/discussions` is defined and protected by authentication.
        2.  **Inspect controller and service logic for `GET /api/discussions` (List Threads):**
            *   Instruction: Verify the service queries `discussions` for records where `parent_id IS NULL`, ordered by `created_at` DESC.
            *   Instruction: Confirm it joins with `users` to get the author's name for each thread.
            *   Instruction: Verify it calculates or retrieves a `reply_count` for each thread.
            *   Instruction: Verify pagination is supported.
            *   Instruction: Check the response format for an array of threads with expected fields.
        3.  **Inspect route definition for viewing a single thread with replies:**
            *   Instruction: Verify an endpoint like `GET /api/discussions/:threadId` is defined and protected by authentication.
        4.  **Inspect controller and service logic for `GET /api/discussions/:threadId` (View Thread):**
            *   Instruction: Verify the service first fetches the main thread by `threadId` (where `parent_id IS NULL`), joining with `users` for author name. If not found, ensure 404.
            *   Instruction: Verify it then fetches all replies where `parent_id = threadId`, ordered by `created_at` ASC, joining with `users` for each reply's author name.
            *   Instruction: Check the response structure: an object containing the main thread details and an array of reply objects.

### User Story 19: Implement API for Admin to Delete Discussion Threads and Replies
*   **As an** administrator,
*   **I want** API endpoints to delete entire discussion threads (including all their replies) or to delete individual replies,
*   **So that** I can effectively moderate community discussions by removing inappropriate or irrelevant content.

    **Technical Requirements:**
    1.  **Delete Thread Endpoint (e.g., `DELETE /api/admin/discussions/:threadId`):**
        *   **Controller (`discussion.controller.js`):** Extracts `threadId`.
        *   **Service (`discussion.service.js`):**
            *   Verify `threadId` refers to a main thread.
            *   **Database Interaction (Transaction):**
                *   Delete all replies where `parent_id = threadId`.
                *   Delete the main thread record itself.
                *   These operations should be within a database transaction.
        *   **Audit Logging:** Logs thread deletion (e.g., `action: 'discussion_deletion'`, details: thread ID, title). Matches `manage_discussions.php`.
        *   **Response:** Success message (200 OK or 204 No Content).
    2.  **Delete Reply Endpoint (e.g., `DELETE /api/admin/discussions/replies/:replyId`):**
        *   **Controller:** Extracts `replyId`.
        *   **Service:**
            *   Verify `replyId` refers to a reply (i.e., `parent_id IS NOT NULL`).
            *   **Database Interaction:** Deletes the specific reply record by `id = replyId`.
        *   **Audit Logging:** Logs reply deletion (e.g., `action: 'reply_deletion'`, details: reply ID). Matches `manage_discussions.php`.
        *   **Response:** Success message.
    3.  **Authorization:** Both protected by JWT auth and 'admin' role.

*   `[x] Done`
    *   **Acceptance Criteria:**
        1.  **Inspect route definitions for admin discussion management:**
            *   Instruction: Verify an endpoint like `DELETE /api/admin/discussions/:threadId` is defined and protected for 'admin' role.
            *   Instruction: Verify an endpoint like `DELETE /api/admin/discussions/replies/:replyId` is defined and protected for 'admin' role.
        2.  **Inspect controller and service logic for `DELETE /api/admin/discussions/:threadId` (Delete Thread):**
            *   Instruction: Verify the service checks that `threadId` exists and is a main thread.
            *   Instruction: Confirm that, within a transaction, it first deletes all records from `discussions` where `parent_id = threadId`.
            *   Instruction: Confirm it then deletes the main thread record (where `id = threadId`).
            *   Instruction: Verify an audit log entry is created (e.g., `action: 'discussion_deletion'`, `details: { threadId, title }`).
            *   Instruction: Verify a success status is returned.
        3.  **Inspect controller and service logic for `DELETE /api/admin/discussions/replies/:replyId` (Delete Reply):**
            *   Instruction: Verify the service checks that `replyId` exists and is a reply (`parent_id IS NOT NULL`).
            *   Instruction: Confirm it deletes the record from `discussions` where `id = replyId`.
            *   Instruction: Verify an audit log entry is created (e.g., `action: 'reply_deletion'`, `details: { replyId }`).
            *   Instruction: Verify a success status is returned.

---

## Epic: Configuration Management (Admin)

### User Story 20: Implement API for Admin to Manage Site Configuration
*   **As an** administrator (with 'system' or equivalent high-level admin privileges, typically 'admin' role for simplicity unless a distinct 'system' role is strictly necessary),
*   **I want** API endpoints to view all site configuration key-value pairs and to update the value for a specific configuration key,
*   **So that** I can customize site-wide settings like the HOA name or description.

    **Technical Requirements:**
    1.  **Get Configuration Endpoint (e.g., `GET /api/admin/config`):**
        *   **Controller (`config.controller.js`):**
        *   **Service (`config.service.js`):**
            *   **Database Interaction:** Fetches all records from `config` table.
        *   **Response:** An object or array of key-value pairs.
    2.  **Update Configuration Endpoint (e.g., `PUT /api/admin/config/:key`):**
        *   **Controller:** Extracts `key` from path; receives `value` in `req.body`.
        *   **Validation:** `value` should not be empty.
        *   **Service:**
            *   **Database Interaction:** Updates the `value` for the given `key` in `config` table. If key doesn't exist, it should perform an "upsert" (insert or replace, as in PHP's `INSERT OR REPLACE`).
        *   **Audit Logging:** Log config update (e.g., `action: 'config_update'`, details: key, new value). PHP was missing this.
        *   **Response:** Updated config item or success message.
    3.  **Authorization:** Both protected by JWT auth and 'admin' role. (PHP used 'system' role for `manage_config.php`; decide if this distinction is needed or if 'admin' suffices. For simplicity, 'admin' is assumed here).

*   `[x] Done`
    *   **Acceptance Criteria:**
        1.  **Inspect route definitions for configuration management:**
            *   Instruction: Verify an endpoint like `GET /api/admin/config` is defined and protected for 'admin' role.
            *   Instruction: Verify an endpoint like `PUT /api/admin/config/:configKey` is defined and protected for 'admin' role.
        2.  **Inspect controller and service logic for `GET /api/admin/config`:**
            *   Instruction: Verify the service queries the `config` table and returns all key-value pairs.
            *   Instruction: Check the response format (e.g., an object where keys are config keys, or an array of `{key, value}` objects).
        3.  **Inspect controller and service logic for `PUT /api/admin/config/:configKey`:**
            *   Instruction: Verify the controller extracts `configKey` from path and expects `value` in `req.body`.
            *   Instruction: Confirm validation for non-empty `value`.
            *   Instruction: Verify the service performs an "upsert" operation (insert if key doesn't exist, update if it does) on the `config` table for the given `configKey` and `value`.
            *   Instruction: Verify an audit log entry is created (e.g., `action: 'config_update'`, `details: { key: configKey, value: newValue }`).
            *   Instruction: Verify the API returns the updated config item or a success message.

---

## Epic: Audit Logging

### User Story 21: Implement Centralized Audit Logging Service/Utility
*   **As a** backend developer,
*   **I want** a centralized service or utility function for logging administrative actions consistently across various modules,
*   **So that** all auditable events are recorded with necessary details (admin ID, action type, specific details, timestamp) into the `audit_logs` table.

    **Technical Requirements:**
    1.  **Utility/Service (`audit.service.js` or `utils/logger.js`):**
        *   Define a function like `async logAdminAction(adminId, action, details)`.
        *   `adminId`: The ID of the admin performing the action (from `req.user.id`).
        *   `action`: A string identifier for the action (e.g., 'user_creation', 'document_approval', 'announcement_delete').
        *   `details`: A JSON object or string containing relevant specifics (e.g., `{ targetUserId: 123, newRole: 'admin' }` or "Deleted document ID 45").
        *   **Database Interaction:** This function will use the `AuditLog` Sequelize model to create a new entry in the `audit_logs` table. `created_at` will be set automatically.
    2.  **Integration:** This `logAdminAction` function must be called from all relevant service methods or controller actions that perform auditable administrative operations (as identified in previous user stories).

*   `[x] Done`
    *   **Acceptance Criteria:**
        1.  **Inspect `audit.service.js` (or a similar utility file):**
            *   Instruction: Verify a function, e.g., `logAdminAction(adminId, action, details)`, is defined.
            *   Instruction: Check that this function accepts parameters for the administrator's ID, a string describing the action, and an object/string for additional details.
            *   Instruction: Verify this function uses the `AuditLog` Sequelize model to `create` a new record in the `audit_logs` table with the provided `admin_id`, `action`, `details`, and an automatically generated `created_at` timestamp.
        2.  **Review various admin-related service or controller files (e.g., `admin.user.service.js`, `document.service.js` for admin actions, `announcement.service.js` for admin actions, etc.):**
            *   Instruction: For each administrative CUD (Create, Update, Delete) operation that should be audited (e.g., user role change, document approval, announcement deletion), confirm that the `logAdminAction` function is called with appropriate parameters.
            *   Instruction: Example: After successfully updating a user's role, ensure `auditService.logAdminAction(req.user.id, 'user_role_update', { userId: targetUser.id, newRole: newRole })` or similar is invoked.

### User Story 22: Implement API for Admin to View Audit Logs
*   **As an** administrator,
*   **I want** an API endpoint to view audit logs, paginated and ordered by the most recent entries, including the name of the admin who performed the action,
*   **So that** I can track administrative activities and review system changes.

    **Technical Requirements:**
    1.  **Endpoint (e.g., `GET /api/admin/audit-logs`):**
        *   **Controller (`audit.controller.js`):**
        *   **Service (`audit.service.js`):**
            *   **Database Interaction:** Fetches records from `audit_logs` table.
            *   **Join:** Join with `users` table on `audit_logs.admin_id = users.id` to retrieve the admin's name (`users.name`).
            *   **Ordering:** Order by `created_at` DESC.
            *   **Pagination:** Support `limit` and `offset`.
        *   **Response:** List of audit log objects, each including `id`, `admin_name`, `action`, `details`, `created_at`.
    2.  **Authorization:** Protected by JWT auth and 'admin' role. (PHP `audit_log.php` allowed any logged-in user; this should be restricted to admins).

*   `[x] Done`
    *   **Acceptance Criteria:**
        1.  **Inspect route definition for viewing audit logs:**
            *   Instruction: Verify an endpoint like `GET /api/admin/audit-logs` is defined and protected for 'admin' role.
        2.  **Inspect controller and service logic for `GET /api/admin/audit-logs`:**
            *   Instruction: Verify the service queries the `audit_logs` table.
            *   Instruction: Confirm it performs a join with the `users` table using `audit_logs.admin_id` to fetch the `name` of the admin user.
            *   Instruction: Verify results are ordered by `audit_logs.created_at` in descending order.
            *   Instruction: Verify pagination parameters (`limit`, `offset`) are applied.
            *   Instruction: Check the response format: an array of audit log objects, each including at least `id`, `admin_name` (from the joined users table), `action`, `details` (as stored), and `created_at`.

---

## Epic: Database Setup & Migration

### User Story 23: Setup Node.js Project with Database (SQLite) and ORM (Sequelize)
*   **As a** backend developer,
*   **I want** to initialize the Node.js project with SQLite as the database and Sequelize as the ORM, defining all necessary models (Users, Documents, Announcements, Events, Discussions, Config, AuditLogs, VerificationTokens) and their relationships as per the existing schema,
*   **So that** the application has a structured way to interact with the database, manage its schema through migrations, and ensure data integrity.

    **Technical Requirements:**
    1.  **Project Initialization:** `npm init` or `yarn init`. Install `express`, `sequelize`, `sqlite3`, `bcrypt`, `jsonwebtoken`, `multer`, `dotenv`, `joi` (or `express-validator`), `dompurify` (if server-side HTML sanitization for rich text is chosen), and development dependencies.
    2.  **Sequelize Setup:**
        *   Initialize Sequelize CLI (`npx sequelize-cli init`).
        *   Configure `config/config.json` (or JS) to use SQLite, pointing to a database file (e.g., `database/hoa.db` to match PHP structure).
    3.  **Model Definition:** Create Sequelize models for all tables derived from `db_connect.php`:
        *   `User`: id, name, email, password, role, status, email_verified, is_system_user, created_at.
        *   `Config`: key, value.
        *   `VerificationToken`: id, user_id, token, type, created_at, expires_at.
        *   `Event`: id, title, description, start_date, end_date, location, created_by, created_at.
        *   `Document`: id, title, description, file_name (stored unique name), file_path (server path), uploaded_by, uploaded_at, approved, is_public. (Note: `file_name` and `file_path` distinction as per User Story 8).
        *   `Discussion`: id, title (nullable for replies), content, created_by, created_at, parent_id, document_id.
        *   `Announcement`: id, title, content, created_by, created_at.
        *   `AuditLog`: id, admin_id, action, details, created_at.
        *   Define all columns with correct Sequelize data types, constraints (`allowNull`, `unique`, `defaultValue`), and foreign key associations (e.g., `User.hasMany(Event, { foreignKey: 'created_by' })`).
    4.  **Migrations:** Use Sequelize CLI to generate migrations for creating each table and defining indexes.
    5.  **Database Initialization Script/Seeders:**
        *   Script to run all migrations (`npx sequelize-cli db:migrate`).
        *   Seed initial `config` data (HOA Name, etc.).
        *   Seed initial system admin user.
    6.  **Connection:** Establish and export Sequelize instance and models (typically `models/index.js`).

*   `[x] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `package.json`:**
            *   Instruction: Verify `sequelize`, `sqlite3`, `express`, `bcrypt`, `jsonwebtoken`, `multer`, `dotenv`, and chosen validation/sanitization libraries are listed as dependencies.
        2.  **Inspect Sequelize CLI configuration (e.g., `config/config.json` or `.sequelizerc`):**
            *   Instruction: Verify the 'development' (and other relevant environments) configuration points to an SQLite database file (e.g., path to `database/hoa.db`).
        3.  **Inspect model files (e.g., `models/user.js`, `models/document.js`, etc.):**
            *   Instruction: For each table (`User`, `Config`, `VerificationToken`, `Event`, `Document`, `Discussion`, `Announcement`, `AuditLog`), verify a corresponding Sequelize model file exists.
            *   Instruction: In each model file, verify all columns are defined with Sequelize data types accurately reflecting the original schema from `db_connect.php` (e.g., `DataTypes.STRING`, `DataTypes.INTEGER`, `DataTypes.BOOLEAN`, `DataTypes.DATE`, `DataTypes.TEXT`).
            *   Instruction: Verify constraints like `allowNull: false`, `unique: true`, `defaultValue` are correctly set.
            *   Instruction: Verify foreign key associations (e.g., `User.hasMany(Announcement, { foreignKey: 'created_by' })`, `Announcement.belongsTo(User, { as: 'creator', foreignKey: 'created_by' })`) are defined in the `associate` method of the models. Specifically check `Discussions.belongsTo(Discussions, { as: 'parentThread', foreignKey: 'parent_id' })` and `Discussions.hasMany(Discussions, { as: 'replies', foreignKey: 'parent_id' })`.
        4.  **Inspect migration files (in `migrations/` directory):**
            *   Instruction: Verify a set of migration files exists, capable of creating all tables from scratch, including defining primary keys, foreign keys, indexes, and constraints.
            *   Instruction: Check the `up` method in each migration to ensure it uses `queryInterface.createTable` with correct column definitions and `queryInterface.addConstraint` or inline foreign key definitions.
        5.  **Execute `npx sequelize-cli db:migrate` (or equivalent script):**
            *   Instruction: Run the migrations on an empty database. Verify they execute without errors.
            *   Instruction: Inspect the SQLite database file (e.g., using DB Browser for SQLite) to confirm all tables are created with the correct schema, including columns, types, constraints, and relationships/foreign keys.
        6.  **Inspect database connection logic (e.g., `models/index.js` or `db.js`):**
            *   Instruction: Verify Sequelize is instantiated and connects to the database using the configured settings.
            *   Instruction: Verify that all defined models are imported, associated (if `associate` methods are present), and available through the exported `db` object.

### User Story 24: Create Initial System User/Admin Account via Seeder
*   **As a** backend developer,
*   **I want** a Sequelize seeder to create an initial system administrator account with a pre-defined, securely managed password, and default site configurations,
*   **So that** the application is immediately administrable and configured after a fresh setup.

    **Technical Requirements:**
    1.  **Seeding Mechanism:** Use Sequelize seeders (`npx sequelize-cli seed:generate --name initial-setup`).
    2.  **System Admin User:**
        *   `name`: "System Administrator"
        *   `email`: From `process.env.ADMIN_EMAIL`.
        *   `password`: From `process.env.ADMIN_PASSWORD`, hashed with `bcrypt` in the seeder.
        *   `role`: 'admin'.
        *   `status`: 'approved'.
        *   `is_system_user`: `true`.
        *   The seeder should check if this admin email already exists to prevent duplicates.
    3.  **Default Configuration:**
        *   Seed `config` table with default values based on `config.php`:
            *   `hoa_name`: 'Sanderson Creek HOA' (or from env var)
            *   `hoa_description`: 'Sanderson Creek HOA Community Management System' (or from env var)
            *   `hoa_logo`: '/images/logo.png' (or from env var, path might need adjustment for new stack)
        *   The seeder should use `findOrCreate` or check existence for config keys to avoid duplicates.
    4.  **Execution:** Seeder run via `npx sequelize-cli db:seed:all` after migrations. Document environment variable requirements.

*   `[x] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect the seeder file(s) (e.g., `seeders/YYYYMMDDHHMMSS-initial-admin-user.js`, `seeders/YYYYMMDDHHMMSS-initial-config.js`):**
            *   Instruction: For the admin user seeder: Verify the `up` method attempts to create or find an admin user. Check that `email` and initial `password` are sourced from environment variables (e.g., `process.env.ADMIN_EMAIL`, `process.env.ADMIN_PASSWORD`). Verify the password is hashed using `bcrypt` before insertion/update. Confirm the user record has `role: 'admin'`, `status: 'approved'`, and `is_system_user: true`.
            *   Instruction: For the config seeder: Verify the `up` method attempts to `findOrCreate` or insert default key-value pairs into the `config` table (e.g., `hoa_name`, `hoa_description`, `hoa_logo`) with values potentially sourced from environment variables or defaults.
        2.  **Set required environment variables (e.g., `ADMIN_EMAIL`, `ADMIN_PASSWORD`, `DEFAULT_HOA_NAME`).**
        3.  **Execute `npx sequelize-cli db:seed:all` (or specific seeder commands) after migrations have run on an empty but migrated database.**
            *   Instruction: Run the seeders. Verify they execute without errors.
        4.  **Inspect the `users` table in the SQLite database:**
            *   Instruction: Verify the system administrator user record exists with the correct email (from env var), a hashed password, `role: 'admin'`, `status: 'approved'`, and `is_system_user: true`.
        5.  **Inspect the `config` table in the SQLite database:**
            *   Instruction: Verify the default configuration records (e.g., `hoa_name`) exist with their seeded values.
        6.  **Attempt to log in to the application using the newly seeded admin credentials (once login API is ready and if this seeder runs before User Story 2):**
            *   Instruction: (This step is for later integration testing but confirms the seed worked). Verify successful login.

================
File: docker-compose.yml
================
version: '3.8'

services:
  backend:
    build:
      context: . # Build context is the project root
      dockerfile: Dockerfile # Assumes Dockerfile is at the project root
      # If you named it backend.Dockerfile:
      # dockerfile: backend.Dockerfile
    container_name: hoa_backend_api
    ports:
      # Map host port (from .env's APP_PORT or default 3001)
      # to container's internal PORT (defined in Dockerfile, default 3001)
      - "${APP_PORT:-3001}:${PORT:-3001}"
    volumes:
      # Mount a volume for persistent SQLite database storage
      # Maps host's ./backend/database to /usr/src/app/backend/database inside the container
      - ./backend/database:/usr/src/app/backend/database
      # Mount a volume for persistent file uploads
      # Maps host's ./backend/uploads to /usr/src/app/backend/uploads inside the container
      - ./backend/uploads:/usr/src/app/backend/uploads
      # For development with nodemon (OPTIONAL - requires nodemon setup in Dockerfile/entrypoint):
      # This mounts your local backend source code into the container.
      # - ./backend:/usr/src/app/backend
      # This anonymous volume prevents host node_modules from overwriting container's installed node_modules.
      # - /usr/src/app/backend/node_modules
    env_file:
      - .env # Load environment variables from .env file at the project root
    environment:
      # Override or set additional environment variables here if needed
      - NODE_ENV=${NODE_ENV:-development} # Default to development if not set in .env
      # PORT is already set via ARG/ENV in Dockerfile and exposed
    restart: unless-stopped
    networks:
      - hoa-app-network

networks:
  hoa-app-network:
    driver: bridge

# Optional: Define named volumes if you prefer them over host mounts
# If using named volumes, replace the volume definitions above with:
# volumes:
#   hoa_db_data:
#   hoa_uploads_data:
# And in the service:
#   - hoa_db_data:/usr/src/app/backend/database
#   - hoa_uploads_data:/usr/src/app/backend/uploads

================
File: docker-plan.md
================
You're absolutely right! My apologies for the incorrect assumption about moving the `backend` directory. We will proceed with the Dockerization plan assuming the project structure you've provided, where `backend` is a subdirectory of the project root, and Docker-related files (`Dockerfile`, `docker-compose.yml`, `.dockerignore`) will reside at the **project root** (alongside the `backend` and future `frontend` directories).

This is a common and good setup for monorepo-like structures or when you have distinct frontend and backend services.

Here's the revised, detailed Dockerization plan in Markdown format, tailored to your project structure.

# Dockerization Plan for HOA Application (Backend Service)

This plan details the steps to Dockerize the Node.js backend service of the HOA application. The `Dockerfile` and related files will be placed at the project root, and Docker commands will be run from there.

---

## Story 1: Prepare Backend Project for Dockerization

**As a** Developer,
**I want** to ensure the backend project is correctly configured and its dependencies are clearly defined,
**So that** it can be reliably built into a Docker image.

**Technical Details:**

1.  **Verify `backend/package.json`:**
    *   **File Location:** `backend/package.json`
    *   **Action:** Ensure this file is up-to-date and accurately reflects all runtime dependencies.
    *   **Scripts:**
        *   Confirm a `start` script exists for running the application in production mode (e.g., `"start": "node src/app.js"`).
        *   Confirm scripts for database operations like `db:migrate` and `db:seed` are present (e.g., `"db:migrate": "sequelize-cli db:migrate"`).
    *   **Dependencies:**
        *   Verify `sqlite3` is listed under `"dependencies"` and not just `"devDependencies"`.
        *   Ensure all other runtime packages (Express, Sequelize, JWT, bcrypt, etc.) are correctly listed.

2.  **Confirm Database Path Configuration:**
    *   **File Location:** `backend/config/config.json`
    *   **Current Setting:** `"storage": "database/hoa.db"` for development, test, and production.
    *   **Implication for Docker:** This path will be relative to the `WORKDIR` *inside the container*. If `WORKDIR` is `/usr/src/app/backend`, then the app will look for `/usr/src/app/backend/database/hoa.db`. This needs to align with volume mounts.

3.  **Confirm Uploads Path Configuration:**
    *   **File Location:** `backend/src/middlewares/upload.middleware.js`
    *   **Current Setting:** `const uploadDir = path.join(__dirname, '../../uploads/documents');`
    *   **Implication for Docker:**
        *   If `__dirname` inside the container is `/usr/src/app/backend/src/middlewares`, then `../../` resolves to `/usr/src/app/backend/`.
        *   The upload path inside the container will be `/usr/src/app/backend/uploads/documents`. This also needs to align with volume mounts.

4.  **Environment Variables (`.env.example`):**
    *   **File Location:** (Root of project) `.env.example`
    *   **Action:** Review and ensure all necessary environment variables for the backend are documented here. This file will serve as a template for the `.env` file used by Docker Compose. Key variables include:
        *   `PORT` (for the application inside the container)
        *   `APP_PORT` (optional, for host port mapping in Docker Compose)
        *   `JWT_SECRET`, `JWT_EXPIRATION`
        *   Admin seeding variables (`ADMIN_EMAIL`, `ADMIN_PASSWORD`)
        *   Default HOA config seeding variables
        *   `NODE_ENV` (will be set in `docker-compose.yml`)

---

## Story 2: Create Backend Dockerfile

**As a** Developer,
**I want** to create a `Dockerfile` specifically for the backend service, located at the project root,
**So that** I can define the steps to build a portable and consistent Docker image for the backend API.

**Technical Details:**

1.  **Create `Dockerfile` at the Project Root:**
    *   **File Location:** `./Dockerfile` (or `./backend.Dockerfile` if you prefer to name it specifically and reference it in `docker-compose.yml`)
    *   **Content:**

    ```dockerfile
    # Stage 1: Use an official Node.js LTS Alpine image for a smaller footprint
    FROM node:18-alpine AS base

    # Set the working directory for backend code within the container
    # All subsequent commands will be run from this directory
    WORKDIR /usr/src/app/backend

    # Copy only package.json and package-lock.json from the backend directory first
    # This leverages Docker's layer caching. If these files don't change,
    # Docker won't re-run 'npm ci' in subsequent builds.
    COPY ./backend/package*.json ./

    # Install production dependencies for the backend
    # 'npm ci' is generally recommended for CI/production for consistency with package-lock.json
    # '--omit=dev' ensures devDependencies are not installed in the final image
    RUN npm ci --omit=dev

    # Copy the rest of the backend application code into the WORKDIR
    COPY ./backend/ ./

    # Ensure necessary directories exist within the container's WORKDIR
    # These paths are relative to /usr/src/app/backend
    # The application will write to these; Docker volumes will map them to the host.
    # chown might be needed if you run the container as a non-root user.
    # For the default node user (often root in -alpine images unless specified),
    # mkdir is usually sufficient. If using USER node, chown is important.
    RUN mkdir -p database uploads/documents
    # If you switch to USER node later:
    # RUN chown -R node:node database uploads

    # (Optional but recommended) Define a non-root user to run the application
    # USER node

    # Expose the port the application will run on *inside* the container
    # This should match the PORT environment variable your app uses
    ARG PORT=3001
    ENV PORT=${PORT}
    EXPOSE ${PORT}

    # Command to run the application
    # This will execute 'npm start' from /usr/src/app/backend
    CMD [ "npm", "start" ]
    ```

---

## Story 3: Configure Docker Ignore File

**As a** Developer,
**I want** to create a `.dockerignore` file at the project root,
**So that** unnecessary files and directories are excluded from the Docker build context, leading to faster builds and smaller images.

**Technical Details:**

1.  **Create `.dockerignore` at the Project Root:**
    *   **File Location:** `./.dockerignore`
    *   **Content:**

    ```
    # Git specific
    .git
    .gitignore

    # Node modules (for both backend and potentially frontend if it exists here)
    backend/node_modules/
    frontend/node_modules/ # If frontend directory exists at root
    node_modules/ # General node_modules at root, if any

    # Environment files (should be passed at runtime)
    .env
    .env.*
    !.env.example

    # Docker specific files
    Dockerfile
    backend.Dockerfile # If you named it differently
    frontend.Dockerfile # If you add a frontend Dockerfile
    docker-compose.yml
    docker-compose.*.yml

    # Logs
    logs/
    *.log
    npm-debug.log*
    yarn-debug.log*
    yarn-error.log*

    # Local database files (will be mounted as a volume)
    # These paths are relative to the project root, where .dockerignore resides
    backend/database/*.db
    backend/database/*.db-journal

    # Local uploads (will be mounted as a volume)
    backend/uploads/

    # IDE specific
    .vscode/
    .idea/

    # OS specific
    .DS_Store
    Thumbs.db

    # Other build artifacts or temporary files
    # Example:
    # frontend/dist/
    # frontend/build/
    ```

---

## Story 4: Create Docker Compose Configuration

**As a** Developer,
**I want** to create a `docker-compose.yml` file at the project root,
**So that** I can easily define, build, and run the backend service locally, manage its environment, and configure persistent storage for the database and uploads.

**Technical Details:**

1.  **Create `docker-compose.yml` at the Project Root:**
    *   **File Location:** `./docker-compose.yml`
    *   **Content:**

    ```yaml
    version: '3.8'

    services:
      backend:
        build:
          context: . # Build context is the project root
          dockerfile: Dockerfile # Assumes Dockerfile is at the project root
          # If you named it backend.Dockerfile:
          # dockerfile: backend.Dockerfile
        container_name: hoa_backend_api
        ports:
          # Map host port (from .env's APP_PORT or default 3001)
          # to container's internal PORT (defined in Dockerfile, default 3001)
          - "${APP_PORT:-3001}:${PORT:-3001}"
        volumes:
          # Mount a volume for persistent SQLite database storage
          # Maps host's ./backend/database to /usr/src/app/backend/database inside the container
          - ./backend/database:/usr/src/app/backend/database
          # Mount a volume for persistent file uploads
          # Maps host's ./backend/uploads to /usr/src/app/backend/uploads inside the container
          - ./backend/uploads:/usr/src/app/backend/uploads
          # For development with nodemon (OPTIONAL - requires nodemon setup in Dockerfile/entrypoint):
          # This mounts your local backend source code into the container.
          # - ./backend:/usr/src/app/backend
          # This anonymous volume prevents host node_modules from overwriting container's installed node_modules.
          # - /usr/src/app/backend/node_modules
        env_file:
          - .env # Load environment variables from .env file at the project root
        environment:
          # Override or set additional environment variables here if needed
          - NODE_ENV=${NODE_ENV:-development} # Default to development if not set in .env
          # PORT is already set via ARG/ENV in Dockerfile and exposed
        restart: unless-stopped
        networks:
          - hoa-app-network

    networks:
      hoa-app-network:
        driver: bridge

    # Optional: Define named volumes if you prefer them over host mounts
    # If using named volumes, replace the volume definitions above with:
    # volumes:
    #   hoa_db_data:
    #   hoa_uploads_data:
    # And in the service:
    #   - hoa_db_data:/usr/src/app/backend/database
    #   - hoa_uploads_data:/usr/src/app/backend/uploads
    ```

---

## Story 5: Configure Environment Variables for Docker

**As a** Developer,
**I want** to ensure all necessary environment variables are correctly configured in the `.env` file,
**So that** Docker Compose can inject them into the backend container at runtime.

**Technical Details:**

1.  **Create/Update `.env` File at the Project Root:**
    *   **Action:** Copy `.env.example` to `.env` (if it doesn't exist) and populate it.
    *   **Key Variables for Backend:**
        *   `APP_PORT=3001` (Host port mapping for Docker Compose)
        *   `PORT=3001` (Internal container port; Dockerfile also sets this. Ensure consistency.)
        *   `NODE_ENV=development` (or `production` for production-like testing)
        *   `JWT_SECRET=a_very_strong_and_unique_secret_for_docker` (Change this!)
        *   `JWT_EXPIRATION=1h`
        *   `ADMIN_EMAIL=admin-docker@example.com`
        *   `ADMIN_PASSWORD=SuperSecureDockerPassword123!`
        *   `DEFAULT_HOA_NAME="HOA Name (Docker)"`
        *   `DEFAULT_HOA_DESCRIPTION="HOA Description (Docker)"`
        *   `DEFAULT_HOA_LOGO="/images/logo.png"`
        *   Other variables your application might need (e.g., for email services, external APIs).

    *   **Important Note on Paths:** The application code (Sequelize config, upload middleware) uses paths relative to its own root *within the container* (`/usr/src/app/backend`). The Docker volume mounts map your *local host paths* (e.g., `./backend/database`) to these *internal container paths*.

---

## Story 6: Build and Run the Backend Service

**As a** Developer,
**I want** to build the Docker image for the backend and run it using Docker Compose,
**So that** I can verify the Docker setup is working correctly.

**Technical Details:**

1.  **Navigate to Project Root:** Open your terminal in the directory containing `docker-compose.yml` and `Dockerfile`.
2.  **Initial Build and Run:**
    ```bash
    docker-compose up --build
    ```
    *   `--build`: Forces Docker to rebuild the image using `Dockerfile`.
    *   Omit `-d` initially to see logs directly in the terminal.
3.  **Verify Logs:**
    *   Look for:
        *   `npm ci` output (dependency installation).
        *   Application startup messages from `backend/src/app.js` (e.g., "Database connection has been established successfully.", "Server is running on port 3001.").
4.  **Run in Detached Mode (Once Confirmed Working):**
    ```bash
    docker-compose up --build -d
    ```
    Then view logs with:
    ```bash
    docker-compose logs -f backend
    ```

---

## Story 7: Execute Database Migrations and Seeds in Docker

**As a** Developer,
**I want** to run database migrations and seeders inside the running Docker container,
**So that** the database schema is correctly set up and initial data is populated for the Dockerized application.

**Technical Details:**

1.  **Ensure Host Directories Exist:**
    *   Before the first `docker-compose up`, make sure `./backend/database/` and `./backend/uploads/` directories exist on your host machine at the project root. Docker Compose will map these into the container. (Docker typically creates the host path for a bind mount if it's missing, but it's good practice to pre-create them).
2.  **Execute Commands Inside the Container:**
    *   While the `backend` service is running (from `docker-compose up`), open a **new terminal window**.
    *   Navigate to the project root.
    *   Run migrations:
        ```bash
        docker-compose exec backend npm run db:migrate
        ```
        *   `docker-compose exec backend`: Executes a command in the `backend` service container.
        *   `npm run db:migrate`: Runs the script defined in `backend/package.json`.
    *   Run seeders:
        ```bash
        docker-compose exec backend npm run db:seed
        ```

---

## Story 8: Test the Dockerized Backend API

**As a** Developer,
**I want** to test the API endpoints of the Dockerized backend service,
**So that** I can confirm it's fully functional, data persists, and file uploads work as expected.

**Technical Details:**

1.  **API Client:** Use Postman, Insomnia, `curl`, or any API testing tool.
2.  **Target URL:** `http://localhost:${APP_PORT}` (e.g., `http://localhost:3001` if `APP_PORT` is 3001).
3.  **Test Scenarios:**
    *   **Registration:** `POST /api/auth/register`
    *   **Login:** `POST /api/auth/login` (using seeded admin or newly registered & approved user).
    *   **Protected Endpoint:** Access an endpoint that requires authentication (e.g., `GET /api/users/me` or an admin endpoint if logged in as admin).
    *   **Document Upload:**
        *   `POST /api/admin/documents` (as admin). Send a file.
        *   **Verify on Host:** Check your local `./backend/uploads/documents` directory to see if the file appears.
    *   **Data Persistence:**
        *   Create some data (e.g., register a new user, create an announcement).
        *   Stop the containers: `docker-compose down`
        *   Restart the containers: `docker-compose up -d` (no `--build` needed unless code changed).
        *   Verify the previously created data is still present by querying the API.
        *   Verify the SQLite database file (`./backend/database/hoa.db`) on your host has been updated and retains data.

---

## Story 9: (Future) Add Frontend Service to Docker Compose

**As a** Developer,
**I want** to (eventually) add the frontend service to the `docker-compose.yml`,
**So that** the entire application (frontend and backend) can be orchestrated and run locally with Docker Compose.

**Technical Details (Placeholder - to be expanded when frontend is ready):**

1.  **Frontend `Dockerfile`:** Create a `Dockerfile` for the React frontend (e.g., multi-stage build using Node to build static assets, then Nginx or a simple static server to serve them).
2.  **Update `docker-compose.yml`:**
    *   Add a new `frontend` service definition.
    *   Configure its build context and Dockerfile.
    *   Map ports (e.g., host port 80 or 3000 to container port 80 for Nginx).
    *   Ensure the frontend container's `VITE_API_URL` (or equivalent) environment variable is set to communicate with the `backend` service name (e.g., `http://backend:3001`). Docker Compose's internal DNS will resolve `backend` to the backend container's IP.
    *   Make the `frontend` service depend on the `backend` service (`depends_on: - backend`) if necessary.
    *   Ensure both services are on the same `hoa-app-network`.

================
File: Dockerfile
================
# Stage 1: Use an official Node.js LTS Alpine image for a smaller footprint
FROM node:18-alpine AS base

# Set the working directory for backend code within the container
# All subsequent commands will be run from this directory
WORKDIR /usr/src/app/backend

# Copy only package.json and package-lock.json from the backend directory first
# This leverages Docker's layer caching. If these files don't change,
# Docker won't re-run 'npm ci' in subsequent builds.
COPY ./backend/package*.json ./

# Install production dependencies for the backend
# 'npm ci' is generally recommended for CI/production for consistency with package-lock.json
# '--omit=dev' ensures devDependencies are not installed in the final image
RUN npm ci

# Copy the rest of the backend application code into the WORKDIR
COPY ./backend/ ./

# Ensure necessary directories exist within the container's WORKDIR
# These paths are relative to /usr/src/app/backend
# The application will write to these; Docker volumes will map them to the host.
# chown might be needed if you run the container as a non-root user.
# For the default node user (often root in -alpine images unless specified),
# mkdir is usually sufficient. If using USER node, chown is important.
RUN mkdir -p database uploads/documents
# If you switch to USER node later:
# RUN chown -R node:node database uploads

# (Optional but recommended) Define a non-root user to run the application
# USER node

# Expose the port the application will run on *inside* the container
# This should match the PORT environment variable your app uses
ARG PORT=3001
ENV PORT=${PORT}
EXPOSE ${PORT}

# Command to run the application
# This will execute 'npm start' from /usr/src/app/backend
CMD [ "npm", "start" ]

================
File: front-end-plan.md
================
# Front-end Development Plan (React)

## Technology Stack Assumptions

*   **JavaScript Library/Framework:** React (v18+)
*   **Project Scaffolding:** Vite (preferred for speed and modern ESM)
*   **Routing:** React Router DOM (v6+)
*   **State Management:** React Context API with `useReducer` for global state (e.g., Auth, Site Config). Component-level state (`useState`) for local UI state.
*   **Component Styling:** Material UI (MUI v5+) for a comprehensive component library and theming, to align with the original Materialize CSS feel but with modern React practices. This includes `@mui/material`, `@emotion/react`, `@emotion/styled`, and `@mui/icons-material`.
*   **API Communication:** Axios for structured HTTP requests.
*   **Form Handling:** React Hook Form for efficient form state management and validation.
*   **Development Language:** JavaScript (ES6+) or TypeScript. (This plan will assume JavaScript (JSX) for simplicity in description, but TypeScript (TSX) is highly recommended for new React projects for better type safety and developer experience).
*   **Linting/Formatting:** ESLint and Prettier.
*   **Rich Text Editor:** React-Quill or a similar library (e.g., Tiptap, Slate) for discussion/announcement content, ensuring compatibility with MUI if possible or styling to match.
*   **Date/Time Pickers:** MUI X Date and Time Pickers (or equivalent integrated with MUI).
*   **Notifications/Toasts:** A library like `react-toastify` or MUI's Snackbar component for user feedback.

## Goal

To create a modern, responsive, and user-friendly single-page application (SPA) using React that consumes the Node.js backend API. The frontend will replicate all user-facing functionalities of the current PHP application, offering an improved user experience and maintainability.

## Expected Output

A complete React application with a well-organized component structure, efficient state management, client-side routing, and a build process for deployment. The UI will be intuitive, responsive across devices, and provide a significantly improved user experience by leveraging modern React patterns and Material UI components. All functionalities present in the original PHP application (user views and admin panels) will be implemented.

---

## Epic: Basic Setup & Structure

### User Story 25: Initialize React Application and Setup Basic Structure
*   **As a** frontend developer,
*   **I want** to initialize a new React application using Vite and establish a scalable project structure with essential libraries for routing, API calls, state management, and UI components,
*   **So that** I have a solid and organized foundation for building UI components and features efficiently.

    **Technical Requirements:**
    1.  **Project Initialization:** Use Vite (`npm create vite@latest my-hoa-app -- --template react`).
    2.  **Folder Structure:** Establish a logical `src/` directory structure:
        *   `App.jsx`: Main application component, router setup.
        *   `main.jsx`: Application entry point, renders `App`.
        *   `components/`: Reusable UI components.
            *   `common/`: Generic components (e.g., `StyledButton`, `LoadingSpinner`, `ConfirmationDialog`).
            *   `layout/`: Components like `Header`, `Footer`, `AdminLayout`, `MainLayout`.
        *   `pages/`: Top-level route components (e.g., `HomePage.jsx`, `LoginPage.jsx`, `DashboardPage.jsx`).
        *   `features/`: Module-specific components, hooks, and potentially services (e.g., `features/auth/`, `features/documents/`, `features/admin/users/`).
        *   `services/` or `api/`: Centralized API call logic (e.g., `apiClient.js`, `authService.js`, `documentService.js`).
        *   `hooks/`: Custom React hooks (e.g., `useAuth.js`, `useDebounce.js`).
        *   `contexts/`: Global state management (e.g., `AuthContext.jsx`, `SiteConfigContext.jsx`).
        *   `routes/`: Routing configuration (`AppRoutes.jsx`), including protected route components.
        *   `assets/`: Static assets like images, fonts.
        *   `utils/`: Utility functions (e.g., `dateFormatter.js`, `validationSchemas.js`).
        *   `theme/`: MUI theme customization (`theme.js`).
    3.  **Core Dependencies:** Install `react-router-dom`, `axios`.
    4.  **MUI Setup:** Install `@mui/material @emotion/react @emotion/styled @mui/icons-material @mui/x-date-pickers`. Create `theme/theme.js` for basic MUI theme customization (palette, typography). Wrap the application with `<ThemeProvider theme={theme}>` and `<LocalizationProvider dateAdapter={AdapterDateFns}>` (or dayjs).
    5.  **Linting/Formatting:** Configure ESLint (with React plugins) and Prettier.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `package.json`:**
            *   Instruction: Verify `react`, `react-dom` are present.
            *   Instruction: Verify the project was initialized with Vite by checking scripts (e.g., `vite`, `vite build`) and dependencies.
        2.  **Inspect the `src/` directory structure:**
            *   Instruction: Confirm a clear and organized folder structure exists, generally aligning with the pattern: `components/`, `pages/`, `services/` (or `api/`), `hooks/`, `contexts/`, `routes/`, `theme/`.
        3.  **Verify installation of core libraries in `package.json`:**
            *   Instruction: Check that `react-router-dom` and `axios` are listed as dependencies.
        4.  **Verify MUI library setup:**
            *   Instruction: Verify `@mui/material`, `@emotion/react`, `@emotion/styled`, `@mui/icons-material`, and a date adapter for `@mui/x-date-pickers` (e.g., `date-fns` or `dayjs` along with `@date-io/date-fns` or `@date-io/dayjs`) are in `package.json`.
            *   Instruction: Check `main.jsx` or `App.jsx` for the application being wrapped by MUI's `<ThemeProvider>` (with a custom theme if created) and `<CssBaseline />`.
            *   Instruction: If date pickers are planned, verify `<LocalizationProvider>` wraps the app.
        5.  **Verify ESLint and Prettier configuration:**
            *   Instruction: Check for `.eslintrc.js` (or similar) and `.prettierrc.js` (or similar) configuration files. Confirm linting and formatting scripts are available in `package.json` and run without errors.

### User Story 26: Implement Global Layout and Navigation Structure
*   **As a** frontend developer,
*   **I want** to create a global application layout structure with a responsive `Header` (displaying HOA branding, dynamic navigation links based on auth state and role) and a `Footer`,
*   **So that** users experience a consistent visual and navigational framework across all public and authenticated sections of the application.

    **Technical Requirements:**
    1.  **Main Layout (`components/layout/MainLayout.jsx`):** Wraps general application pages. Renders `Header`, an `Outlet` for page content, and `Footer`.
    2.  **Header Component (`components/layout/Header.jsx`):**
        *   Uses MUI `AppBar`, `Toolbar`, `Typography` for branding (HOA Name from `SiteConfigContext` or fetched config).
        *   Navigation links (MUI `Button` or `Link` components, integrated with `react-router-dom`'s `NavLink`).
        *   Dynamic links based on `AuthContext`:
            *   Unauthenticated: "Home", "Documents", "Login", "Register".
            *   Authenticated Member: "Home", "Dashboard", "Documents", "Discussions", "Logout".
            *   Authenticated Admin: Adds "Admin Panel" link.
        *   Responsive: MUI `IconButton` for menu on small screens (`<MenuIcon />`), opening an MUI `Drawer` or `Menu` with navigation links.
    3.  **Footer Component (`components/layout/Footer.jsx`):** MUI `Box` or `Container` with `Typography` for " [Year] [HOA Name]". Link to Audit Log visible here (from PHP footer, implies all logged-in users could see it). This needs clarification for role access if Audit Log is admin-only in new design. For now, assume link available if logged in.
    4.  **Site Configuration Context (`contexts/SiteConfigContext.jsx`):** To fetch and provide `hoa_name` and other global settings from `/api/config` (publicly accessible endpoint, or a subset of it).

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `App.jsx` or `AppRoutes.jsx`:**
            *   Instruction: Verify a `MainLayout` component wraps the main application routes that share the common header/footer.
        2.  **Inspect `components/layout/Header.jsx`:**
            *   Instruction: Verify it uses MUI components like `<AppBar>`, `<Toolbar>`, `<Typography>`, `<Button>` or `<Link>`.
            *   Instruction: Verify HOA name is displayed (potentially fetched from a `SiteConfigContext` or hardcoded initially).
            *   Instruction: Using mocked `AuthContext` states:
                *   Unauthenticated: Check visibility of "Home", "Documents", "Login", "Register" links.
                *   Authenticated 'member': Check visibility of "Home", "Dashboard", "Documents", "Discussions", "Logout" links. "Login", "Register", "Admin Panel" should be hidden.
                *   Authenticated 'admin': Check visibility of all member links PLUS "Admin Panel".
            *   Instruction: Resize browser or use dev tools for mobile view. Verify a responsive menu (e.g., hamburger icon) appears and, when clicked, shows the appropriate navigation links.
        3.  **Inspect `components/layout/Footer.jsx`:**
            *   Instruction: Verify it displays copyright text.
            *   Instruction: (Pending clarification on Audit Log visibility) If the Audit Log link from the original PHP footer is to be retained for all logged-in users, verify its presence when a user is authenticated.
        4.  **Inspect `contexts/SiteConfigContext.jsx` (if implemented for HOA name):**
            *   Instruction: Verify it fetches configuration (like `hoa_name`) from a backend endpoint (e.g., a public `/api/config/public` or a restricted part of `/api/admin/config` accessible early) and provides it via context.

### User Story 27: Implement Client-Side Routing and Protected Routes
*   **As a** frontend developer,
*   **I want** to configure client-side routing using React Router DOM for all application pages, including public routes, authenticated-only routes, and admin-only routes, utilizing a protected route mechanism,
*   **So that** navigation is seamless, URLs are descriptive, and access to sensitive sections is properly controlled based on user authentication and roles.

    **Technical Requirements:**
    1.  **Routing Setup (`routes/AppRoutes.jsx` or in `App.jsx`):**
        *   Use `createBrowserRouter` and `RouterProvider` (or `BrowserRouter`, `Routes`, `Route`).
        *   Define routes for:
            *   Public: `/` (Home), `/login`, `/register`, `/documents` (public view).
            *   Authenticated (`ProtectedRoute` for members/admins): `/dashboard`, `/discussions` (list), `/discussions/:threadId` (view thread).
            *   Admin (`ProtectedRoute` with `role='admin'`):
                *   `/admin` (redirects to `/admin/dashboard` or first admin page)
                *   `/admin/dashboard` (Admin landing)
                *   `/admin/users`
                *   `/admin/documents`
                *   `/admin/announcements`
                *   `/admin/events`
                *   `/admin/discussions`
                *   `/admin/config`
                *   `/admin/audit-logs`
    2.  **Protected Route Components (`components/routes/AuthProtectedRoute.jsx`, `components/routes/AdminProtectedRoute.jsx`):**
        *   `AuthProtectedRoute`: Consumes `AuthContext`. If `!isAuthenticated`, redirects to `/login` (preserving target location via `state` for redirect after login). Otherwise, renders `Outlet` or `children`.
        *   `AdminProtectedRoute`: Consumes `AuthContext`. If `!isAuthenticated` OR `user.role !== 'admin'`, redirects to `/login` or an "Unauthorized" page (e.g., `/unauthorized`) or `/dashboard`. Otherwise, renders `Outlet` or `children`.
    3.  **Admin Layout (`components/layout/AdminLayout.jsx`):** A specific layout for `/admin/*` routes, potentially with a sidebar navigation for admin sections, nested within an `AdminProtectedRoute`.
    4.  **Not Found Page (`pages/NotFoundPage.jsx`):** A fallback route (`path="*"`) for undefined paths.
    5.  **Lazy Loading:** Implement `React.lazy` for page-level components to improve initial load time, wrapped with `<Suspense>`.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `routes/AppRoutes.jsx` (or main router setup):**
            *   Instruction: Verify routes are defined for all specified public, authenticated, and admin pages.
            *   Instruction: Check that authenticated routes (e.g., `/dashboard`) are wrapped with an `AuthProtectedRoute` component.
            *   Instruction: Check that admin routes (e.g., `/admin/users`) are wrapped with an `AdminProtectedRoute` component (or `AuthProtectedRoute` with role check prop).
            *   Instruction: Verify a wildcard route (`path="*"`) is defined, rendering a `NotFoundPage` component.
        2.  **Inspect `AuthProtectedRoute.jsx`:**
            *   Instruction: Verify it consumes `AuthContext`. If user is not authenticated, check that it uses `Navigate` to redirect to `/login`, passing the current `location` in the `state` prop for post-login redirection.
        3.  **Inspect `AdminProtectedRoute.jsx`:**
            *   Instruction: Verify it consumes `AuthContext`. If user is not authenticated or `user.role` is not 'admin', check redirection (e.g., to `/unauthorized` or `/dashboard`).
        4.  **Inspect `components/layout/AdminLayout.jsx` (if created):**
            *   Instruction: Verify this layout component provides a distinct structure for admin pages (e.g., sidebar navigation using MUI `<Drawer>` and `<List>`). Verify it renders an `<Outlet />` for nested admin page content.
        5.  **Test route protection logic:**
            *   Instruction: Attempt to access `/dashboard` unauthenticated: expect redirect to `/login`.
            *   Instruction: Log in as 'member', attempt to access `/admin/users`: expect redirect to `/unauthorized` or `/dashboard`.
            *   Instruction: Log in as 'admin', access `/admin/users`: expect page to render.
        6.  **Inspect usage of `React.lazy` and `<Suspense>`:**
            *   Instruction: Verify that page-level components are imported using `React.lazy()` (e.g., `const DashboardPage = React.lazy(() => import('../pages/DashboardPage'))`).
            *   Instruction: Ensure these lazy-loaded components are rendered within a `<Suspense fallback={<LoadingSpinner />}>` component in the router configuration.

---

## Epic: User Authentication UI

### User Story 28: Develop Login Page
*   **As a** user,
*   **I want** a visually clear and responsive login page with input fields for email and password, a prominent login button, and appropriate user feedback for actions and errors,
*   **So that** I can easily and securely authenticate to access the application's features.

    **Technical Requirements:**
    1.  **Component (`pages/LoginPage.jsx` or `features/auth/LoginPage.jsx`):**
        *   Use MUI components: `Container`, `Paper` (or `Card`), `Typography`, `TextField`, `Button`, `Link` (for React Router).
        *   Responsive layout (e.g., centered card on larger screens).
    2.  **Form Handling:** Use `react-hook-form` for managing form state, validation, and submission.
        *   Define validation schema (e.g., using Zod or Yup, or inline with RHF): email (required, valid format), password (required).
    3.  **API Call:** On valid form submission, call an `loginUser(email, password)` function from `authService.js`. This service function will use `apiClient.js` (Axios instance) to make the `POST /api/auth/login` request.
    4.  **State Update (`AuthContext`):** On successful API response (200 OK with JWT):
        *   Call `login(userData, token)` method from `AuthContext` to update global auth state and store token (e.g., in memory or `localStorage`).
        *   Use `useNavigate` hook from `react-router-dom` to redirect to `/dashboard` (or intended post-login page, potentially from `location.state` if redirected from a protected route).
    5.  **Error Handling & Feedback:**
        *   Display field-specific validation errors from `react-hook-form`.
        *   Display general API error messages (e.g., "Invalid credentials," "Account pending approval") returned from the backend, using an MUI `Alert` or a toast notification.
        *   Disable login button during API call (show loading state, e.g., MUI `CircularProgress` in button).
    6.  **Links:** MUI `Link` component (as `RouterLink`) to `/register`. Message about contacting admin for forgotten passwords.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/LoginPage.jsx` (or similar):**
            *   Instruction: Verify the component uses MUI components for layout (e.g., `<Container>`, `<Paper>`) and form elements (`<TextField>` for email/password, `<Button type="submit">`).
            *   Instruction: Confirm the layout is responsive, e.g., the login form is centered and appropriately sized on different screen widths.
        2.  **Inspect `react-hook-form` integration:**
            *   Instruction: Verify `useForm` hook is used. Check `register` calls for email and password fields.
            *   Instruction: Review validation rules: email must be `required` and a valid email format; password must be `required`. Verify error messages are displayed near the respective fields if validation fails.
        3.  **Inspect form submission handler (`onSubmit`):**
            *   Instruction: Confirm it calls a login function from an authentication service (e.g., `authService.login(data)`).
            *   Instruction: Verify the login button is disabled and/or shows a loading indicator (e.g., MUI `<CircularProgress>`) while the API request is in progress.
        4.  **Inspect `AuthContext` interaction on successful login:**
            *   Instruction: After a successful API response, verify the `login` method of `AuthContext` is called with user data and token from the API.
            *   Instruction: Verify `useNavigate` is used to redirect to `/dashboard` or the route stored in `location.state.from`.
        5.  **Inspect display of API error messages:**
            *   Instruction: Simulate backend errors (e.g., 401 for invalid credentials, 403 for pending approval). Verify these error messages are displayed clearly to the user (e.g., using an MUI `<Alert>` component).
        6.  **Verify navigation links:**
            *   Instruction: Confirm an MUI `<Link>` component, correctly configured to work with `react-router-dom` (e.g., `component={RouterLink} to="/register"`), navigates to the registration page.
            *   Instruction: Verify the presence of text indicating users should contact an admin for forgotten passwords (as per original app).

### User Story 29: Develop Registration Page
*   **As a** new user,
*   **I want** a responsive registration page with fields for my full name, email address, password, and password confirmation, with clear validation and feedback,
*   **So that** I can easily create an account which will then await administrator approval.

    **Technical Requirements:**
    1.  **Component (`pages/RegisterPage.jsx` or `features/auth/RegisterPage.jsx`):** MUI layout similar to Login page.
    2.  **Form Handling (`react-hook-form`):**
        *   Inputs for `name`, `email`, `password`, `confirmPassword`.
        *   Validation: all fields required; email valid format; password min length (e.g., 8), matches `confirmPassword`.
    3.  **API Call:** On valid submission, call `authService.register(data)` which posts to `/api/auth/register`.
    4.  **Feedback:**
        *   On success (201 Created): Display persistent success message (e.g., MUI `Alert` type="success"): "Registration successful! Your account is pending admin approval." Form might be cleared or disabled.
        *   On API error (e.g., 409 email exists): Display error in MUI `Alert`.
        *   Loading state for submit button.
    5.  **Links:** MUI `Link` to `/login`.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/RegisterPage.jsx` (or similar):**
            *   Instruction: Verify MUI components for layout and form elements (`<TextField>` for name, email, password, confirm password; `<Button type="submit">`).
        2.  **Inspect `react-hook-form` integration and validation:**
            *   Instruction: Verify `useForm` is used. Check `register` calls.
            *   Instruction: Review validation rules: `name` (required); `email` (required, valid format); `password` (required, min length); `confirmPassword` (required, matches password). Verify field-specific error messages.
        3.  **Inspect form submission handler:**
            *   Instruction: Confirm it calls a registration function from `authService.register(data)`.
            *   Instruction: Verify loading state on the submit button during API call.
        4.  **Inspect feedback on successful registration:**
            *   Instruction: After a successful API response (201), verify an MUI `<Alert severity="success">` (or similar prominent message) displays "Registration successful! Your account is pending admin approval."
            *   Instruction: Check if the form fields are cleared or the form is disabled post-successful registration.
        5.  **Inspect display of API error messages:**
            *   Instruction: Simulate backend error (e.g., 409 for duplicate email). Verify the error message is displayed in an MUI `<Alert severity="error">`.
        6.  **Verify navigation links:**
            *   Instruction: Confirm an MUI `<Link component={RouterLink} to="/login">` navigates to the login page.

### User Story 30: Implement Logout Functionality in Header
*   **As an** authenticated user,
*   **I want** a clearly visible "Logout" button or link, typically within the main application header or a user-specific menu,
*   **So that** I can securely end my session, clearing my authentication state from the client application and be redirected appropriately.

    **Technical Requirements:**
    1.  **UI Element (`components/layout/Header.jsx`):**
        *   An MUI `Button` or `MenuItem` (if in a dropdown menu) labeled "Logout".
        *   Visible only if `AuthContext.isAuthenticated` is true.
    2.  **Action (`AuthContext`):**
        *   The `onClick` handler for the logout button calls the `logout()` function exposed by `AuthContext`.
        *   `AuthContext.logout()` function:
            *   Clears the token from wherever it's stored (e.g., `localStorage.removeItem('authToken')`).
            *   Resets the context's state: `setUser(null)`, `setToken(null)`, `setIsAuthenticated(false)`.
            *   Uses `useNavigate` (obtained in `Header` or passed to context) to redirect to `/login` or `/`.
    3.  **Backend Interaction (Optional):** If the backend implements a token blacklist or server-side session invalidation, the `authService.logout()` could make an API call to `/api/auth/logout` before clearing client-side state. For simple JWT, client-side clearing is primary.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `components/layout/Header.jsx` (or user menu component):**
            *   Instruction: When authenticated (verified via `AuthContext.isAuthenticated`), confirm a "Logout" MUI `<Button>` or `<MenuItem>` is rendered and visible.
            *   Instruction: When not authenticated, confirm the "Logout" element is not rendered.
        2.  **Inspect the `onClick` handler for the "Logout" element:**
            *   Instruction: Verify it calls a `logout` function provided by `AuthContext` (e.g., `auth.logout()`).
        3.  **Inspect the `logout` function within `AuthContext.jsx`:**
            *   Instruction: Confirm this function removes the authentication token from its storage location (e.g., `localStorage.removeItem('authToken')`).
            *   Instruction: Verify it resets the context's internal state for `user`, `token`, and `isAuthenticated` to their initial unauthenticated values.
        4.  **Verify navigation after logout:**
            *   Instruction: After clicking "Logout", confirm the application navigates (using `useNavigate`) to the `/login` page or the site's home page (`/`).
        5.  **Verify state after logout:**
            *   Instruction: After logout, check `AuthContext` state (e.g., via React DevTools or logging) to ensure `isAuthenticated` is false and `user`/`token` are null.
            *   Instruction: Attempt to access a protected route (e.g., `/dashboard`). Verify redirection to `/login`.

---

## Epic: Core User Features UI (Dashboard, Documents, Discussions)

### User Story 31: Develop Home Page
*   **As a** user (both guest and authenticated),
*   **I want** a home page that displays a welcome message and the HOA name. If I am logged in, it should additionally show recent announcements,
*   **So that** I get a relevant landing experience and quick updates.

    **Technical Requirements:**
    1.  **Component (`pages/HomePage.jsx`):**
        *   Uses MUI `Container`, `Typography`.
        *   Displays HOA Name (from `SiteConfigContext`).
        *   Conditionally fetches and displays announcements if `AuthContext.isAuthenticated`.
    2.  **Announcements Display:**
        *   Calls `announcementService.getAnnouncements({ limit: 5, sortBy: 'createdAt:desc' })`.
        *   Renders each announcement in an MUI `Card` or `Paper` with `Typography` for title, date.
        *   Content (`announcement.content`, potentially HTML) must be rendered safely. If it's sanitized HTML from backend, use `dangerouslySetInnerHTML={{ __html: announcement.content }}`. If plain text, simple rendering.
    3.  **Loading/Error States:** Show MUI `CircularProgress` while fetching, and an `Alert` for errors.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/HomePage.jsx`:**
            *   Instruction: Verify it displays a generic welcome message and the HOA name (sourced from `SiteConfigContext` or a similar global config).
        2.  **Conditional Announcement Fetching & Display (requires `AuthContext` and `announcementService` integration):**
            *   Instruction: When `AuthContext.isAuthenticated` is true, verify an API call is made to fetch recent announcements (e.g., `GET /api/announcements?limit=5&sort=createdAt:desc`).
            *   Instruction: When authenticated and announcements are successfully fetched, verify they are displayed (e.g., each in an MUI `<Card>`), showing title, content snippet, and creation date.
            *   Instruction: If announcement content is HTML, ensure it is rendered safely (e.g., using `dangerouslySetInnerHTML` assuming backend sanitizes, or a React HTML parsing library).
            *   Instruction: When `AuthContext.isAuthenticated` is false, verify no API call for announcements is made and the announcement section is not displayed.
        3.  **Loading and Error State Handling:**
            *   Instruction: While announcements are being fetched, verify a loading indicator (e.g., MUI `<CircularProgress>`) is displayed.
            *   Instruction: If the API call to fetch announcements fails, verify an appropriate error message (e.g., using MUI `<Alert>`) is shown.

### User Story 32: Develop Dashboard Page
*   **As an** authenticated user,
*   **I want** a dashboard page that provides a personalized welcome and summarizes recent announcements, upcoming events, a list of approved documents, and recent discussion threads,
*   **So that** I have a centralized overview of important HOA activities and information.

    **Technical Requirements:**
    1.  **Component (`pages/DashboardPage.jsx`):** Protected by `AuthProtectedRoute`.
    2.  **Welcome Message:** Displays "Welcome, [User Name]!" (name from `AuthContext.user.name`).
    3.  **Data Fetching:** On mount, concurrently fetch data using respective services:
        *   Announcements: `announcementService.getAnnouncements({ limit: 3, sortBy: 'createdAt:desc' })`.
        *   Events: `eventService.getEvents({ limit: 3, filter: 'upcoming', sortBy: 'startDate:asc' })`.
        *   Documents: `documentService.getDocuments({ limit: 5, approved: true, sortBy: 'uploadedAt:desc' })`.
        *   Discussions: `discussionService.getDiscussions({ limit: 3, sortBy: 'createdAt:desc' })`.
    4.  **Layout:** Use MUI `Grid` for a multi-column layout. Each section (Announcements, Events, etc.) in an MUI `Card` or `Paper`.
    5.  **Display:**
        *   **Announcements/Events/Discussions:** List items with titles, dates, brief content. Titles link to full view where applicable (e.g., discussion thread). HTML content rendered safely.
        *   **Documents:** List item with title, description snippet. Link to `documentService.downloadDocument(id)` or to the document details page.
    6.  **Loading/Error States:** Individual loading/error states for each section or a global one for the page.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/DashboardPage.jsx` and its route definition:**
            *   Instruction: Verify the page is protected by `AuthProtectedRoute`.
        2.  **Welcome Message:**
            *   Instruction: Verify it displays a personalized welcome message including the authenticated user's name (from `AuthContext.user.name`).
        3.  **Data Fetching (requires service integrations):**
            *   Instruction: On page load, verify API calls are made to fetch:
                *   Recent announcements (e.g., `GET /api/announcements?limit=X`).
                *   Upcoming events (e.g., `GET /api/events?filter=upcoming&limit=X`).
                *   Approved documents (e.g., `GET /api/documents?approved=true&limit=X`).
                *   Recent discussions (e.g., `GET /api/discussions?limit=X`).
        4.  **Layout and Display:**
            *   Instruction: Verify an MUI `<Grid>` or similar layout component is used to arrange the different sections (Announcements, Events, Documents, Discussions).
            *   Instruction: For each section:
                *   Verify it's presented within an MUI `<Card>` or `<Paper>`.
                *   Announcements: Check for title, date, content snippet. HTML content rendered safely.
                *   Events: Check for title, date(s), location snippet.
                *   Documents: Check for title, and a download link/button which, when clicked, triggers a download.
                *   Discussions: Check for title, author, date. Title should be a link to the full discussion view (e.g., `/discussions/:threadId`).
        5.  **Loading and Error State Handling:**
            *   Instruction: For each data fetching operation, verify loading indicators are shown while data is pending.
            *   Instruction: If any API call fails, verify an appropriate error message is displayed for that section or for the page.

### User Story 33: Develop Documents Page & Download Functionality
*   **As a** user (guest or authenticated),
*   **I want** a documents page that lists available documents (respecting public/private permissions based on my authentication status) with their titles, descriptions, upload dates, and provides a clear way to download them,
*   **So that** I can access shared HOA files.

    **Technical Requirements:**
    1.  **Component (`pages/DocumentsPage.jsx`):**
    2.  **Data Fetching:** Calls `documentService.getDocuments()`. The service/API handles returning appropriate documents based on auth state (public & approved for guests; all approved for members; all for admins if this page is also used by them, or a separate admin doc page exists).
    3.  **Display:** Use MUI `Table` or `List` to display documents: Title, Description, Uploaded Date.
    4.  **Download Action:** Each document row/item has an MUI `Button` or `IconButton` (`<DownloadIcon />`) to trigger download.
        *   `onClick` handler calls `documentService.downloadDocument(doc.id)`. This service function will handle the actual file download triggering, possibly by creating a temporary link and clicking it, or by opening `window.open(API_URL + '/documents/' + doc.id + '/download')` if the backend sets `Content-Disposition: attachment`.
    5.  **Loading/Error States:** Standard handling.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/DocumentsPage.jsx`:**
            *   Instruction: Verify it calls a service function (e.g., `documentService.getDocuments()`) to fetch the list of documents. The backend API is responsible for filtering based on auth status.
        2.  **Document Display:**
            *   Instruction: Verify documents are displayed in an MUI `<Table>` or `<List>`, showing columns/fields for Title, Description (if available), and Uploaded Date.
            *   Instruction: Ensure dates are formatted readably (e.g., using `date-fns` or `dayjs`).
        3.  **Download Functionality:**
            *   Instruction: For each document, verify an MUI `<Button>` or `<IconButton>` (e.g., with `<DownloadIcon />`) is present for downloading.
            *   Instruction: When the download element is clicked, verify it triggers a call to a download service function (e.g., `documentService.downloadDocument(doc.id)`) or directly constructs a URL to the backend download endpoint (e.g., `/api/documents/:id/download`) and initiates the download (e.g., via `window.open` or creating an `<a>` tag).
            *   Instruction: Perform a download and verify the correct file is downloaded with a user-friendly name.
        4.  **Loading and Error State Handling:**
            *   Instruction: Verify a loading indicator is shown while the document list is being fetched.
            *   Instruction: If fetching documents fails, verify an error message is displayed.

### User Story 34: Develop Discussion List Page
*   **As an** authenticated user,
*   **I want** a page listing all main discussion threads, showing key information like title, author, creation date, and reply count, with a way to navigate to view a full thread, and an option to start a new discussion,
*   **So that** I can browse ongoing conversations and initiate new ones.

    **Technical Requirements:**
    1.  **Component (`pages/DiscussionListPage.jsx` or `features/discussions/DiscussionListPage.jsx`):** Protected by `AuthProtectedRoute`.
    2.  **Data Fetching:** Calls `discussionService.getDiscussions()` (supports pagination).
    3.  **Display:** MUI `List` or `Table` to display threads. Each item shows:
        *   Title (as a `Link` from `react-router-dom` to `/discussions/:threadId`).
        *   Author Name.
        *   Creation Date (formatted).
        *   Reply Count.
    4.  **New Discussion Button:** MUI `Button` ("Start New Discussion") that navigates to a new discussion form/page (e.g., `/discussions/new`).
    5.  **Pagination Controls:** If API supports pagination, implement UI controls (e.g., MUI `Pagination` component).
    6.  **Loading/Error States.**

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/DiscussionListPage.jsx` and its route definition:**
            *   Instruction: Verify the page is protected by `AuthProtectedRoute`.
        2.  **Data Fetching (requires `discussionService` integration):**
            *   Instruction: Verify an API call is made to fetch main discussion threads (e.g., `GET /api/discussions` with pagination parameters).
        3.  **Discussion Thread Display:**
            *   Instruction: Verify threads are displayed in an MUI `<List>` or `<Table>`.
            *   Instruction: For each thread, check for:
                *   Title: Displayed as a clickable link (using `react-router-dom`'s `<Link>`) navigating to the specific thread view (e.g., `/discussions/:threadId`).
                *   Author's Name.
                *   Creation Date (formatted).
                *   Reply Count.
        4.  **"Start New Discussion" Button:**
            *   Instruction: Verify an MUI `<Button>` labeled "Start New Discussion" (or similar) is present.
            *   Instruction: When clicked, verify it navigates the user to a form or page for creating a new discussion (e.g., `/discussions/new`).
        5.  **Pagination (if implemented):**
            *   Instruction: If the API supports pagination for discussions, verify MUI `<Pagination>` controls (or similar) are present and functional, allowing navigation between pages of threads.
        6.  **Loading and Error State Handling:**
            *   Instruction: Verify appropriate loading indicators and error messages are displayed during data fetching.

### User Story 35: Develop View Discussion Page (Thread & Replies)
*   **As an** authenticated user,
*   **I want** a page to view a specific discussion thread's full content and all its replies, chronologically, with author and date for each post, and a form to post my own reply,
*   **So that** I can fully read and participate in the conversation.

    **Technical Requirements:**
    1.  **Component (`pages/ViewDiscussionPage.jsx` or `features/discussions/ViewDiscussionPage.jsx`):** Protected by `AuthProtectedRoute`. Takes `threadId` from route params (`useParams`).
    2.  **Data Fetching:** Calls `discussionService.getDiscussionById(threadId)` which fetches the main thread and its replies.
    3.  **Display Main Thread:**
        *   MUI `Card` or `Paper`. `Typography` for title, author, date.
        *   Content (HTML from backend) rendered safely using `dangerouslySetInnerHTML` or a dedicated renderer.
    4.  **Display Replies:**
        *   MUI `List` of `Card`s/`Paper`s for replies below the main thread.
        *   Each reply shows content (HTML rendered safely), author, date.
    5.  **Reply Form:**
        *   MUI `TextField` (multiline) or a Rich Text Editor component (e.g., `React-Quill`) for reply content.
        *   MUI `Button` to submit.
        *   Uses `react-hook-form`. On submit, calls `discussionService.postReply(threadId, replyData)`.
        *   After successful reply, re-fetch discussion data or optimistically update the UI to show the new reply. Clear form.
    6.  **Loading/Error States.**

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/ViewDiscussionPage.jsx` and its route definition (e.g., `/discussions/:threadId`):**
            *   Instruction: Verify the page is protected by `AuthProtectedRoute` and correctly extracts `threadId` using `useParams`.
        2.  **Data Fetching (requires `discussionService` integration):**
            *   Instruction: Verify an API call is made to fetch the specific discussion thread and its replies based on `threadId` (e.g., `GET /api/discussions/:threadId`).
        3.  **Main Thread Display:**
            *   Instruction: Verify the main thread's title, author, and creation date are displayed.
            *   Instruction: Verify the main thread's content (potentially HTML) is rendered correctly and safely.
        4.  **Replies Display:**
            *   Instruction: Verify replies are listed chronologically below the main thread.
            *   Instruction: For each reply, check for its content (HTML rendered safely), author, and creation date.
        5.  **Reply Form:**
            *   Instruction: Verify a form is present for posting a new reply. This should include an input area for the reply content (e.g., MUI `<TextField multiline>` or a Rich Text Editor like `React-Quill`).
            *   Instruction: Verify an MUI `<Button>` is present to submit the reply.
            *   Instruction: (If using `react-hook-form`) Verify form state and validation (e.g., reply content is required).
            *   Instruction: On form submission, verify an API call is made to post the reply (e.g., `POST /api/discussions/:threadId/replies`) with the content.
            *   Instruction: After a successful reply submission, verify the list of replies updates to show the new reply, and the reply form is cleared.
        6.  **Loading and Error State Handling:**
            *   Instruction: Verify loading indicators for initial data fetch and for reply submission.
            *   Instruction: Verify error messages for data fetching failures or reply submission failures.

### User Story 36: Develop "Start New Discussion" Form/Page
*   **As an** authenticated user,
*   **I want** a dedicated form or page with fields for a discussion title and rich text content,
*   **So that** I can initiate new topics for community discussion.

    **Technical Requirements:**
    1.  **Component (`pages/NewDiscussionPage.jsx` or modal component):** Protected by `AuthProtectedRoute`.
    2.  **Form Handling (`react-hook-form`):**
        *   MUI `TextField` for "Title".
        *   Rich Text Editor (e.g., `React-Quill`) for "Content".
        *   Validation: Title and Content required.
    3.  **API Call:** On submit, call `discussionService.createDiscussion({ title, content })`.
    4.  **Navigation/Feedback:** On success, navigate to the new discussion's page (`/discussions/:newThreadId`) or back to discussion list (`/discussions`). Show success toast/message.
    5.  **Loading/Error States.**

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/NewDiscussionPage.jsx` (or modal component) and its route definition (e.g., `/discussions/new`):**
            *   Instruction: Verify the page/modal is protected by `AuthProtectedRoute`.
        2.  **Form Elements and Rich Text Editor:**
            *   Instruction: Verify an MUI `<TextField>` is present for the "Title".
            *   Instruction: Verify a Rich Text Editor component (e.g., `React-Quill`) is integrated for the "Content" input, providing common formatting options (bold, italic, lists, etc.).
            *   Instruction: Verify an MUI `<Button type="submit">` is present.
        3.  **Form Handling and Validation (with `react-hook-form`):**
            *   Instruction: Verify validation rules: `title` is required; `content` (from the rich text editor) is required (editor's content should be extracted and validated).
            *   Instruction: Check for display of validation errors.
        4.  **API Call on Submission:**
            *   Instruction: On valid form submission, verify an API call is made to create a new discussion (e.g., `POST /api/discussions`) with the `title` and HTML `content` from the editor.
        5.  **Navigation and Feedback on Success:**
            *   Instruction: After a successful API response, verify the user is navigated to the newly created discussion's page (e.g., `/discussions/:newThreadId`) or back to the discussion list (`/discussions`).
            *   Instruction: Verify a success notification (e.g., toast message) is displayed.
        6.  **Loading and Error State Handling:**
            *   Instruction: Verify a loading indicator on the submit button during API call.
            *   Instruction: Verify display of API error messages if creation fails.

---

## Epic: Admin Panel UI

### User Story 37: Develop Admin Panel Layout and Navigation
*   **As an** administrator,
*   **I want** a dedicated admin panel section with a distinct layout (e.g., sidebar navigation) that provides easy access to all management features,
*   **So that** I can efficiently manage the HOA system.

    **Technical Requirements:**
    1.  **Admin Layout Component (`components/layout/AdminLayout.jsx`):**
        *   This component will wrap all admin pages (e.g., `/admin/*`).
        *   Uses MUI `Box` for overall structure, potentially with a persistent `Drawer` for sidebar navigation on larger screens, collapsing to a temporary `Drawer` triggered by a menu icon on smaller screens.
        *   The main content area will render an `Outlet` for the specific admin page.
    2.  **Admin Sidebar Navigation (`components/admin/AdminSidebar.jsx`):**
        *   Displayed within the `AdminLayout`.
        *   Uses MUI `List` and `ListItemButton` (with `ListItemIcon` and `ListItemText`) for navigation links.
        *   Links (using `NavLink` from `react-router-dom` for active state styling) to:
            *   Admin Dashboard (e.g., `/admin/dashboard`)
            *   User Management (`/admin/users`)
            *   Document Management (`/admin/documents`)
            *   Announcement Management (`/admin/announcements`)
            *   Event Management (`/admin/events`)
            *   Discussion Management (`/admin/discussions`)
            *   Configuration (`/admin/config`)
            *   Audit Logs (`/admin/audit-logs`)
    3.  **Routing:** All routes under `/admin/` will use `AdminLayout` and be protected by `AdminProtectedRoute`.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `routes/AppRoutes.jsx` (or admin-specific route config):**
            *   Instruction: Verify that all routes prefixed with `/admin/` (e.g., `/admin/users`, `/admin/documents`) are wrapped by an `AdminLayout` component and an `AdminProtectedRoute`.
        2.  **Inspect `components/layout/AdminLayout.jsx`:**
            *   Instruction: Verify it renders a distinct layout structure, typically including a sidebar area (for `AdminSidebar`) and a main content area (for an `<Outlet />`).
            *   Instruction: Check responsiveness: e.g., sidebar is persistent on desktop and collapses to a temporary drawer on mobile.
        3.  **Inspect `components/admin/AdminSidebar.jsx` (or similar):**
            *   Instruction: Verify it uses MUI `<List>`, `<ListItemButton>`, `<ListItemIcon>`, `<ListItemText>` to create navigation items.
            *   Instruction: Confirm links exist for all admin sections: Dashboard (Admin), User Management, Document Management, Announcement Management, Event Management, Discussion Management, Configuration, Audit Logs.
            *   Instruction: Verify these links use `react-router-dom`'s `<NavLink>` (or equivalent logic with `Link` and `useMatch`) to correctly navigate to the respective admin pages and highlight the active link.
        4.  **Navigation Test:**
            *   Instruction: As an admin, navigate through all links in the admin sidebar. Verify each link leads to the correct (placeholder or implemented) admin page and the main content area updates, while the admin layout (sidebar, header if any) remains consistent.

### User Story 38: Develop Admin User Management UI
*   **As an** administrator,
*   **I want** a UI to list all non-system users, approve pending registrations, change user roles, trigger password changes for users, and delete user accounts,
*   **So that** I can fully manage user access and lifecycle.

    **Technical Requirements:**
    1.  **Component (`pages/admin/UserManagementPage.jsx`):**
    2.  **Data Display:** MUI `Table` to display users (ID, Name, Email, Role, Status, Joined Date). Fetches from `/api/admin/users` (paginated).
    3.  **Actions per User (in table rows, e.g., using an actions column with `IconButton`s or a `Menu`):**
        *   **Approve:** Button visible for 'pending' users. Calls `userService.approveUser(userId)`.
        *   **Change Role:** Dropdown/Select (MUI `Select`) with 'member', 'admin'. On change, calls `userService.updateUserRole(userId, newRole)`.
        *   **Change Password:** Button opens an MUI `Dialog` (modal). Dialog has a `TextField` for new password, confirm password. Submit calls `userService.changeUserPassword(userId, newPassword)`.
        *   **Delete:** `IconButton` (`<DeleteIcon />`). Opens a `ConfirmationDialog` component. On confirm, calls `userService.deleteUser(userId)`.
    4.  **Feedback:** Use toasts/`Alert`s for action success/failure. Table should refresh or update optimistically.
    5.  **Pagination:** MUI `TablePagination` component integrated with API calls.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/admin/UserManagementPage.jsx`:**
            *   Instruction: Verify an API call is made to fetch users (e.g., `GET /api/admin/users` with pagination) and the data is displayed in an MUI `<Table>`.
            *   Instruction: Check table columns for: ID, Name, Email, Role, Status, Joined Date, and an "Actions" column.
        2.  **Approve User Action:**
            *   Instruction: For users with 'pending' status, verify an "Approve" button is visible.
            *   Instruction: On click, verify an API call (e.g., `PUT /api/admin/users/:id/status` with payload `{ status: 'approved' }`) is made.
            *   Instruction: On success, verify the user's status in the table updates to 'approved' and the "Approve" button is hidden/disabled for that user.
        3.  **Change Role Action:**
            *   Instruction: For each user, verify an MUI `<Select>` (or similar dropdown) is present to change their role (options: 'member', 'admin').
            *   Instruction: When a new role is selected and confirmed (e.g., via a save button or on change), verify an API call (e.g., `PUT /api/admin/users/:id/role` with payload `{ role: newRole }`) is made.
            *   Instruction: On success, verify the user's role in the table updates.
        4.  **Change Password Action:**
            *   Instruction: Verify a "Change Password" button/icon is present for each user.
            *   Instruction: On click, verify an MUI `<Dialog>` opens containing a form with "New Password" and "Confirm Password" `<TextField>` elements.
            *   Instruction: On submitting this modal form (with validation for matching passwords and minimum length), verify an API call (e.g., `PUT /api/admin/users/:id/password` with payload `{ newPassword }`) is made.
            *   Instruction: Verify the modal closes on success and a success notification is shown.
        5.  **Delete User Action:**
            *   Instruction: Verify a "Delete" icon/button (e.g., MUI `<IconButton>` with `<DeleteIcon />`) is present for each user.
            *   Instruction: On click, verify a confirmation dialog (e.g., custom `ConfirmationDialog` component or MUI `<Dialog>`) appears asking for confirmation.
            *   Instruction: Upon confirmation, verify an API call (e.g., `DELETE /api/admin/users/:id`) is made.
            *   Instruction: On success, verify the user is removed from the table.
        6.  **Feedback and Pagination:**
            *   Instruction: Verify success/error notifications (toasts or MUI `<Alert>`) are displayed for all actions.
            *   Instruction: Verify MUI `<TablePagination>` (or similar) is implemented and correctly fetches paged data.

### User Story 39: Develop Admin Document Management UI
*   **As an** administrator,
*   **I want** a UI to upload new documents, list all existing documents (regardless of status), approve pending documents, and delete documents,
*   **So that** I can fully control the document lifecycle and availability.

    **Technical Requirements:**
    1.  **Component (`pages/admin/DocumentManagementPage.jsx`):**
    2.  **Upload Form:**
        *   MUI `TextField` for Title, Description.
        *   HTML5 `<input type="file">` (styled or using an MUI wrapper if available) for file selection.
        *   MUI `Checkbox` for "Is Public".
        *   MUI `Button` to submit. Uses `react-hook-form`. Submits `FormData` to `documentService.uploadDocument(formData)`.
    3.  **Document List:** MUI `Table` displaying all documents (ID, Title, Uploaded By (name), Uploaded At, Status (Approved/Pending), Is Public, Actions). Fetches from `/api/admin/documents` (or `/api/documents` if admin view gives all).
    4.  **Actions per Document:**
        *   **Approve:** Button for 'pending' documents. Calls `documentService.approveDocument(docId)`.
        *   **Delete:** `IconButton` (`<DeleteIcon />`). Opens `ConfirmationDialog`. Calls `documentService.deleteDocument(docId)`.
        *   **Download (Admin):** Link/button to download any document.
    5.  **Feedback & Pagination.**

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/admin/DocumentManagementPage.jsx`:**
        2.  **Upload Document Form:**
            *   Instruction: Verify a form exists with MUI `<TextField>` for Title and Description, an `<input type="file">` for file selection, an MUI `<Checkbox>` for "Is Public", and a submit `<Button>`.
            *   Instruction: (Using `react-hook-form`) Verify validation (e.g., title and file are required).
            *   Instruction: On submit, verify a `FormData` object is created and an API call (e.g., `POST /api/admin/documents`) is made via a service function.
            *   Instruction: On successful upload, verify the document list updates and a success notification is shown.
        3.  **Document List Table:**
            *   Instruction: Verify an API call fetches all documents for admin view (e.g., `GET /api/admin/documents` or `/api/documents` with admin context).
            *   Instruction: Verify the MUI `<Table>` displays columns for: ID, Title, Uploaded By (Name), Uploaded At, Status (Approved/Pending), Is Public, and Actions.
        4.  **Approve Document Action:**
            *   Instruction: For documents with 'Pending' status, verify an "Approve" button is visible.
            *   Instruction: On click, verify an API call (e.g., `PUT /api/admin/documents/:id/approve`) is made.
            *   Instruction: On success, verify the document's status in the table updates to 'Approved'.
        5.  **Delete Document Action:**
            *   Instruction: Verify a "Delete" icon/button is present for each document.
            *   Instruction: On click, verify a confirmation dialog appears.
            *   Instruction: Upon confirmation, verify an API call (e.g., `DELETE /api/admin/documents/:id`) is made.
            *   Instruction: On success, verify the document is removed from the table.
        6.  **Admin Download Action:**
            *   Instruction: Verify a download link/button exists for each document, allowing admins to download any file regardless of its approved/public status.
        7.  **Feedback and Pagination:**
            *   Instruction: Verify notifications for all actions and functional pagination for the document list.

### User Story 40: Develop Admin Announcement Management UI
*   **As an** administrator,
*   **I want** a UI to create new announcements (using a rich text editor), list all existing announcements, edit their content, and delete them,
*   **So that** I can manage all aspects of community communications.

    **Technical Requirements:**
    1.  **Component (`pages/admin/AnnouncementManagementPage.jsx`):**
    2.  **Create/Edit Form (possibly in an MUI `Dialog` or separate view):**
        *   MUI `TextField` for Title.
        *   Rich Text Editor (e.g., `React-Quill`) for Content.
        *   MUI `Button` to Save. Uses `react-hook-form`.
        *   On Create: calls `announcementService.createAnnouncement({ title, content })`.
        *   On Edit: pre-fills form, calls `announcementService.updateAnnouncement(id, { title, content })`.
    3.  **Announcement List:** MUI `Table` (ID, Title, Content Snippet, Created At, Actions). Fetches from `/api/admin/announcements` (or `/api/announcements` with admin view).
    4.  **Actions per Announcement:**
        *   **Edit:** `IconButton` (`<EditIcon />`). Opens Create/Edit form/dialog pre-filled.
        *   **Delete:** `IconButton` (`<DeleteIcon />`). Opens `ConfirmationDialog`. Calls `announcementService.deleteAnnouncement(id)`.
    5.  **Feedback & Pagination.**

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/admin/AnnouncementManagementPage.jsx`:**
        2.  **Create/Edit Announcement Form (Dialog or separate view):**
            *   Instruction: Verify a form exists with an MUI `<TextField>` for Title and a Rich Text Editor (`React-Quill`) for Content.
            *   Instruction: Verify a "Save" (or "Create"/"Update") `<Button>` is present.
            *   Instruction: (Using `react-hook-form`) Validate title and content are required.
            *   Instruction: When creating, verify an API call (e.g., `POST /api/admin/announcements`) is made.
            *   Instruction: When editing (form pre-filled with existing announcement data), verify an API call (e.g., `PUT /api/admin/announcements/:id`) is made.
            *   Instruction: On success, verify the announcement list updates/item updates and a success notification is shown. The form/dialog should close.
        3.  **Announcement List Table:**
            *   Instruction: Verify an API call fetches all announcements for admin view.
            *   Instruction: Verify the MUI `<Table>` displays columns for: ID, Title, Content (snippet, safely rendered if HTML), Created At, and Actions.
        4.  **Edit Action:**
            *   Instruction: Verify an "Edit" icon/button is present for each announcement.
            *   Instruction: On click, verify the Create/Edit form opens, pre-filled with the selected announcement's data.
        5.  **Delete Action:**
            *   Instruction: Verify a "Delete" icon/button is present for each announcement.
            *   Instruction: On click, verify a confirmation dialog appears.
            *   Instruction: Upon confirmation, verify an API call (e.g., `DELETE /api/admin/announcements/:id`) is made.
            *   Instruction: On success, verify the announcement is removed from the table.
        6.  **Feedback and Pagination:**
            *   Instruction: Verify notifications for all actions and functional pagination.

### User Story 41: Develop Admin Event Management UI
*   **As an** administrator,
*   **I want** a UI to create new events, list all existing events, edit their details (title, description, dates, location), and delete them,
*   **So that** I can manage the community calendar and event information.

    **Technical Requirements:**
    1.  **Component (`pages/admin/EventManagementPage.jsx`):**
    2.  **Create/Edit Form (Dialog or separate view):**
        *   MUI `TextField` for Title, Description, Location.
        *   MUI X `DateTimePicker` components for Start Date and End Date.
        *   MUI `Button` to Save. Uses `react-hook-form`.
        *   Validation: Title, Start/End Dates, Location required. End Date > Start Date.
        *   On Create: calls `eventService.createEvent(eventData)`.
        *   On Edit: pre-fills form, calls `eventService.updateEvent(id, eventData)`.
    3.  **Event List:** MUI `Table` (ID, Title, Start Date, End Date, Location, Actions). Fetches from `/api/admin/events`.
    4.  **Actions per Event:**
        *   **Edit:** `IconButton` (`<EditIcon />`). Opens form/dialog pre-filled.
        *   **Delete:** `IconButton` (`<DeleteIcon />`). Opens `ConfirmationDialog`. Calls `eventService.deleteEvent(id)`.
    5.  **Feedback & Pagination.**

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/admin/EventManagementPage.jsx`:**
        2.  **Create/Edit Event Form (Dialog or separate view):**
            *   Instruction: Verify a form with MUI `<TextField>` for Title, Description, Location, and MUI X `<DateTimePicker>` components for Start Date and End Date.
            *   Instruction: (Using `react-hook-form`) Validate required fields and that End Date is after Start Date.
            *   Instruction: When creating, verify `POST /api/admin/events` is called.
            *   Instruction: When editing, verify `PUT /api/admin/events/:id` is called.
            *   Instruction: On success, list updates, notification shown, form/dialog closes.
        3.  **Event List Table:**
            *   Instruction: Verify API call fetches all events for admin.
            *   Instruction: MUI `<Table>` columns: ID, Title, Start Date (formatted), End Date (formatted), Location, Actions.
        4.  **Edit Action:**
            *   Instruction: "Edit" icon/button opens form pre-filled with event data.
        5.  **Delete Action:**
            *   Instruction: "Delete" icon/button opens confirmation dialog. On confirm, `DELETE /api/admin/events/:id` is called. Event removed from table on success.
        6.  **Feedback and Pagination:**
            *   Instruction: Verify notifications and pagination.

### User Story 42: Develop Admin Discussion Management UI
*   **As an** administrator,
*   **I want** a UI to list all discussion threads and their replies, and have the ability to delete entire threads or individual replies,
*   **So that** I can moderate community discussions and remove inappropriate content.

    **Technical Requirements:**
    1.  **Component (`pages/admin/DiscussionManagementPage.jsx`):**
    2.  **Display:**
        *   Fetch all main threads (`discussionService.getAllDiscussionsForAdmin()`).
        *   Display threads in a list/tree structure (e.g., MUI `TreeView` or nested `List`s). Each thread shows title, author, date.
        *   Clicking a thread expands to show its replies (fetched on demand or with initial thread data). Replies show content snippet, author, date.
    3.  **Actions:**
        *   **Delete Thread:** Button/icon next to each main thread. Opens `ConfirmationDialog`. Calls `discussionService.deleteThreadAsAdmin(threadId)`. UI refreshes.
        *   **Delete Reply:** Button/icon next to each reply. Opens `ConfirmationDialog`. Calls `discussionService.deleteReplyAsAdmin(replyId)`. UI refreshes.
    4.  **Feedback & Pagination (for main threads).**

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/admin/DiscussionManagementPage.jsx`:**
        2.  **Discussion Display:**
            *   Instruction: Verify API call fetches discussion threads (and potentially replies, or replies are fetched on expansion).
            *   Instruction: Verify threads are displayed in a hierarchical or expandable list (e.g., MUI `<TreeView>` or custom expandable items). Main threads show title, author, date.
            *   Instruction: When a thread is expanded, verify its replies are shown, each with content snippet, author, and date.
        3.  **Delete Thread Action:**
            *   Instruction: Verify a "Delete Thread" icon/button is present for each main discussion thread.
            *   Instruction: On click, verify a confirmation dialog appears.
            *   Instruction: Upon confirmation, verify an API call (e.g., `DELETE /api/admin/discussions/:threadId`) is made.
            *   Instruction: On success, verify the thread (and its visible replies) is removed from the UI.
        4.  **Delete Reply Action:**
            *   Instruction: Verify a "Delete Reply" icon/button is present for each individual reply.
            *   Instruction: On click, verify a confirmation dialog appears.
            *   Instruction: Upon confirmation, verify an API call (e.g., `DELETE /api/admin/discussions/replies/:replyId`) is made.
            *   Instruction: On success, verify the reply is removed from the UI.
        5.  **Feedback and Pagination (for main threads):**
            *   Instruction: Verify notifications for delete actions.
            *   Instruction: Verify pagination for the list of main discussion threads, if applicable.

### User Story 43: Develop Admin Configuration Management UI
*   **As an** administrator,
*   **I want** a UI to view all current site configuration key-value pairs and update their values,
*   **So that** I can customize site-wide settings like HOA name and description.

    **Technical Requirements:**
    1.  **Component (`pages/admin/ConfigManagementPage.jsx`):**
    2.  **Data Fetching:** Calls `configService.getAllConfig()` (gets all key-value pairs from `/api/admin/config`).
    3.  **Display & Edit:**
        *   Display key-value pairs in a list or form-like structure. Each key shown as `Typography` or `InputLabel`. Each value in an MUI `TextField`.
        *   An MUI `Button` ("Save Changes" or individual save buttons per item) to submit updates.
    4.  **Update Logic:**
        *   When "Save Changes" is clicked, iterate through modified fields. For each, call `configService.updateConfig(key, newValue)`.
        *   Alternatively, if individual save, the specific key's value is sent.
    5.  **Feedback:** Success/error toasts for updates.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/admin/ConfigManagementPage.jsx`:**
        2.  **Configuration Display and Editing:**
            *   Instruction: Verify an API call (e.g., `GET /api/admin/config`) fetches the current site configurations.
            *   Instruction: Verify configurations are displayed as a list of key-value pairs, where keys are labels (e.g., MUI `<InputLabel>`) and values are editable in MUI `<TextField>` components.
        3.  **Update Mechanism:**
            *   Instruction: Verify a "Save Changes" MUI `<Button>` (or individual save buttons per config item) is present.
            *   Instruction: On clicking "Save", verify that for each modified configuration value, an API call (e.g., `PUT /api/admin/config/:key` with the new value) is made.
            *   Instruction: Alternatively, if a single save button updates all, verify it sends all (or just changed) key-value pairs to a batch update endpoint if available, or makes multiple individual PUT requests.
        4.  **Feedback:**
            *   Instruction: Verify success notifications (e.g., toasts) are displayed when configurations are updated successfully.
            *   Instruction: Verify error messages are shown if an update fails.

### User Story 44: Develop Admin Audit Log Viewer UI
*   **As an** administrator,
*   **I want** a UI to view a paginated list of audit log entries, showing timestamp, admin name, action performed, and details,
*   **So that** I can track administrative actions and monitor system changes.

    **Technical Requirements:**
    1.  **Component (`pages/admin/AuditLogPage.jsx`):**
    2.  **Data Fetching:** Calls `auditLogService.getAuditLogs()` (paginated, from `/api/admin/audit-logs`).
    3.  **Display:** MUI `Table` with columns: Timestamp (formatted), Admin Name, Action, Details.
    4.  **Pagination:** MUI `TablePagination`.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `pages/admin/AuditLogPage.jsx`:**
        2.  **Audit Log Display:**
            *   Instruction: Verify an API call (e.g., `GET /api/admin/audit-logs` with pagination parameters) fetches audit log entries.
            *   Instruction: Verify the audit logs are displayed in an MUI `<Table>`.
            *   Instruction: Check table columns for: Timestamp (formatted readably), Admin Name, Action (e.g., 'user_update'), and Details.
        3.  **Pagination:**
            *   Instruction: Verify MUI `<TablePagination>` (or similar) is implemented and allows navigation through pages of audit log entries, correctly fetching data for each page.
        4.  **Loading and Error State Handling:**
            *   Instruction: Verify a loading indicator while logs are fetched.
            *   Instruction: Verify an error message if fetching logs fails.

---

## Epic: State Management and API Integration (General)

### User Story 45: Implement Global State Management (Auth & Site Config)
*   **As a** frontend developer,
*   **I want** to implement a global state management solution using React Context API for critical shared data like user authentication details and site configuration (e.g., HOA name),
*   **So that** this information is easily and consistently accessible throughout the application without prop drilling.

    **Technical Requirements:**
    1.  **AuthContext (`contexts/AuthContext.jsx`):**
        *   Manages `user` object, `token`, `isAuthenticated` boolean.
        *   Provides `login(userData, token)`, `logout()`, `loadUserFromToken()` functions.
        *   `loadUserFromToken()`: On app load, checks `localStorage` for a token. If found, decodes it (or calls a backend `/api/auth/me` endpoint to validate and get user data) and populates context.
    2.  **SiteConfigContext (`contexts/SiteConfigContext.jsx`):**
        *   Manages `siteConfig` object (e.g., `{ hoaName, hoaDescription, hoaLogo }`).
        *   Provides `fetchSiteConfig()` function, called on app load. Fetches from a public config endpoint (e.g., `/api/config/public`).
        *   Provides loading and error states for config fetching.
    3.  **Providers:** Wrap the root application component (`App.jsx`) with `<AuthProvider>` and `<SiteConfigProvider>`.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `contexts/AuthContext.jsx`:**
            *   Instruction: Verify it manages state for `user`, `token`, `isAuthenticated`.
            *   Instruction: Confirm it provides `login(userData, token)` and `logout()` functions that correctly update this state and interact with `localStorage` (if used for token persistence).
            *   Instruction: If token persistence is used, verify a function like `loadUserFromToken()` is called on initial app load (e.g., in the `AuthProvider`'s `useEffect`). This function should retrieve the token from `localStorage`, and if present, update the context state (potentially after validating the token with a backend call to `/api/auth/me` or by decoding it client-side if expiry is checked).
        2.  **Inspect `contexts/SiteConfigContext.jsx`:**
            *   Instruction: Verify it manages state for `siteConfig` (e.g., an object containing `hoaName`).
            *   Instruction: Confirm it provides a function to fetch this configuration (e.g., from `/api/config/public` or a general `/api/config` if it's public) and updates the context state.
            *   Instruction: Verify this fetch function is called when the `SiteConfigProvider` mounts.
            *   Instruction: Check for handling of loading and error states for config fetching.
        3.  **Inspect `main.jsx` or `App.jsx`:**
            *   Instruction: Verify the root of the application is wrapped by `<AuthProvider>` and `<SiteConfigProvider>` (order might matter depending on dependencies).
        4.  **Test context consumption:**
            *   Instruction: In a component like `Header.jsx`, verify it consumes `AuthContext` to display user-specific links and `SiteConfigContext` to display the HOA name.
            *   Instruction: Test login/logout and verify dependent components update correctly.
            *   Instruction: Refresh the page after login (if using token persistence) and verify the authenticated state is restored.

### User Story 46: Create API Service Layer with Axios
*   **As a** frontend developer,
*   **I want** to create a dedicated API service layer using Axios, including a centralized client configuration with request/response interceptors for token handling and global error management,
*   **So that** all backend API interactions are consistent, maintainable, and abstracted from UI components.

    **Technical Requirements:**
    1.  **Axios Client (`services/apiClient.js`):**
        *   Create an Axios instance: `axios.create({ baseURL: process.env.REACT_APP_API_URL })`.
        *   **Request Interceptor:**
            *   Retrieves token from `AuthContext` (or `localStorage`).
            *   If token exists, adds `Authorization: Bearer ${token}` header to outgoing requests.
        *   **Response Interceptor:**
            *   Handles global errors: e.g., if 401 Unauthorized is received, trigger logout in `AuthContext` and redirect to `/login`.
            *   Standardizes error object format if needed.
    2.  **Service Modules (e.g., `services/authService.js`, `documentService.js`, etc.):**
        *   Each module exports async functions for specific API operations (e.g., `authService.login(credentials)`).
        *   These functions use the configured `apiClient` to make requests.
        *   They `try/catch` errors, potentially re-throwing a standardized error or returning `null/undefined` for components to handle.
        *   Example: `async login(credentials) { try { const response = await apiClient.post('/auth/login', credentials); return response.data; } catch (error) { throw error.response?.data || error; } }`

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect `services/apiClient.js` (or similar):**
            *   Instruction: Verify an Axios instance is created using `axios.create()`.
            *   Instruction: Confirm `baseURL` is configured, ideally from an environment variable (e.g., `process.env.REACT_APP_API_URL` or `import.meta.env.VITE_API_URL` for Vite).
        2.  **Inspect Axios Request Interceptor:**
            *   Instruction: Verify `apiClient.interceptors.request.use()` is implemented.
            *   Instruction: Inside the interceptor, confirm it attempts to retrieve the authentication token (e.g., from `localStorage.getItem('authToken')` or by accessing `AuthContext`).
            *   Instruction: If a token is found, verify it adds an `Authorization` header to the request config (e.g., `config.headers.Authorization = Bearer ${token};`).
        3.  **Inspect Axios Response Interceptor (Optional but Recommended for Global Error Handling):**
            *   Instruction: Verify `apiClient.interceptors.response.use()` is implemented for handling responses or errors globally.
            *   Instruction: Check if it specifically handles 401 Unauthorized errors by, for example, triggering a logout action (from `AuthContext`) and redirecting to login.
            *   Instruction: Check if it standardizes error objects passed to service function callers.
        4.  **Inspect at least one service module (e.g., `services/authService.js`):**
            *   Instruction: Verify it imports and uses the configured `apiClient` instance.
            *   Instruction: For each function (e.g., `login`, `register`), verify it makes the correct HTTP request (method, URL path, payload) using `apiClient`.
            *   Instruction: Check that it returns the `response.data` on success and properly throws or returns a structured error on failure (e.g., `error.response.data`).
        5.  **Inspect a component that uses a service function:**
            *   Instruction: Verify the component imports the service and calls its functions.
            *   Instruction: Confirm the component uses `async/await` with `try/catch` (or promise `.then().catch()`) to handle the results/errors from the service function.

================
File: integration-plan.md
================
# Integration Plan

## Goal

To successfully integrate the newly developed React frontend with the Node.js backend API, ensuring all functionalities work end-to-end as expected. This phase also includes setting up and testing any third-party services (like email) and preparing the application for robust deployment, including using Docker.

## Expected Output

A fully integrated HOA application where the React frontend seamlessly communicates with the Node.js backend via defined API contracts. All features specified in the frontend and backend plans will be operational and tested across different user roles. External services will be correctly configured and functioning. The application will be packaged as Docker images, and local Docker Compose orchestration will be verified.

---

## Epic: API Endpoint Connection & End-to-End Feature Testing

### User Story 47: Integrate and Test User Authentication Flow (Registration, Login, Logout)
*   **As a** QA/dev team member,
*   **I want** to thoroughly test the complete user authentication lifecycle by connecting the React frontend (Login, Registration pages, Header) to the Node.js backend authentication API endpoints (`/api/auth/register`, `/api/auth/login`), verifying token generation, client-side storage, authenticated requests, and logout procedures.
*   **So that** users can securely register, log in, maintain sessions, access role-appropriate content, and log out, forming the security foundation of the application.

    **Technical Requirements & Testing Steps:**
    1.  **Environment Sanity Check:**
        *   Backend (Node.js): Running, accessible (e.g., `http://localhost:3001` if local), CORS configured to allow requests from the React dev server URL (e.g., `http://localhost:3000` or `http://localhost:5173` for Vite).
        *   Frontend (React): Dev server running, `REACT_APP_API_URL` (or `VITE_API_URL`) environment variable correctly set to the backend URL.
    2.  **Registration:**
        *   **Action:** Navigate to the React registration page (`/register`). Fill and submit the registration form with valid new user data.
        *   **Frontend Verification (Browser DevTools - Network Tab):** Observe a `POST` request to `/api/auth/register`. Inspect payload (name, email, password) and response (e.g., 201 Created, success message).
        *   **Frontend Verification (UI):** Confirm a success message like "Registration successful. Your account is pending approval" is displayed.
        *   **Backend Verification (Logs & DB):** Check Node.js server logs for request processing. Query the SQLite `users` table to verify a new user record with `status: 'pending'`, `role: 'member'`, and a hashed password.
    3.  **Login with Pending User:**
        *   **Action:** Attempt to log in via the React login page (`/login`) using the newly registered (pending) user's credentials.
        *   **Frontend Verification (Network Tab):** Observe `POST /api/auth/login`. Inspect response (e.g., 403 Forbidden, error message "Account pending approval").
        *   **Frontend Verification (UI):** Confirm the specific error message is displayed on the login page.
    4.  **Account Approval (Simulated/Actual):**
        *   Manually update the user's `status` to `'approved'` in the backend database, OR use the (to-be-tested) admin UI to approve the user if that part of the integration is ready.
    5.  **Login with Approved User:**
        *   **Action:** Log in with the now-approved user's credentials.
        *   **Frontend Verification (Network Tab):** Observe `POST /api/auth/login`. Inspect response (e.g., 200 OK, JWT in response body, user details).
        *   **Frontend Verification (Client State & UI):**
            *   Check `localStorage` (if used for token) or React Context state (via React DevTools) to confirm the JWT and user data are stored.
            *   Confirm redirection to the dashboard (`/dashboard`).
            *   Confirm UI elements (e.g., Header navigation) update to reflect authenticated state (e.g., "Logout" visible, user name displayed).
    6.  **Authenticated API Requests:**
        *   **Action:** Navigate to a protected page that fetches data (e.g., Dashboard loading announcements).
        *   **Frontend Verification (Network Tab):** Observe API requests (e.g., `GET /api/announcements`). Verify the `Authorization: Bearer <JWT>` header is present and correct.
    7.  **Logout:**
        *   **Action:** Click the "Logout" button in the React UI.
        *   **Frontend Verification (Client State & UI):** Confirm JWT is cleared from storage/context. Confirm redirection to `/login` or `/`. Confirm UI updates to unauthenticated state.
        *   **Frontend Verification (Access):** Attempt to navigate to a protected route (e.g., `/dashboard`). Verify redirection back to `/login`.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Inspect network requests from React login/registration forms using browser developer tools:**
            *   Instruction: Verify that when the registration form is submitted, a `POST` request is made to the `/api/auth/register` endpoint with a JSON payload containing `name`, `email`, and `password`. Check for a 201 status and success message in the response.
            *   Instruction: Verify that when the login form is submitted with valid, approved credentials, a `POST` request is made to the `/api/auth/login` endpoint with a JSON payload containing `email` and `password`. Check for a 200 status and a response body containing a JWT (`token`) and user details.
            *   Instruction: Verify subsequent requests to protected API endpoints from the React app include an `Authorization: Bearer <token>` header with the received JWT.
        2.  **Inspect React application state (e.g., using React DevTools for Context or Redux state) and behavior after login/logout:**
            *   Instruction: Upon a successful login, confirm that the received JWT and user object are stored in the designated client-side state management solution (e.g., `AuthContext` and potentially `localStorage`).
            *   Instruction: Verify the user is programmatically redirected to `/dashboard` (or the intended post-login page) after successful login.
            *   Instruction: After logout, verify the JWT is cleared from client-side storage/state, and the user is redirected to `/login` or `/`.
        3.  **Inspect backend logs and the `users` table in the database:**
            *   Instruction: After a test registration, query the `users` table to confirm a new record exists with `status='pending'`.
            *   Instruction: After an admin approves the user (manually or via UI if integrated) and the user logs in, verify the backend logs show successful authentication.
        4.  **Test error paths:**
            *   Instruction: Attempt login with incorrect credentials; verify a 401 response from backend and appropriate error message in React UI.
            *   Instruction: Attempt login with correct credentials for a 'pending' user; verify a 403 response and relevant message in UI.

### User Story 48: Integrate and Test Document Management Features (User and Admin)
*   **As a** QA/dev team member,
*   **I want** to connect and test the React document management UI (public listing, user dashboard listing, admin CRUD panel) with the Node.js document API endpoints, verifying all functionalities including listing by permission, download, upload, approval, and deletion.
*   **So that** document sharing and administration works correctly and securely for all user roles.

    **Technical Requirements & Testing Steps:**
    1.  **Public Document Listing & Download (Guest User):**
        *   **Action:** Navigate to `/documents` in React UI without being logged in.
        *   **Frontend/Backend Verification:** Observe `GET /api/documents`. Verify only documents marked `is_public: true` AND `approved: true` are returned and displayed. Click download on one; verify `GET /api/documents/:id/download` is called and file downloads.
    2.  **Authenticated Member Document Listing & Download:**
        *   **Action:** Log in as a 'member'. Navigate to `/documents` or `/dashboard` (document section).
        *   **Frontend/Backend Verification:** Observe `GET /api/documents`. Verify all documents with `approved: true` (both public and private) are returned and displayed. Test download for a private, approved document.
    3.  **Admin Document Upload:**
        *   **Action:** Log in as 'admin'. Navigate to admin document management (`/admin/documents`). Use the upload form to upload a new PDF document with title "Test Admin PDF", description "Admin test", and mark "Is Public" as true. Then upload another, "Test Private PDF", with "Is Public" as false.
        *   **Frontend/Backend Verification:** Observe `POST /api/admin/documents` calls with `multipart/form-data`. Payloads correct. Backend responds 201. UI list updates.
        *   **Backend Verification (DB & File System):** Check `documents` table: "Test Admin PDF" should be `is_public: true`, `approved: true`. "Test Private PDF" should be `is_public: false`, `approved: false`. Files exist on server. Audit log entries created.
    4.  **Admin Document Approval:**
        *   **Action:** In admin UI, find "Test Private PDF" (should be 'Pending'). Click "Approve".
        *   **Frontend/Backend Verification:** Observe `PUT /api/admin/documents/:id/approve`. Backend responds 200. UI status updates to 'Approved'.
        *   **Backend Verification (DB):** "Test Private PDF" now `approved: true`. Audit log entry.
    5.  **Verify Member Access to Newly Approved Private Doc:**
        *   **Action:** Log out admin. Log in as 'member'. Navigate to `/documents`.
        *   **Frontend/Backend Verification:** "Test Private PDF" should now be listed and downloadable.
    6.  **Admin Document Deletion:**
        *   **Action:** Log in as 'admin'. Delete "Test Admin PDF". Confirm deletion in dialog.
        *   **Frontend/Backend Verification:** Observe `DELETE /api/admin/documents/:id`. Backend responds 200/204. UI list updates.
        *   **Backend Verification (DB & File System):** "Test Admin PDF" record deleted from DB. File removed from server. Audit log entry.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Verify frontend API calls for document operations using browser developer tools (Network tab):**
            *   Instruction: Guest user on `/documents` page: `GET /api/documents` is called.
            *   Instruction: Admin uploading document: `POST /api/admin/documents` with `FormData`.
            *   Instruction: Admin approving document: `PUT /api/admin/documents/:id/approve`.
            *   Instruction: Admin deleting document: `DELETE /api/admin/documents/:id`.
            *   Instruction: Any user downloading document: `GET /api/documents/:id/download`.
        2.  **Verify document listing and access permissions in React UI based on user role:**
            *   Instruction: As guest, ensure only documents where `is_public:true` AND `approved:true` are shown on `/documents`.
            *   Instruction: As 'member', ensure all documents where `approved:true` are shown on `/documents` or dashboard.
            *   Instruction: As 'admin', ensure all documents (regardless of `is_public` or `approved` status) are shown in the `/admin/documents` management UI.
        3.  **Verify successful document upload by admin:**
            *   Instruction: Confirm the React UI shows a success message and the new document appears in the admin list.
            *   Instruction: Check server's configured upload directory to ensure the physical file is present with a unique name.
            *   Instruction: Query `documents` table to verify a new record with correct metadata (title, paths, `uploaded_by`, `is_public`, and `approved` status based on `is_public` flag) exists.
        4.  **Verify document approval and deletion by admin:**
            *   Instruction: After admin approves a document, verify its status changes in the React UI and in the `documents` table (`approved: true`).
            *   Instruction: After admin deletes a document, verify it's removed from the React UI, the physical file is deleted from the server, and the record is removed from the `documents` table.
        5.  **Verify audit logs for admin document actions:**
            *   Instruction: Query the `audit_logs` table to confirm entries are created for admin uploads, approvals, and deletions of documents.

### User Story 49: Integrate and Test Announcement Management Features
*   **As a** QA/dev team member,
*   **I want** to connect and test the React announcement UI (user dashboard/home listing, admin CRUD panel) with the Node.js announcement API endpoints, verifying creation with rich text, listing, editing, and deletion.
*   **So that** announcements are correctly managed by admins and displayed to users.

    **Technical Requirements & Testing Steps:**
    1.  **Admin Create Announcement:**
        *   **Action:** Log in as 'admin'. Navigate to `/admin/announcements`. Use form with Rich Text Editor to create an announcement with formatted content (bold, list).
        *   **Frontend/Backend Verification:** `POST /api/admin/announcements` with title and HTML content. Backend 201. UI updates.
        *   **Backend Verification (DB):** New record in `announcements` table with sanitized HTML, `created_by`. Audit log.
    2.  **User View Announcements:**
        *   **Action:** Log in as 'member'. Navigate to `/dashboard` or `/`.
        *   **Frontend/Backend Verification:** `GET /api/announcements`. Newly created announcement is listed. Formatted HTML content renders correctly and safely in React UI.
    3.  **Admin Edit Announcement:**
        *   **Action:** As 'admin', edit the created announcement's title and content.
        *   **Frontend/Backend Verification:** `PUT /api/admin/announcements/:id` with updated data. Backend 200. UI updates.
        *   **Backend Verification (DB):** Record updated. Audit log.
    4.  **Admin Delete Announcement:**
        *   **Action:** As 'admin', delete the announcement.
        *   **Frontend/Backend Verification:** `DELETE /api/admin/announcements/:id`. Backend 200/204. UI updates.
        *   **Backend Verification (DB):** Record deleted. Audit log.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Verify frontend API calls for announcement operations:**
            *   Instruction: Admin creating announcement: `POST /api/admin/announcements` with `title` and HTML `content`.
            *   Instruction: User viewing announcements (dashboard/home): `GET /api/announcements`.
            *   Instruction: Admin editing announcement: `PUT /api/admin/announcements/:id`.
            *   Instruction: Admin deleting announcement: `DELETE /api/admin/announcements/:id`.
        2.  **Verify announcement creation and rich text handling:**
            *   Instruction: When admin creates an announcement using the React rich text editor, confirm the HTML content is sent to the backend.
            *   Instruction: Query the `announcements` table to verify the `content` is stored (ideally sanitized by the backend).
            *   Instruction: When viewing the announcement as a user, verify the formatted HTML content is rendered correctly and safely in the React UI.
        3.  **Verify UI updates and data consistency:**
            *   Instruction: After admin creates, edits, or deletes an announcement, verify the admin list UI updates.
            *   Instruction: After admin creates/edits, verify the user-facing announcement list updates correctly on next fetch.
        4.  **Verify audit logs for admin announcement actions:**
            *   Instruction: Query `audit_logs` for entries related to announcement creation, updates, and deletions.

### User Story 50: Integrate and Test Event Management Features
*   **As a** QA/dev team member,
*   **I want** to connect and test the React event UI (user dashboard listing, admin CRUD panel) with the Node.js event API endpoints, verifying creation with date/time pickers, listing, editing, and deletion.
*   **So that** community events are correctly managed and displayed.

    **Technical Requirements & Testing Steps:**
    (Similar detailed steps as Announcements, focusing on event-specific fields like `start_date`, `end_date`, `location`, and validation of date pickers and date logic).
    1.  **Admin Create Event:** Use MUI X Date/Time Pickers. Validate start < end.
    2.  **User View Upcoming Events:** Filter by `upcoming`.
    3.  **Admin Edit Event.**
    4.  **Admin Delete Event.**

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Verify frontend API calls for event operations:**
            *   Instruction: Admin creating event: `POST /api/admin/events` with `title`, `description`, `start_date`, `end_date`, `location`.
            *   Instruction: User viewing events (dashboard): `GET /api/events` (potentially with `?filter=upcoming`).
            *   Instruction: Admin editing event: `PUT /api/admin/events/:id`.
            *   Instruction: Admin deleting event: `DELETE /api/admin/events/:id`.
        2.  **Verify event creation with date/time pickers:**
            *   Instruction: When admin creates an event using MUI X Date/Time pickers, confirm the selected dates/times are correctly formatted (e.g., ISO 8601 strings) and sent to the backend.
            *   Instruction: Verify client-side and backend validation for `start_date` being before `end_date`.
        3.  **Verify UI updates and data consistency for events:**
            *   Instruction: Check admin list and user-facing lists update correctly after CRUD operations.
            *   Instruction: Ensure dates/times are displayed in a user-friendly format in the UI.
        4.  **Verify audit logs for admin event actions:**
            *   Instruction: Query `audit_logs` for entries related to event creation, updates, and deletions.

### User Story 51: Integrate and Test Discussion Management Features
*   **As a** QA/dev team member,
*   **I want** to connect and test the React discussion UI (listing, viewing threads/replies, creating threads/replies by users, admin moderation) with the Node.js discussion API endpoints.
*   **So that** users can engage in discussions and admins can moderate effectively.

    **Technical Requirements & Testing Steps:**
    1.  **User Create Thread:** Use Rich Text Editor.
    2.  **User Post Reply:** Use Rich Text Editor.
    3.  **User View Threads & Replies:** Test pagination, correct display of nested content.
    4.  **Admin Delete Thread:** Verify thread and all its replies are removed.
    5.  **Admin Delete Reply:** Verify only the specific reply is removed.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Verify frontend API calls for discussion operations:**
            *   Instruction: User creating thread: `POST /api/discussions` with `title` and HTML `content`.
            *   Instruction: User posting reply: `POST /api/discussions/:threadId/replies` with HTML `content`.
            *   Instruction: User viewing thread list: `GET /api/discussions`.
            *   Instruction: User viewing specific thread: `GET /api/discussions/:threadId`.
            *   Instruction: Admin deleting thread: `DELETE /api/admin/discussions/:threadId`.
            *   Instruction: Admin deleting reply: `DELETE /api/admin/discussions/replies/:replyId`.
        2.  **Verify rich text handling for threads and replies:**
            *   Instruction: Confirm HTML content from React Rich Text Editor is sent to backend for new threads/replies.
            *   Instruction: Verify stored (sanitized) HTML content is fetched and rendered correctly/safely in the thread/reply views.
        3.  **Verify discussion structure and data integrity:**
            *   Instruction: After creating a thread and replies, verify they are correctly associated in the backend (`parent_id`) and displayed hierarchically in the UI.
            *   Instruction: After admin deletes a thread, verify both the main thread and all its replies are removed from DB and UI.
            *   Instruction: After admin deletes a reply, verify only that reply is removed.
        4.  **Verify audit logs for admin discussion moderation:**
            *   Instruction: Query `audit_logs` for entries related to thread/reply deletions by admins.

### User Story 52: Integrate and Test Admin User Management Full Workflow
*   **As a** QA/dev team member,
*   **I want** to test the entire admin user management workflow: listing users, approving a 'pending' user, changing a user's role, changing a user's password, and deleting a user, ensuring all UI interactions correctly call backend APIs and reflect changes.
*   **So that** administrators can fully manage user accounts through the React UI.

    **Technical Requirements & Testing Steps:**
    (This story consolidates testing of the admin user management UI connected to already-defined backend APIs.)
    1.  **List Users:** Verify `/api/admin/users` populates the admin table.
    2.  **Approve User:** Find a 'pending' user. Click 'Approve'. Verify `PUT /api/admin/users/:id/status` is called. User status updates in UI and DB. Audit log.
    3.  **Change Role:** Select a user. Change role via dropdown. Verify `PUT /api/admin/users/:id/role`. Role updates in UI and DB. Audit log.
    4.  **Change Password:** Select user. Use 'Change Password' modal. Verify `PUT /api/admin/users/:id/password`. Success message. Audit log. (User should be able to log in with new password).
    5.  **Delete User:** Select user. Confirm deletion. Verify `DELETE /api/admin/users/:id`. User removed from UI and DB. Associated documents also deleted. Audit log.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Verify user list display:**
            *   Instruction: In `/admin/users`, confirm a `GET /api/admin/users` call is made and populates an MUI `<Table>` with user data.
        2.  **Test "Approve User" functionality:**
            *   Instruction: For a 'pending' user, click "Approve". Verify a `PUT /api/admin/users/:id/status` call is made with `{ status: 'approved' }`. Confirm UI and DB reflect the change. Audit log created.
        3.  **Test "Change Role" functionality:**
            *   Instruction: For a user, change their role using the UI dropdown. Verify a `PUT /api/admin/users/:id/role` call is made with `{ role: newRole }`. Confirm UI and DB reflect the change. Audit log created.
        4.  **Test "Change Password" functionality:**
            *   Instruction: For a user, use the "Change Password" modal. Verify a `PUT /api/admin/users/:id/password` call is made with `{ newPassword }`. Confirm a success message. Audit log created. Attempt login with the new password.
        5.  **Test "Delete User" functionality:**
            *   Instruction: For a user, click "Delete" and confirm. Verify a `DELETE /api/admin/users/:id` call is made. Confirm UI removes the user, DB record is deleted, and associated documents (files and DB entries) are deleted. Audit log created.

### User Story 53: Integrate and Test Admin Configuration Management
*   **As a** QA/dev team member,
*   **I want** to test the admin configuration management UI, ensuring it correctly fetches current configurations, allows admins to update values, and successfully calls the backend API to persist these changes.
*   **So that** site-wide settings can be managed by administrators.

    **Technical Requirements & Testing Steps:**
    1.  **View Config:** Navigate to `/admin/config`. Verify `GET /api/admin/config` is called, data populates form fields.
    2.  **Update Config:** Change a value (e.g., `hoa_name`). Click "Save". Verify `PUT /api/admin/config/:key` (or batch update) is called with new value. UI reflects change (or re-fetches). DB updated. Audit log.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Verify configuration display:**
            *   Instruction: In `/admin/config`, confirm a `GET /api/admin/config` call is made and populates editable fields (e.g., MUI `<TextField>`) with current key-value pairs.
        2.  **Test configuration update:**
            *   Instruction: Modify a configuration value in the UI and save. Verify a `PUT /api/admin/config/:key` call (or a batch update call) is made with the updated value(s).
            *   Instruction: Confirm the UI reflects the saved change (either immediately or on re-fetch). Query the `config` table in the DB to verify the update.
            *   Instruction: Verify an audit log entry is created for the configuration change.

### User Story 54: Integrate and Test Admin Audit Log Viewer
*   **As a** QA/dev team member,
*   **I want** to test the admin audit log viewer UI, ensuring it correctly fetches and displays paginated audit log entries from the backend API.
*   **So that** administrators can effectively monitor system activities.

    **Technical Requirements & Testing Steps:**
    1.  **View Audit Logs:** Navigate to `/admin/audit-logs`. Verify `GET /api/admin/audit-logs` is called (with pagination params).
    2.  **Test Pagination:** Use pagination controls. Verify correct API calls for subsequent pages are made and UI updates.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Verify audit log display:**
            *   Instruction: In `/admin/audit-logs`, confirm a `GET /api/admin/audit-logs` call is made (initially for the first page).
            *   Instruction: Verify the fetched audit log entries are displayed in an MUI `<Table>` with columns for Timestamp, Admin Name, Action, and Details.
        2.  **Test pagination functionality:**
            *   Instruction: If there are multiple pages of audit logs, use the MUI `<TablePagination>` controls. Verify that changing pages triggers new API calls with updated pagination parameters (e.g., `?page=2&limit=10`).
            *   Instruction: Confirm the table updates to show the correct set of logs for the selected page.

---

## Epic: Dockerization and Deployment Preparation

### User Story 58 (Reiteration for Integration context): Finalize and Test Build Scripts & Environment Configuration
*   **As a** DevOps/dev team member,
*   **I want** to finalize and test production build scripts for the React frontend, ensure the Node.js backend has a reliable production startup script, and comprehensively document all necessary environment variables for both,
*   **So that** the integrated application is fully prepared for consistent and repeatable deployments.

    **Technical Requirements & Testing Steps:**
    1.  **React Frontend Build Test:**
        *   **Action:** Execute `npm run build` (or `yarn build`).
        *   **Verification:** Confirm optimized static assets are generated in `dist/` (for Vite) or `build/` (for CRA).
        *   **Action:** Serve the static build locally (e.g., using `serve -s dist`). Access it in a browser.
        *   **Verification:** Perform a smoke test: login, navigate to a few pages, interact with a feature. Ensure the `REACT_APP_API_URL` (or `VITE_API_URL`) used by the build correctly points to the running backend.
    2.  **Node.js Backend Production Run Test:**
        *   **Action:** Create a `.env.production` file (or set system env vars) with production-like settings (e.g., different `PORT` if needed, production DB path if different, actual email service keys).
        *   **Action:** Run the backend using its production start script (e.g., `NODE_ENV=production npm start`).
        *   **Verification:** Backend starts without errors. Test API endpoints (e.g., with Postman) to confirm it's operational with these settings.
    3.  **CORS Policy Verification:**
        *   **Action:** With backend running in production mode and frontend build served locally (or from its intended production-like origin), test API calls from frontend.
        *   **Verification:** Ensure no CORS errors block communication. Backend `cors` middleware options should allow the frontend's origin.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Verify React frontend production build:**
            *   Instruction: Execute the frontend's production build script (e.g., `npm run build`). Confirm it completes successfully and creates an optimized bundle in the `dist` (or `build`) directory.
            *   Instruction: Serve the contents of the build directory using a local static server (e.g., `serve -s dist`). Access the application in a browser. Perform basic smoke tests (login, navigation) to ensure the build is functional and API calls are correctly configured (i.e., `VITE_API_URL` or `REACT_APP_API_URL` points to the running backend).
        2.  **Verify Node.js backend production startup:**
            *   Instruction: Ensure a `start` script is defined in the backend's `package.json` intended for production (e.g., `node server.js`).
            *   Instruction: Set `NODE_ENV=production` and any other production-specific environment variables (via a `.env` file loaded by `dotenv` or system environment variables). Start the backend using `npm start`. Verify it starts without errors and logs indicate it's running in production mode (if such logging exists).
        3.  **Verify and document all environment variables:**
            *   Instruction: Create/update a `.env.example` file in both frontend and backend projects, listing all required environment variables with descriptions and example values (e.g., `VITE_API_URL` for frontend; `PORT`, `DATABASE_PATH`, `JWT_SECRET`, `SENDGRID_API_KEY`, `ADMIN_EMAIL` for backend).
        4.  **Verify CORS configuration for production:**
            *   Instruction: Inspect the backend's CORS middleware setup. Confirm it's configured to allow requests from the intended production frontend domain(s) when `NODE_ENV` is 'production'. Test this by making requests from a frontend served from a different origin than `localhost` if possible (or by temporarily setting the frontend build to be served from a different port and adjusting CORS).

### User Story 59 (Reiteration for Integration context): Build and Test Dockerized Application with Docker Compose
*   **As a** DevOps/dev team member,
*   **I want** to build Docker images for the production-ready React frontend and Node.js backend, and use `docker-compose.yml` to orchestrate their local execution, including volume mounts for persistent data (SQLite DB, uploads),
*   **So that** I can verify the containerized application works end-to-end, simulating a deployment environment and ensuring all services interact correctly.

    **Technical Requirements & Testing Steps:**
    1.  **Review Dockerfiles:** Ensure `backend/Dockerfile` uses `--omit=dev` or `--production` for `npm install`, and `frontend/Dockerfile` performs a production build (`npm run build`) and serves static assets via Nginx/httpd.
    2.  **Review `docker-compose.yml`:**
        *   Verify services for `backend` and `frontend`.
        *   Ensure backend's `environment` section correctly passes all necessary env vars (or uses an `env_file`).
        *   Ensure frontend Nginx config correctly serves the SPA and proxies API requests to the `backend` service name if using Nginx as a reverse proxy (e.g., `proxy_pass http://backend:3000;`). Alternatively, ensure the frontend's `VITE_API_URL` is set to the backend's exposed Docker host port or a gateway URL.
        *   Verify volumes for SQLite DB file (e.g., `hoa_db_data:/app/database` inside container) and document uploads (e.g., `hoa_uploads_data:/app/uploads`).
    3.  **Build & Run:**
        *   **Action:** Execute `docker-compose up --build -d`.
        *   **Verification (Docker):** Check `docker ps` to see containers are running. Check `docker-compose logs -f backend frontend` for startup messages and errors.
    4.  **E2E Test in Docker Environment:**
        *   **Action:** Access the frontend application through the port exposed by Docker Compose for the frontend service (e.g., `http://localhost:8080`).
        *   **Verification:** Perform a comprehensive E2E test suite (manual or automated subset) covering all major features: registration, login, document upload/download, announcement creation/viewing, discussion interaction, admin functionalities.
    5.  **Data Persistence Test:**
        *   **Action:** Perform actions that create data (e.g., register user, upload document).
        *   **Action:** Execute `docker-compose down`.
        *   **Action:** Execute `docker-compose up -d` (without `--build` unless code changed).
        *   **Verification:** Access the application again. Verify the previously created data (user, document) still exists, confirming volume mounts are working correctly for the SQLite DB and uploads.
    6.  **Email Service Test (from within Docker):**
        *   **Action:** Trigger an action that sends an email (e.g., new user registration if admin notifications are set up).
        *   **Verification:** Check if the backend container can reach the email SaaS provider and if emails are sent/received. This might require ensuring Docker networking allows outbound connections.

*   `[ ] Completed`
    *   **Acceptance Criteria:**
        1.  **Verify Dockerfiles are optimized for production:**
            *   Instruction: Backend `Dockerfile`: `npm ci --omit=dev` is used. Multi-stage builds are used if beneficial to reduce image size.
            *   Instruction: Frontend `Dockerfile`: A multi-stage build is used where the first stage builds the React app (`npm run build`) and the final stage uses a lightweight server (Nginx/httpd) to serve static assets from the build output.
        2.  **Inspect `docker-compose.yml` for correct service definitions and configurations:**
            *   Instruction: Verify `build` contexts point to the correct Dockerfile locations.
            *   Instruction: Confirm port mappings expose the frontend (e.g., Nginx port 80) and backend (e.g., Node.js port 3000) to the host.
            *   Instruction: Verify the `environment` or `env_file` for the backend service correctly defines all necessary runtime environment variables (e.g., `DATABASE_PATH` pointing to the path *inside the container* where the volume is mounted, `JWT_SECRET`, etc.).
            *   Instruction: Verify the frontend service (Nginx) is configured to correctly serve the React SPA (e.g., `nginx.conf` has `try_files $uri $uri/ /index.html;`). If Nginx is also acting as a reverse proxy for API calls to the backend, verify its proxy configuration (e.g., `location /api/ { proxy_pass http://backend_service_name:backend_port; }`).
            *   Instruction: Verify named volumes or host-mounted volumes are correctly defined for the SQLite database file (e.g., `my_db_volume:/usr/src/app/database`) and the document uploads directory (e.g., `my_uploads_volume:/usr/src/app/uploads`).
        3.  **Successfully build and run the application using `docker-compose up --build`:**
            *   Instruction: Execute `docker-compose up --build`. Verify both frontend and backend containers build and start without errors. Check logs using `docker-compose logs frontend backend`.
        4.  **Perform E2E smoke tests on the containerized application:**
            *   Instruction: Access the React frontend via the host port mapped in `docker-compose.yml`.
            *   Instruction: Test key user flows: registration, login, viewing/downloading a document, creating an announcement, admin login and viewing an admin page. Confirm frontend successfully communicates with the backend service (using the backend service name if Nginx proxies, or the mapped host port if frontend calls host directly).
        5.  **Test data persistence across `docker-compose down` and `up`:**
            *   Instruction: Create some data (e.g., register a new user, upload a document). Then run `docker-compose down`. Then run `docker-compose up` again. Access the application and verify the previously created user and document are still present and accessible.
        6.  **Test email sending functionality from within the Docker environment (if applicable):**
            *   Instruction: Trigger an action that should send an email (e.g., new user registration). Verify the email is sent and received. Check backend container logs for any errors related to connecting to the email service provider.
