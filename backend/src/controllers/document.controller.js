const documentService = require('../services/document.service');
const { uploadDocumentSchema } = require('../validators/document.validator');
const multer = require('multer'); // To handle Multer errors specifically

/**
 * Handles document upload by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function uploadDocument(req, res, next) {
  try {
    // File is already handled by multer middleware if this controller is reached
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded or file type not allowed.' });
    }

    // Validate text fields
    const { error, value } = uploadDocumentSchema.validate(req.body);
    if (error) {
      // If validation fails, and a file was uploaded, it's good practice to remove the orphaned file.
      // However, fs.unlink can be complex here due to async nature and error paths.
      // For simplicity, this example doesn't remove orphaned files on validation error.
      // In a production app, consider a cleanup strategy.
      return res.status(400).json({
        message: 'Validation failed for document metadata.',
        errors: error.details.map(d => d.message)
      });
    }

    const documentData = {
      title: value.title,
      description: value.description,
      // originalFileName: req.file.originalname, // Available if needed
      storedFileName: req.file.filename,    // Name generated by Multer
      filePath: req.file.path,              // Full path where Multer stored the file
      uploadedBy: req.user.id,              // Assuming req.user is populated by auth middleware
      isPublic: value.is_public,
    };

    const newDocument = await documentService.createDocument(documentData);

    return res.status(201).json({
      message: 'Document uploaded successfully.',
      document: newDocument
    });

  } catch (err) {
    // Handle Multer-specific errors (like file size limit)
    if (err instanceof multer.MulterError) {
      if (err.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({ message: `File too large. Max size is ${process.env.MAX_FILE_SIZE_MB || 10}MB.` });
      }
      return res.status(400).json({ message: `File upload error: ${err.message}` });
    }
    // Handle other errors
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles listing documents for users/admins.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function listDocuments(req, res, next) {
  try {
    const { limit, offset } = req.query;
    // req.user might be undefined if the route is public and token is not provided
    const result = await documentService.listDocuments(req.user, { limit, offset });
    return res.status(200).json(result);
  } catch (err) {
    next(err);
  }
}

/**
 * Handles retrieving a specific document's metadata.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function getDocumentMetadata(req, res, next) {
  try {
    const documentId = parseInt(req.params.documentId, 10);
    if (isNaN(documentId)) {
      return res.status(400).json({ error: 'Invalid document ID format.' });
    }

    const document = await documentService.getDocumentMetadataById(documentId, req.user);
    // The service now throws specific errors, so a !document check is less likely here
    // unless the service is changed to return null for some cases again.
    // For now, we rely on the catch block.
    return res.status(200).json(document);
  } catch (err) {
    if (err.statusCode) {
      // Use 'error' key as requested
      return res.status(err.statusCode).json({ error: err.message });
    }
    next(err); // For unexpected errors
  }
}

/**
 * Handles downloading a specific document.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function downloadDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.documentId, 10);
    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    const document = await documentService.getDocumentForDownload(documentId, req.user);
    
    // The service throws an error if access is denied or document not found.
    // If we reach here, download is permitted.
    
    // Use res.download to trigger file download.
    // The 'file_name' from the DB should be the user-facing filename.
    // The 'file_path' from the DB is the actual path on the server.
    // Ensure file_path is secure and not subject to path traversal.
    // The documentService should ideally return the original filename if stored,
    // or use title as a fallback. For now, using document.file_name (stored unique name)
    // might not be user-friendly. Let's assume document.title is a good fallback.
    // The plan mentions: "assume file_name in DB is the user-facing filename for download."
    // This implies the original filename should be stored, perhaps in a field like `original_file_name`.
    // For now, using the stored `file_name` as the download name.
    
    // IMPORTANT: Ensure `document.file_path` is an absolute path or correctly resolved
    // to prevent security vulnerabilities. The Multer setup stores absolute paths.
    res.download(document.file_path, document.original_file_name, (err) => {
      if (err) {
        // Handle errors that occur after headers have been sent, like network issues
        // or if the file is missing (though getDocumentForDownload should catch this)
        console.error('Error during file download:', err);
        if (!res.headersSent) {
          return res.status(500).json({ message: 'Could not download the file.' });
        }
      }
    });

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles approving a document by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function adminApproveDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.id, 10);
    const adminUserId = req.user.id; // Assuming verifyToken middleware sets req.user

    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    const updatedDocument = await documentService.approveDocumentById(documentId, adminUserId);
    return res.status(200).json(updatedDocument);
  } catch (err) {
    // Pass errors to the error handling middleware
    // Specific error handling (e.g., for not found or permission issues)
    // should ideally be done in the service layer and result in custom error objects
    // that the global error handler can interpret.
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles deleting a document by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function adminDeleteDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.id, 10);
    const adminUserId = req.user.id; // Assuming verifyToken middleware sets req.user

    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    await documentService.deleteDocumentById(documentId, adminUserId);
    return res.status(204).send();
  } catch (err) {
    // Pass errors to the error handling middleware
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}
module.exports = {
  uploadDocument,
  listDocuments,
  getDocumentMetadata,
  downloadDocument,
  adminApproveDocument,
  adminDeleteDocument,
};