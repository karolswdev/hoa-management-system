This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-09T04:00:13.006Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
config/
  config.json
migrations/
  20250531213155-create-users-table.js
  20250531214039-create-users-table.js
  20250531214112-create-config-table.js
  20250531214127-create-verification-tokens-table.js
  20250531214148-create-events-table.js
  20250531214209-create-documents-table.js
  20250531214211-add-original-file-name-to-documents.js
  20250531214231-create-discussions-table.js
  20250531214251-create-announcements-table.js
  20250531214312-create-audit-logs-table.js
  20250531221950-add-expires_at-to-announcements.js
models/
  announcement.model.js
  auditLog.model.js
  config.model.js
  discussion.model.js
  document.model.js
  event.model.js
  index.js
  user.model.js
  verificationToken.model.js
seeders/
  20250531214351-initial-admin-user.js
  20250531214406-initial-site-config.js
src/
  controllers/
    admin.user.controller.js
    announcement.controller.js
    audit.controller.js
    auth.controller.js
    config.controller.js
    discussion.controller.js
    document.controller.js
    event.controller.js
    user.controller.js
  middlewares/
    auth.middleware.js
    upload.middleware.js
    validate.middleware.js
  routes/
    admin.user.routes.js
    announcement.routes.js
    audit.routes.js
    auth.routes.js
    config.routes.js
    discussion.routes.js
    document.routes.js
    event.routes.js
    public.document.routes.js
    user.routes.js
  services/
    announcement.service.js
    audit.service.js
    auth.service.js
    config.service.js
    discussion.service.js
    document.service.js
    event.service.js
    user.service.js
  utils/
    ApiError.js
    catchAsync.js
  validators/
    admin.user.validator.js
    announcement.validator.js
    audit.validator.js
    auth.validator.js
    config.validator.js
    discussion.validator.js
    document.validator.js
    event.validator.js
    user.validator.js
  app.js
test/
  good/
    announcements.test.js
    audit.test.js
    auth.test.js
    config.test.js
    discussions.test.js
    documents.test.js
    events.test.js
    users.test.js
  integration/
    discussions.test.js
    events.test.js
  seeders/
    test-seed.js
  utils/
    dbHelpers.js
    testSetup.js
package.json

================================================================
Files
================================================================

================
File: config/config.json
================
{
  "development": {
    "dialect": "sqlite",
    "storage": "database/hoa.db"
  },
  "test": {
    "dialect": "sqlite",
    "storage": "database/test.db"
  },
  "production": {
    "dialect": "sqlite",
    "storage": "database/hoa.db"
  }
}

================
File: migrations/20250531213155-create-users-table.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    /**
     * Add altering commands here.
     *
     * Example:
     * await queryInterface.createTable('users', { id: Sequelize.INTEGER });
     */
  },

  async down (queryInterface, Sequelize) {
    /**
     * Add reverting commands here.
     *
     * Example:
     * await queryInterface.dropTable('users');
     */
  }
};

================
File: migrations/20250531214039-create-users-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('users', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      name: {
        type: Sequelize.STRING,
        allowNull: false
      },
      email: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true
      },
      password: {
        type: Sequelize.STRING,
        allowNull: false
      },
      role: {
        type: Sequelize.STRING,
        allowNull: false,
        defaultValue: 'member'
      },
      status: {
        type: Sequelize.STRING,
        allowNull: false,
        defaultValue: 'pending'
      },
      email_verified: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      is_system_user: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('users');
  }
};

================
File: migrations/20250531214112-create-config-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('config', {
      key: {
        type: Sequelize.STRING,
        primaryKey: true,
        allowNull: false
      },
      value: {
        type: Sequelize.TEXT
      }
      // No timestamps for config table
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('config');
  }
};

================
File: migrations/20250531214127-create-verification-tokens-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('verification_tokens', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      user_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'users', // Name of the target table
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'
      },
      token: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true
      },
      type: {
        type: Sequelize.STRING, // e.g., 'email_verification', 'password_reset'
        allowNull: false
      },
      expires_at: {
        type: Sequelize.DATE,
        allowNull: false
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
      // No updated_at for verification tokens
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('verification_tokens');
  }
};

================
File: migrations/20250531214148-create-events-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('events', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: false
      },
      description: {
        type: Sequelize.TEXT
      },
      start_date: {
        type: Sequelize.DATE,
        allowNull: false
      },
      end_date: {
        type: Sequelize.DATE,
        allowNull: false
      },
      location: {
        type: Sequelize.STRING,
        allowNull: false
      },
      created_by: {
        type: Sequelize.INTEGER,
        allowNull: true,
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('events');
  }
};

================
File: migrations/20250531214209-create-documents-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('documents', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: false
      },
      description: {
        type: Sequelize.TEXT
      },
      file_name: { // Stored unique name
        type: Sequelize.STRING,
        allowNull: false
      },
      file_path: { // Server path
        type: Sequelize.STRING,
        allowNull: false
      },
      uploaded_by: {
        type: Sequelize.INTEGER,
        allowNull: true,
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      approved: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      is_public: {
        type: Sequelize.BOOLEAN,
        defaultValue: false
      },
      uploaded_at: { // mapped from createdAt
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('documents');
  }
};

================
File: migrations/20250531214211-add-original-file-name-to-documents.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    await queryInterface.addColumn('documents', 'original_file_name', {
      type: Sequelize.STRING,
      allowNull: false,
    });
  },

  async down (queryInterface, Sequelize) {
    await queryInterface.removeColumn('documents', 'original_file_name');
  }
};

================
File: migrations/20250531214231-create-discussions-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('discussions', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: true // Nullable for replies
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: false
      },
      user_id: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: {
          model: 'users', // Table name should be 'Users' if model name is User
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL' // Or 'CASCADE' if discussions should be deleted with user
      },
      parent_id: {
        type: Sequelize.INTEGER,
        allowNull: true, // Null for main threads
        references: {
          model: 'discussions', // Self-reference
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE' // If parent thread is deleted, replies are also deleted
      },
      document_id: {
        type: Sequelize.INTEGER,
        allowNull: true, // Null if not linked to a document
        references: {
          model: 'documents',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('discussions');
  }
};

================
File: migrations/20250531214251-create-announcements-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('announcements', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      title: {
        type: Sequelize.STRING,
        allowNull: false
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: false
      },
      created_by: {
        type: Sequelize.INTEGER,
        allowNull: true,
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('announcements');
  }
};

================
File: migrations/20250531214312-create-audit-logs-table.js
================
'use strict';
/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('audit_logs', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      admin_id: {
        type: Sequelize.INTEGER,
        allowNull: true, // As admin user might be deleted
        references: {
          model: 'users',
          key: 'id'
        },
        onUpdate: 'CASCADE',
        onDelete: 'SET NULL'
      },
      action: {
        type: Sequelize.STRING,
        allowNull: false
      },
      details: {
        type: Sequelize.TEXT // Can store JSON string or plain text
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
      }
      // No updated_at for audit logs
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('audit_logs');
  }
};

================
File: migrations/20250531221950-add-expires_at-to-announcements.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.addColumn('announcements', 'expires_at', {
      type: Sequelize.DATE,
      allowNull: true,
    });
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.removeColumn('announcements', 'expires_at');
  }
};

================
File: models/announcement.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Announcement extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Announcement.belongsTo(models.User, {
        foreignKey: 'created_by',
        as: 'creator',
        onDelete: 'SET NULL', // If user is deleted, announcement's creator is set to null
      });
    }
  }
  Announcement.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false
    },
    content: {
      type: DataTypes.TEXT,
      allowNull: false
    },
    created_by: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if creator user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    },
    expires_at: {
      type: DataTypes.DATE,
      allowNull: true
    }
  }, {
    sequelize,
    modelName: 'Announcement',
    tableName: 'announcements',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Announcement;
};

================
File: models/auditLog.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class AuditLog extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      AuditLog.belongsTo(models.User, {
        foreignKey: 'admin_id',
        as: 'adminUser', // Alias for the admin user who performed the action
        onDelete: 'SET NULL', // If admin user is deleted, keep the log but set admin_id to null
      });
    }
  }
  AuditLog.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    admin_id: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if admin user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    },
    action: {
      type: DataTypes.STRING,
      allowNull: false
    },
    details: {
      type: DataTypes.TEXT // Can store JSON string or plain text
    }
  }, {
    sequelize,
    modelName: 'AuditLog',
    tableName: 'audit_logs',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: false // Audit logs are typically immutable after creation
  });
  return AuditLog;
};

================
File: models/config.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Config extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
    }
  }
  Config.init({
    key: {
      type: DataTypes.STRING,
      primaryKey: true,
      allowNull: false
    },
    value: {
      type: DataTypes.TEXT
    }
  }, {
    sequelize,
    modelName: 'Config',
    tableName: 'config',
    timestamps: false // No createdAt/updatedAt for config table as per original schema
  });
  return Config;
};

================
File: models/discussion.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Discussion extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Discussion.belongsTo(models.User, {
        foreignKey: 'user_id',
        as: 'author',
        onDelete: 'SET NULL', // If user is deleted, discussion's author is set to null
      });
      Discussion.belongsTo(models.Discussion, {
        foreignKey: 'parent_id',
        as: 'parentThread',
        onDelete: 'CASCADE', // If parent thread is deleted, replies are also deleted
      });
      Discussion.hasMany(models.Discussion, {
        foreignKey: 'parent_id',
        as: 'replies',
      });
      Discussion.belongsTo(models.Document, {
        foreignKey: 'document_id',
        as: 'relatedDocument',
        onDelete: 'SET NULL', // If document is deleted, link is removed
      });
    }
  }
  Discussion.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: true // Nullable for replies
    },
    content: {
      type: DataTypes.TEXT,
      allowNull: false
    },
    user_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'users',
        key: 'id'
      }
    },
    parent_id: {
      type: DataTypes.INTEGER,
      allowNull: true, // Null for main threads
      references: {
        model: 'discussions', // Self-reference
        key: 'id'
      }
    },
    document_id: {
      type: DataTypes.INTEGER,
      allowNull: true, // Null if not linked to a document
      references: {
        model: 'documents',
        key: 'id'
      }
    }
  }, {
    sequelize,
    modelName: 'Discussion',
    tableName: 'discussions',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Discussion;
};

================
File: models/document.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Document extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Document.belongsTo(models.User, {
        foreignKey: 'uploaded_by',
        as: 'uploader',
        onDelete: 'SET NULL', // If user is deleted, document's uploader is set to null
      });
      // If discussions can be linked to documents
      Document.hasMany(models.Discussion, {
        foreignKey: 'document_id',
        as: 'relatedDiscussions'
      });
    }
  }
  Document.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false
    },
    description: {
      type: DataTypes.TEXT
    },
    file_name: { // Stored unique name
      type: DataTypes.STRING,
      allowNull: false
    },
    file_path: { // Server path
      type: DataTypes.STRING,
      allowNull: false
    },
    original_file_name: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    uploaded_by: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if uploader user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    },
    approved: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    is_public: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    }
  }, {
    sequelize,
    modelName: 'Document',
    tableName: 'documents',
    timestamps: true,
    createdAt: 'uploaded_at', // Map createdAt to uploaded_at
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Document;
};

================
File: models/event.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class Event extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Event.belongsTo(models.User, {
        foreignKey: 'created_by',
        as: 'creator',
        onDelete: 'SET NULL', // If user is deleted, event's creator is set to null
      });
    }
  }
  Event.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false
    },
    description: {
      type: DataTypes.TEXT
    },
    start_date: {
      type: DataTypes.DATE,
      allowNull: false
    },
    end_date: {
      type: DataTypes.DATE,
      allowNull: false
    },
    location: {
      type: DataTypes.STRING,
      allowNull: false
    },
    created_by: {
      type: DataTypes.INTEGER,
      allowNull: true, // Can be null if creator user is deleted
      references: {
        model: 'users',
        key: 'id'
      }
    }
  }, {
    sequelize,
    modelName: 'Event',
    tableName: 'events',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at' // Or false if not needed
  });
  return Event;
};

================
File: models/index.js
================
'use strict';

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../config/config.json')[env];
const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(config.database, config.username, config.password, config);
}

fs
  .readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 &&
      file !== basename &&
      file.slice(-3) === '.js' &&
      file.indexOf('.test.js') === -1
    );
  })
  .forEach(file => {
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;

================
File: models/user.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class User extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      User.hasMany(models.Event, { foreignKey: 'created_by', as: 'events' });
      User.hasMany(models.Document, { foreignKey: 'uploaded_by', as: 'documents' });
      User.hasMany(models.Discussion, { foreignKey: 'user_id', as: 'discussions' });
      User.hasMany(models.Announcement, { foreignKey: 'created_by', as: 'announcements' });
      User.hasMany(models.AuditLog, { foreignKey: 'admin_id', as: 'auditLogs' });
      User.hasMany(models.VerificationToken, { foreignKey: 'user_id', as: 'verificationTokens' });
    }
  }
  User.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false
    },
    role: {
      type: DataTypes.STRING,
      allowNull: false,
      defaultValue: 'member'
    },
    status: {
      type: DataTypes.STRING,
      allowNull: false,
      defaultValue: 'pending'
    },
    email_verified: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    is_system_user: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    }
  }, {
    sequelize,
    modelName: 'User',
    tableName: 'users', // Explicitly define table name
    timestamps: true, // Enables createdAt and updatedAt
    createdAt: 'created_at', // Map createdAt to created_at
    updatedAt: 'updated_at' // Map updatedAt to updated_at (if needed, or set to false)
  });
  return User;
};

================
File: models/verificationToken.model.js
================
'use strict';
const {
  Model
} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class VerificationToken extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      VerificationToken.belongsTo(models.User, {
        foreignKey: 'user_id',
        as: 'user',
        onDelete: 'CASCADE', // If a user is deleted, their tokens are also deleted
      });
    }
  }
  VerificationToken.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    user_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'users', // Name of the target table
        key: 'id'
      }
    },
    token: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    type: {
      type: DataTypes.STRING, // e.g., 'email_verification', 'password_reset'
      allowNull: false
    },
    expires_at: {
      type: DataTypes.DATE,
      allowNull: false
    }
  }, {
    sequelize,
    modelName: 'VerificationToken',
    tableName: 'verification_tokens',
    timestamps: true, // Enables createdAt and updatedAt
    createdAt: 'created_at', // Map createdAt to created_at
    updatedAt: false // No updatedAt for verification tokens
  });
  return VerificationToken;
};

================
File: seeders/20250531214351-initial-admin-user.js
================
'use strict';
const bcrypt = require('bcrypt');

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    const adminEmail = process.env.ADMIN_EMAIL || 'admin@example.com';
    const adminPassword = process.env.ADMIN_PASSWORD || 'password123'; // Fallback for local dev if not set

    if (!process.env.ADMIN_EMAIL || !process.env.ADMIN_PASSWORD) {
      console.warn('ADMIN_EMAIL or ADMIN_PASSWORD environment variables not set. Using default credentials for seeder.');
    }

    const hashedPassword = await bcrypt.hash(adminPassword, 10);

    const existingAdmin = await queryInterface.rawSelect('users', {
      where: { email: adminEmail },
    }, ['id']);

    if (!existingAdmin) {
      await queryInterface.bulkInsert('users', [{
        name: 'System Administrator',
        email: adminEmail,
        password: hashedPassword,
        role: 'admin',
        status: 'active',
        email_verified: true, // Admin email is considered verified
        is_system_user: true,
        created_at: new Date(),
        updated_at: new Date()
      }], {});
    } else {
      console.log(`Admin user with email ${adminEmail} already exists. Skipping admin user seed.`);
    }
  },

  async down (queryInterface, Sequelize) {
    const adminEmail = process.env.ADMIN_EMAIL || 'admin@example.com';
    await queryInterface.bulkDelete('users', { email: adminEmail }, {});
  }
};

================
File: seeders/20250531214406-initial-site-config.js
================
'use strict';

/** @type {import('sequelize-cli').Migration} */
module.exports = {
  async up (queryInterface, Sequelize) {
    const configs = [
      { key: 'hoa_name', value: process.env.DEFAULT_HOA_NAME || 'Sanderson Creek HOA' },
      { key: 'hoa_description', value: process.env.DEFAULT_HOA_DESCRIPTION || 'Sanderson Creek HOA Community Management System' },
      { key: 'hoa_logo', value: process.env.DEFAULT_HOA_LOGO || '/images/logo.png' }
    ];

    for (const config of configs) {
      const existingConfig = await queryInterface.rawSelect('config', {
        where: { key: config.key },
      }, ['key']);

      if (!existingConfig) {
        await queryInterface.bulkInsert('config', [config], {});
      } else {
        // Optionally update if it exists, or just skip
        console.log(`Config key ${config.key} already exists. Skipping config seed for this key.`);
        // await queryInterface.bulkUpdate('config', { value: config.value }, { key: config.key });
      }
    }
  },

  async down (queryInterface, Sequelize) {
    const configKeys = ['hoa_name', 'hoa_description', 'hoa_logo'];
    await queryInterface.bulkDelete('config', { key: { [Sequelize.Op.in]: configKeys } }, {});
  }
};

================
File: src/controllers/admin.user.controller.js
================
const userService = require('../services/user.service');
const { updateUserStatusSchema, updateUserRoleSchema, changePasswordSchema } = require('../validators/admin.user.validator');

/**
 * Handles listing all non-system users for admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function listUsers(req, res, next) {
  try {
    const { limit, offset } = req.query; // For pagination
    const result = await userService.listNonSystemUsers({ limit, offset });
    return res.status(200).json(result);
  } catch (err) {
    next(err);
  }
}

/**
 * Handles retrieving a specific non-system user by ID for admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function getUserById(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const user = await userService.getNonSystemUserById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found or is a system user.' });
    }
    return res.status(200).json(user);
  } catch (err) {
    next(err);
  }
}

/**
 * Handles updating a user's status by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function updateUserStatus(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const { error, value } = updateUserStatusSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    const updatedUser = await userService.updateUserStatus(userId, value.status, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json(updatedUser);

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles updating a user's role by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function updateUserRole(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const { error, value } = updateUserRoleSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    const updatedUser = await userService.updateUserRole(userId, value.role, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json(updatedUser);

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles deleting a user by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function deleteUser(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    await userService.deleteUser(userId, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json({ message: 'User and associated data deleted successfully.' });
    // Or return res.status(204).send(); for No Content response

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles changing a user's password by admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function changeUserPasswordByAdmin(req, res, next) {
  try {
    const userId = parseInt(req.params.userId, 10);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID format.' });
    }

    const { error, value } = changePasswordSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    await userService.changeUserPasswordByAdmin(userId, value.newPassword, req.user.id);
    // Audit logging will be handled by the service or a dedicated audit middleware/service later
    return res.status(200).json({ message: 'User password changed successfully.' });

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

module.exports = {
  listUsers,
  getUserById,
  updateUserStatus,
  updateUserRole,
  deleteUser,
  changeUserPasswordByAdmin,
};

================
File: src/controllers/announcement.controller.js
================
const announcementService = require('../services/announcement.service.js');

/**
 * Handles the creation of a new announcement.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function createAnnouncement(req, res, next) {
  try {
    const announcementData = req.body; // Contains title, content, expiresAt (optional)
    const userId = req.user.id; // Assuming auth middleware sets req.user

    const newAnnouncement = await announcementService.createAnnouncement(announcementData, userId);

    res.status(201).json(newAnnouncement);
  } catch (error) {
    next(error); // Pass error to centralized error handler
  }
}

/**
 * Handles listing announcements with pagination, filtering, and sorting.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function listAnnouncements(req, res, next) {
  try {
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const status = req.query.status || 'active';
    const sortBy = req.query.sortBy || 'created_at';
    const sortOrder = req.query.sortOrder || 'DESC';

    if (page <= 0) {
      return res.status(400).json({ message: 'Page must be a positive integer.' });
    }
    if (limit <= 0) {
      return res.status(400).json({ message: 'Limit must be a positive integer.' });
    }

    const allowedSortOrders = ['ASC', 'DESC'];
    if (!allowedSortOrders.includes(sortOrder.toUpperCase())) {
      return res.status(400).json({ message: `sortOrder must be one of: ${allowedSortOrders.join(', ')}` });
    }
    // TODO: Add validation for allowed values of status and sortBy if specified in plan
    // Example: const allowedSortByFields = ['createdAt', 'title', 'expires_at'];
    // if (!allowedSortByFields.includes(sortBy)) {
    //   return res.status(400).json({ message: `sortBy must be one of: ${allowedSortByFields.join(', ')}` });
    // }

    const options = { page, limit, status, sortBy, sortOrder };

    const result = await announcementService.listAnnouncements(options);
    // Ensure the controller correctly uses the key returned by the service.
    // If the service now returns data, the controller should reflect that
    // when constructing the response.
    res.status(200).json({
      data: result.data,
      pagination: {
        totalItems: result.totalItems,
        totalPages: result.totalPages,
        currentPage: result.currentPage,
        limit: result.limit,
      }
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Handles updating an existing announcement.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function updateAnnouncement(req, res, next) {
  try {
    const { id: announcementId } = req.params;
    const updateData = req.body; // Contains optional title, content, expires_at
    const adminUserId = req.user.id; // Assuming auth middleware sets req.user

    // Input validation for req.body is handled by Joi middleware via routes
    // Sanitization for content (if HTML) would be here or in service. Assuming plain text.

    const updatedAnnouncement = await announcementService.updateAnnouncement(announcementId, updateData, adminUserId);
    res.status(200).json(updatedAnnouncement);
  } catch (error) {
    if (error.statusCode === 404) {
      return res.status(404).json({ message: error.message });
    }
    // For other errors, including potential validation errors from service if not caught by Joi
    // or other DB errors.
    // The technical spec mentions 400 for validation errors, but Joi middleware handles that before this controller.
    // If service layer throws a validation error (e.g. invalid date format not caught by Joi),
    // it might not have a statusCode.
    // For simplicity, passing to generic error handler which might result in 500.
    // A more robust error handling might map specific error types to 400 here.
    next(error);
  }
}

/**
 * Handles deleting an announcement.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function deleteAnnouncement(req, res, next) {
  try {
    const { id: announcementId } = req.params;
    const adminUserId = req.user.id; // Assuming auth middleware sets req.user

    await announcementService.deleteAnnouncement(announcementId, adminUserId);
    res.status(204).send(); // No content to send back
  } catch (error) {
    if (error.statusCode === 404) {
      return res.status(404).json({ message: error.message });
    }
    next(error); // Pass to generic error handler
  }
}

module.exports = {
  createAnnouncement,
  listAnnouncements,
  updateAnnouncement,
  deleteAnnouncement,
};

================
File: src/controllers/audit.controller.js
================
'use strict';

const auditService = require('../services/audit.service');

async function getAuditLogsController(req, res, next) {
  try {
    // FIX: Provide default values for page and limit using '||'
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    
    const result = await auditService.getAuditLogs({ page, limit });
    res.status(200).json(result);
  } catch (error) {
    next(error);
  }
}

module.exports = {
  getAuditLogsController,
};

================
File: src/controllers/auth.controller.js
================
const authService = require('../services/auth.service');
const { registerSchema, loginSchema, forgotPasswordSchema, resetPasswordSchema } = require('../validators/auth.validator');

/**
 * Handles user registration.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function register(req, res, next) {
  try {
    // Validate request body
    const { error, value } = registerSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    // Call registration service
    const user = await authService.registerUser(value);

    // Send response
    return res.status(201).json({
      message: 'Registration successful. Your account is pending approval.',
      user // Excludes password as handled by service
    });

  } catch (err) {
    // Handle errors from service (e.g., email conflict) or other unexpected errors
    if (err.statusCode) {
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Pass to a generic error handler if one is set up
    next(err); 
  }
}

/**
 * Handles user login.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function login(req, res, next) {
  try {
    // Validate request body
    const { error, value } = loginSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    // Call login service
    const { token, user } = await authService.loginUser(value);

    // Send response
    return res.status(200).json({
      message: 'Login successful.',
      token,
      user // Excludes password as handled by service
    });

  } catch (err) {
    // Handle errors from service (e.g., invalid credentials, account not approved)
    if (err.statusCode) {
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Pass to a generic error handler
    next(err);
  }
}

/**
 * Handles forgot password request.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function forgotPassword(req, res, next) {
  try {
    const { error, value } = forgotPasswordSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        // error: 'Invalid email format.' // More specific as per requirements
        message: 'Validation failed.',
        errors: error.details.map(d => d.message)
      });
    }

    await authService.requestPasswordReset(value.email);

    return res.status(200).json({
      message: 'Password reset email sent. Please check your inbox.'
    });

  } catch (err) {
    if (err.statusCode) {
      // Specific error messages based on service layer logic
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Default error for invalid email format if not caught by Joi (though Joi should catch it)
    if (err.message.toLowerCase().includes('email')) { // Basic check
        return res.status(400).json({ error: 'Invalid email format.' });
    }
    next(err);
  }
}

/**
 * Handles verification of a password reset token.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function verifyResetToken(req, res, next) {
  try {
    const { token } = req.query;

    if (!token) {
        return res.status(400).json({ error: 'Invalid or expired password reset token.' });
    }

    await authService.verifyPasswordResetToken(token);

    return res.status(200).json({ message: 'Token is valid.' });

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Default error for token issues
    return res.status(400).json({ error: 'Invalid or expired password reset token.' });
    // next(err); // Or pass to generic error handler
  }
}

/**
 * Handles resetting a user's password.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function resetPassword(req, res, next) {
  try {
    const { error, value } = resetPasswordSchema.validate(req.body);
    if (error) {
      // Check for password complexity error specifically
      if (error.details.some(d => d.path.includes('newPassword') && d.type === 'string.pattern.base')) {
        return res.status(400).json({
          error: "Password does not meet complexity requirements. Minimum 8 characters, including uppercase, lowercase, number, and special character."
        });
      }
      // Generic validation error for missing fields or other issues
      return res.status(400).json({
        error: error.details.map(d => d.message).join(', ') || "Token and newPassword are required."
      });
    }

    await authService.resetPassword(value.token, value.newPassword);

    return res.status(200).json({ message: 'Password has been reset successfully.' });

  } catch (err) {
    if (err.statusCode) {
      // Specific error messages from service layer (e.g., invalid token)
      return res.status(err.statusCode).json({ error: err.message });
    }
    // Default error for other issues
    // Log the error for debugging if it's unexpected
    console.error('Unexpected error in resetPassword controller:', err);
    return res.status(500).json({ error: 'An unexpected error occurred.' });
    // next(err); // Or pass to generic error handler
  }
}

module.exports = {
  register,
  login,
  forgotPassword,
  verifyResetToken,
  resetPassword,
};

================
File: src/controllers/config.controller.js
================
const configService = require('../services/config.service');
const ApiError = require('../utils/ApiError'); // Assuming ApiError utility for error handling

const getAllConfigsController = async (req, res, next) => {
  try {
    const configs = await configService.getAllConfigs();
    res.status(200).json(configs);
  } catch (error) {
    // Assuming a centralized error handler or ApiError can be caught by it
    next(error instanceof ApiError ? error : new ApiError(500, 'Failed to retrieve configurations'));
  }
};

const updateConfigController = async (req, res, next) => {
  try {
    const { key } = req.params;
    const { value } = req.body;
    const adminUserId = req.user.id; // Assuming verifyToken and isAdmin middlewares populate req.user

    if (!adminUserId) {
        // This check is more for robustness, as isAdmin should ensure req.user.id exists
        return next(new ApiError(403, 'User ID not found, authorization issue.'));
    }

    const updatedConfig = await configService.upsertConfig(key, value, adminUserId);
    res.status(200).json(updatedConfig);
  } catch (error) {
    next(error instanceof ApiError ? error : new ApiError(500, `Failed to update configuration for key: ${req.params.key}`));
  }
};

module.exports = {
  getAllConfigsController,
  updateConfigController,
};

================
File: src/controllers/discussion.controller.js
================
const httpStatus = require('http-status');
const discussionService = require('../services/discussion.service');
const catchAsync = require('../utils/catchAsync'); // Assuming catchAsync utility for error handling

const createThreadController = catchAsync(async (req, res) => {
  const { title, content } = req.body;
  const userId = req.user.id;
  const thread = await discussionService.createThread({ title, content }, userId);
  res.status(httpStatus.CREATED).send(thread);
});

const createReplyController = catchAsync(async (req, res) => {
  const { threadId } = req.params;
  const { content } = req.body;
  const userId = req.user.id;
  const reply = await discussionService.createReply({ content }, threadId, userId);
  res.status(httpStatus.CREATED).send(reply);
});

const listThreadsController = catchAsync(async (req, res) => {
  const { page, limit } = req.query;
  const threads = await discussionService.listThreads({ page, limit });
  res.send(threads);
});

const viewThreadController = catchAsync(async (req, res) => {
  const { threadId } = req.params;
  const thread = await discussionService.viewThread(threadId);
  if (!thread) {
    return res.status(httpStatus.NOT_FOUND).send({ message: 'Thread not found or is not a main thread' });
  }
  res.send(thread);
});

const deleteThreadController = catchAsync(async (req, res) => {
  const { threadId } = req.params;
  const adminUserId = req.user.id;
  await discussionService.deleteThread(threadId, adminUserId);
  res.status(httpStatus.NO_CONTENT).send();
});

const deleteReplyController = catchAsync(async (req, res) => {
  const { replyId } = req.params;
  const adminUserId = req.user.id;
  await discussionService.deleteReply(replyId, adminUserId);
  res.status(httpStatus.NO_CONTENT).send();
});

module.exports = {
  createThreadController,
  createReplyController,
  listThreadsController,
  viewThreadController,
  deleteThreadController,
  deleteReplyController,
};

================
File: src/controllers/document.controller.js
================
const documentService = require('../services/document.service');
const { uploadDocumentSchema } = require('../validators/document.validator');
const multer = require('multer'); // To handle Multer errors specifically

/**
 * Handles document upload by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function uploadDocument(req, res, next) {
  try {
    // File is already handled by multer middleware if this controller is reached
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded or file type not allowed.' });
    }

    // Validate text fields
    const { error, value } = uploadDocumentSchema.validate(req.body);
    if (error) {
      // If validation fails, and a file was uploaded, it's good practice to remove the orphaned file.
      // However, fs.unlink can be complex here due to async nature and error paths.
      // For simplicity, this example doesn't remove orphaned files on validation error.
      // In a production app, consider a cleanup strategy.
      return res.status(400).json({
        message: 'Validation failed for document metadata.',
        errors: error.details.map(d => d.message)
      });
    }

    const documentData = {
      title: value.title,
      description: value.description,
      originalFileName: req.file.originalname, // Available if needed
      storedFileName: req.file.filename,    // Name generated by Multer
      filePath: req.file.path,              // Full path where Multer stored the file
      uploadedBy: req.user.id,              // Assuming req.user is populated by auth middleware
      isPublic: value.is_public,
    };

    const newDocument = await documentService.createDocument(documentData);

    return res.status(201).json({
      message: 'Document uploaded successfully.',
      document: newDocument
    });

  } catch (err) {
    // Handle Multer-specific errors (like file size limit)
    if (err instanceof multer.MulterError) {
      if (err.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({ message: `File too large. Max size is ${process.env.MAX_FILE_SIZE_MB || 10}MB.` });
      }
      return res.status(400).json({ message: `File upload error: ${err.message}` });
    }
    // Handle other errors
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles listing documents for users/admins.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function listDocuments(req, res, next) {
  try {
    const { limit, offset } = req.query;
    // req.user might be undefined if the route is public and token is not provided
    const result = await documentService.listDocuments(req.user, { limit, offset });
    return res.status(200).json(result);
  } catch (err) {
    next(err);
  }
}

/**
 * Handles retrieving a specific document's metadata.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function getDocumentMetadata(req, res, next) {
  try {
    const documentId = parseInt(req.params.documentId, 10);
    if (isNaN(documentId)) {
      return res.status(400).json({ error: 'Invalid document ID format.' });
    }

    const document = await documentService.getDocumentMetadataById(documentId, req.user);
    // The service now throws specific errors, so a !document check is less likely here
    // unless the service is changed to return null for some cases again.
    // For now, we rely on the catch block.
    return res.status(200).json(document);
  } catch (err) {
    if (err.statusCode) {
      // Use 'error' key as requested
      return res.status(err.statusCode).json({ error: err.message });
    }
    next(err); // For unexpected errors
  }
}

/**
 * Handles downloading a specific document.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function downloadDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.documentId, 10);
    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    const document = await documentService.getDocumentForDownload(documentId, req.user);
    
    // The service throws an error if access is denied or document not found.
    // If we reach here, download is permitted.
    
    // Use res.download to trigger file download.
    // The 'file_name' from the DB should be the user-facing filename.
    // The 'file_path' from the DB is the actual path on the server.
    // Ensure file_path is secure and not subject to path traversal.
    // The documentService should ideally return the original filename if stored,
    // or use title as a fallback. For now, using document.file_name (stored unique name)
    // might not be user-friendly. Let's assume document.title is a good fallback.
    // The plan mentions: "assume file_name in DB is the user-facing filename for download."
    // This implies the original filename should be stored, perhaps in a field like `original_file_name`.
    // For now, using the stored `file_name` as the download name.
    
    // IMPORTANT: Ensure `document.file_path` is an absolute path or correctly resolved
    // to prevent security vulnerabilities. The Multer setup stores absolute paths.
    res.download(document.file_path, document.original_file_name, (err) => {
      if (err) {
        // Handle errors that occur after headers have been sent, like network issues
        // or if the file is missing (though getDocumentForDownload should catch this)
        console.error('Error during file download:', err);
        if (!res.headersSent) {
          return res.status(500).json({ message: 'Could not download the file.' });
        }
      }
    });

  } catch (err) {
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles approving a document by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function adminApproveDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.id, 10);
    const adminUserId = req.user.id; // Assuming verifyToken middleware sets req.user

    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    const updatedDocument = await documentService.approveDocumentById(documentId, adminUserId);
    return res.status(200).json(updatedDocument);
  } catch (err) {
    // Pass errors to the error handling middleware
    // Specific error handling (e.g., for not found or permission issues)
    // should ideally be done in the service layer and result in custom error objects
    // that the global error handler can interpret.
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}

/**
 * Handles deleting a document by an admin.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function adminDeleteDocument(req, res, next) {
  try {
    const documentId = parseInt(req.params.id, 10);
    const adminUserId = req.user.id; // Assuming verifyToken middleware sets req.user

    if (isNaN(documentId)) {
      return res.status(400).json({ message: 'Invalid document ID format.' });
    }

    await documentService.deleteDocumentById(documentId, adminUserId);
    return res.status(204).send();
  } catch (err) {
    // Pass errors to the error handling middleware
    if (err.statusCode) {
      return res.status(err.statusCode).json({ message: err.message });
    }
    next(err);
  }
}
module.exports = {
  uploadDocument,
  listDocuments,
  getDocumentMetadata,
  downloadDocument,
  adminApproveDocument,
  adminDeleteDocument,
};

================
File: src/controllers/event.controller.js
================
const eventService = require('../services/event.service');

const listEvents = async (req, res, next) => {
  try {
    // Query parameters are already validated and sanitized by express-validator
    // and will be available in req.query
    const queryParams = req.query;

    const result = await eventService.getAllEvents(queryParams);

    res.status(200).json(result);
  } catch (error) {
    // Log the error for server-side inspection
    console.error('Error in listEvents controller:', error);

    // Check if the error is a known service layer error or a generic one
    if (error.message === 'Error fetching events from database.') {
      // Pass to a generic error handler or return a 500
      // For now, let's assume a generic error handler will catch it
      // or we can send a 500 directly.
      return res.status(500).json({ error: 'Internal Server Error' });
    }
    // For other types of errors, or if you want more specific error handling
    // you can add more checks here.
    
    // Fallback to a generic 500 error if not handled specifically
    // and not already sent by a more specific catch.
    // This next(error) will typically be caught by a global error handler in app.js
    next(error); 
  }
};

const adminUpdateEvent = async (req, res, next) => {
  try {
    const eventId = req.params.id;
    const updateData = req.body;
    const adminUserId = req.user.id; // Assuming JWT middleware adds user to req

    const updatedEvent = await eventService.updateEvent(eventId, updateData, adminUserId);
    res.status(200).json(updatedEvent);
  } catch (error) {
    console.error(`Error in adminUpdateEvent controller for event ${req.params.id}:`, error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({ error: error.message });
    }
    next(error); // Pass to global error handler
  }
};

const adminDeleteEvent = async (req, res, next) => {
  try {
    const eventId = req.params.id;
    const adminUserId = req.user.id; // Assuming JWT middleware adds user to req

    await eventService.deleteEvent(eventId, adminUserId);
    res.status(204).send();
  } catch (error) {
    console.error(`Error in adminDeleteEvent controller for event ${req.params.id}:`, error);
    if (error.statusCode) {
      return res.status(error.statusCode).json({ error: error.message });
    }
    next(error); // Pass to global error handler
  }
};

const createEvent = async (req, res, next) => {
  try {
    const { title, description, event_date, location } = req.body;
    const adminUserId = req.user.id; // Assuming JWT middleware adds user to req

    const eventData = { title, description, event_date, location };
    const newEvent = await eventService.createEvent(eventData, adminUserId);

    res.status(201).json(newEvent);
  } catch (error) {
    console.error('Error in createEvent controller:', error);
    // If the service layer threw an error with a statusCode, use it
    if (error.statusCode) {
      // Construct a more informative error response if service provides details
      const errorResponse = { error: error.message };
      if (error.errors) { // For validation errors from service
        errorResponse.details = error.errors;
      }
      return res.status(error.statusCode).json(errorResponse);
    }
    // Pass to global error handler for unhandled/generic errors
    next(error);
  }
};

module.exports = {
  listEvents,
  adminUpdateEvent,
  adminDeleteEvent,
  createEvent,
};

================
File: src/controllers/user.controller.js
================
const userService = require('../services/user.service');
const { validationResult } = require('express-validator');

/**
 * Controller to get the authenticated user's own profile.
 */
const getOwnProfile = async (req, res, next) => {
    // This function doesn't change, but we add 'next' for consistency
    try {
        const userProfile = await userService.fetchOwnProfile(req.user.id);
        if (!userProfile) {
            return res.status(404).json({ error: 'User profile not found.' });
        }
        res.status(200).json(userProfile);
    } catch (error) {
        next(error);
    }
};

/**
 * Controller to update the authenticated user's own profile.
 */
const updateOwnProfile = async (req, res, next) => {
  try {
    // The validation is already done by the middleware!
    const updatedUserProfile = await userService.modifyOwnProfile(req.user.id, req.body);
    res.status(200).json(updatedUserProfile);
  } catch (error) {
    next(error);
  }
};

/**
 * Controller to change the authenticated user's own password.
 */
const changeOwnPassword = async (req, res, next) => {
  try {
    // The validation is already done! We just call the service.
    const { currentPassword, newPassword } = req.body;
    await userService.updateOwnPassword(req.user.id, currentPassword, newPassword);
    res.status(200).json({ message: 'Password changed successfully.' });
  } catch (error) {
    // The service throws an error with a statusCode, which we pass to the global handler
    next(error);
  }
};

module.exports = {
  getOwnProfile,
  updateOwnProfile,
  changeOwnPassword,
};

================
File: src/middlewares/auth.middleware.js
================
const jwt = require('jsonwebtoken');
const { User } = require('../../models'); // Adjust path if models are not in root/models

/**
 * Middleware to verify JWT token from Authorization header.
 * Attaches user information to req.user if token is valid.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function verifyToken(req, res, next) {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Access token is required.' });
  }

  const token = authHeader.split(' ')[1];

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Optionally, fetch user from DB to ensure they still exist and are active
    // This adds a DB hit but increases security. For this example, we'll trust the token payload.
    // const user = await User.findByPk(decoded.userId);
    // if (!user || user.status !== 'approved') {
    //   return res.status(401).json({ message: 'Invalid token or user not active.' });
    // }

    req.user = {
      id: decoded.userId, // Ensure this matches the payload key (userId or id)
      role: decoded.role,
      // Add other non-sensitive user details from token if needed
    };
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'Token expired.' });
    }
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ error: 'Invalid token.' });
    }
    // For other errors, pass to generic error handler
    console.error('JWT verification error:', error);
    return res.status(403).json({ message: 'Forbidden: Token verification failed.' });
  }
}

/**
 * Middleware factory to authorize users based on roles.
 * @param  {...string} allowedRoles - List of roles allowed to access the route.
 * @returns {function} Express middleware function.
 */
function authorizeRoles(...allowedRoles) {
  return (req, res, next) => {
    if (!req.user || !req.user.role) {
      // This should ideally not happen if verifyToken runs first and sets req.user
      return res.status(403).json({ message: 'Forbidden: User role not available.' });
    }

    const rolesArray = [...allowedRoles];
    if (!rolesArray.includes(req.user.role)) {
      return res.status(403).json({ message: 'Forbidden: You do not have permission to access this resource.' });
    }
    next();
  };
}

/**
 * Middleware to optionally verify JWT token.
 * If a token is provided and valid, req.user is populated.
 * If no token or an invalid token is provided, it proceeds without error, and req.user remains undefined.
 * This is useful for routes that behave differently for guests vs. authenticated users.
 * @param {import('express').Request} req - Express request object.
 * @param {import('express').Response} res - Express response object.
 * @param {import('express').NextFunction} next - Express next middleware function.
 */
async function optionalAuth(req, res, next) {
  const authHeader = req.headers.authorization;

  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.split(' ')[1];
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = {
        id: decoded.userId,
        role: decoded.role,
      };
    } catch (error) {
      // Invalid token, but we don't block the request, just don't set req.user
      console.warn('Optional auth: Invalid token received, proceeding as guest.', error.name);
    }
  }
  next();
}

module.exports = {
  verifyToken,
  authorizeRoles,
  optionalAuth,
};

================
File: src/middlewares/upload.middleware.js
================
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Define allowed MIME types and a max file size
const ALLOWED_MIME_TYPES = [
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // .docx
  'image/jpeg',
  'image/png',
  'image/gif',
];
const MAX_FILE_SIZE_MB = 10;
const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;

// Ensure the upload directory exists
const uploadDir = path.join(__dirname, '../../uploads/documents'); // Relative to this file, goes up to backend/ then uploads/documents
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

// Multer disk storage configuration
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const extension = path.extname(file.originalname);
    cb(null, file.fieldname + '-' + uniqueSuffix + extension);
  }
});

// Multer file filter
const fileFilter = (req, file, cb) => {
  if (ALLOWED_MIME_TYPES.includes(file.mimetype)) {
    cb(null, true); // Accept file
  } else {
    cb(new multer.MulterError('LIMIT_UNEXPECTED_FILE', `File type not allowed. Allowed types: ${ALLOWED_MIME_TYPES.join(', ')}`), false); // Reject file
  }
};

const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: MAX_FILE_SIZE_BYTES // 10 MB limit
  }
});

module.exports = upload;

================
File: src/middlewares/validate.middleware.js
================
const Joi = require('joi');
const ApiError = require('../utils/ApiError'); // Assuming ApiError utility

const validate = (schema) => (req, res, next) => {
  const validSchema = Joi.compile(schema);
  const object = {};
  if (req.method === 'GET' || req.method === 'DELETE') {
    Object.assign(object, req.params, req.query);
  } else { // POST, PUT, PATCH
    Object.assign(object, req.params, req.query, req.body);
  }

  const { value, error } = validSchema.validate(object, {
    abortEarly: false, // return all errors
    allowUnknown: true, // allow properties not defined in schema
    stripUnknown: true, // remove properties not defined in schema
  });

  if (error) {
    const errorMessage = error.details.map((details) => details.message).join(', ');
    return next(new ApiError(400, errorMessage));
  }
  Object.assign(req, value); // Assign validated (and potentially transformed) data back to req
  return next();
};

module.exports = validate;

================
File: src/routes/admin.user.routes.js
================
const express = require('express');
const adminUserController = require('../controllers/admin.user.controller');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware');

const router = express.Router();

// All routes in this file are protected and require admin role
router.use(verifyToken);
router.use(authorizeRoles('admin'));

/**
 * @swagger
 * /api/admin/users:
 *   get:
 *     summary: List all non-system users (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of users to return
 *       - in: query
 *         name: offset
 *         schema:
 *           type: integer
 *           default: 0
 *         description: Number of users to skip for pagination
 *     responses:
 *       200:
 *         description: A list of non-system users.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 count:
 *                   type: integer
 *                   example: 1
 *                 users:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/UserResponse' # Defined in auth.routes.js or a common place
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.get('/', adminUserController.listUsers);

/**
 * @swagger
 * /api/admin/users/{userId}:
 *   get:
 *     summary: Get a specific non-system user by ID (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user to retrieve
 *     responses:
 *       200:
 *         description: Details of the non-system user.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid user ID format
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Invalid user ID format.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       404:
 *         description: User not found or is a system user
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User not found or is a system user.
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.get('/:userId', adminUserController.getUserById);

/**
 * @swagger
 * /api/admin/users/{userId}/status:
 *   put:
 *     summary: Update a user's status (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user whose status is to be updated
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - status
 *             properties:
 *               status:
 *                 type: string
 *                 enum: [approved, pending, rejected]
 *                 example: approved
 *     responses:
 *       200:
 *         description: User status updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid user ID format or validation failed for status
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to update a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot modify system user status.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put('/:userId/status', adminUserController.updateUserStatus);

/**
 * @swagger
 * /api/admin/users/{userId}/role:
 *   put:
 *     summary: Update a user's role (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user whose role is to be updated
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - role
 *             properties:
 *               role:
 *                 type: string
 *                 enum: [admin, member]
 *                 example: admin
 *     responses:
 *       200:
 *         description: User role updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Invalid user ID format or validation failed for role
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to update a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot modify system user role.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put('/:userId/role', adminUserController.updateUserRole);

/**
 * @swagger
 * /api/admin/users/{userId}:
 *   delete:
 *     summary: Delete a non-system user and their associated data (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user to delete
 *     responses:
 *       200:
 *         description: User and associated data deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User and associated data deleted successfully.
 *       204:
 *         description: User and associated data deleted successfully (No Content).
 *       400:
 *         description: Invalid user ID format
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to delete a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot delete system user.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.delete('/:userId', adminUserController.deleteUser);

/**
 * @swagger
 * /api/admin/users/{userId}/password:
 *   put:
 *     summary: Change a user's password (Admin only)
 *     tags: [Admin Users]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user whose password is to be changed
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - newPassword
 *             properties:
 *               newPassword:
 *                 type: string
 *                 format: password
 *                 minLength: 8
 *                 example: newSecurePassword123
 *     responses:
 *       200:
 *         description: User password changed successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User password changed successfully.
 *       400:
 *         description: Invalid user ID format or validation failed for newPassword
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         description: Forbidden (e.g., trying to change password for a system user)
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Cannot change password for a system user.
 *       404:
 *         $ref: '#/components/responses/NotFoundError' # User not found
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put('/:userId/password', adminUserController.changeUserPasswordByAdmin);

module.exports = router;

================
File: src/routes/announcement.routes.js
================
const express = require('express');
const router = express.Router();
const { verifyToken: authenticateToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin'); // Create isAdmin middleware
const { createAnnouncementSchema, updateAnnouncementSchema } = require('../validators/announcement.validator');
const announcementController = require('../controllers/announcement.controller'); // Or import specific function
const validate = require('../middlewares/validate.middleware'); // Import validate middleware

// POST / (will be /api/admin/announcements/ when mounted) - Create a new announcement
router.post(
  '/',
  authenticateToken,
  isAdmin,
  validate(createAnnouncementSchema), // Wrap schema with validate middleware
  announcementController.createAnnouncement // Ensure this matches your controller export
);

// GET / (will be /api/announcements/ when mounted) - List announcements for users
router.get(
  '/',
  authenticateToken, // Assuming authenticated users can list
  announcementController.listAnnouncements
);

module.exports = router;

// PUT /:id - Update an announcement (Admin only)
router.put(
  '/:id',
  authenticateToken,
  isAdmin,
  validate(updateAnnouncementSchema), // Wrap schema with validate middleware
  announcementController.updateAnnouncement
);

// DELETE /:id - Delete an announcement (Admin only)
router.delete(
  '/:id',
  authenticateToken,
  isAdmin,
  announcementController.deleteAnnouncement
);

================
File: src/routes/audit.routes.js
================
'use strict';

const express = require('express');
const auditController = require('../controllers/audit.controller');
const validate = require('../middlewares/validate.middleware');
const { getAuditLogsSchema } = require('../validators/audit.validator');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin');

const router = express.Router();

router.get(
  '/',
  verifyToken,
  isAdmin,
  validate(getAuditLogsSchema),
  auditController.getAuditLogsController
);

module.exports = router;

================
File: src/routes/auth.routes.js
================
const express = require('express');
const authController = require('../controllers/auth.controller');
const { registerSchema, loginSchema, forgotPasswordSchema, resetPasswordSchema } = require('../validators/auth.validator.js');
const validate = require('../middlewares/validate.middleware');

const router = express.Router();

/**
 * @swagger
 * /api/auth/register:
 *   post:
 *     summary: Register a new user
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - email
 *               - password
 *             properties:
 *               name:
 *                 type: string
 *                 example: John Doe
 *               email:
 *                 type: string
 *                 format: email
 *                 example: john.doe@example.com
 *               password:
 *                 type: string
 *                 format: password
 *                 minLength: 8
 *                 example: password123
 *     responses:
 *       201:
 *         description: Registration successful. Account pending approval.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Registration successful. Your account is pending approval.
 *                 user:
 *                   $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Validation failed
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorValidation'
 *       409:
 *         description: Email already registered
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorConflict'
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorServer'
 */
router.post('/register', validate(registerSchema), authController.register);

/**
 * @swagger
 * /api/auth/login:
 *   post:
 *     summary: Log in an existing user
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *               - password
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 example: john.doe@example.com
 *               password:
 *                 type: string
 *                 format: password
 *                 example: password123
 *     responses:
 *       200:
 *         description: Login successful
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Login successful.
 *                 token:
 *                   type: string
 *                   example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 *                 user:
 *                   $ref: '#/components/schemas/UserResponse'
 *       400:
 *         description: Validation failed
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorValidation'
 *       401:
 *         description: Invalid email or password
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorUnauthorized'
 *       403:
 *         description: Account not approved or access denied
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorForbidden'
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorServer'
 */
router.post('/login', validate(loginSchema), authController.login);

/**
 * @swagger
 * /api/auth/forgot-password:
 *   post:
 *     summary: Request a password reset token
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - email
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 example: user@example.com
 *     responses:
 *       200:
 *         description: Password reset email sent.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Password reset email sent. Please check your inbox.
 *       400:
 *         description: Invalid email format or user account not active/eligible.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Invalid email format.
 *       404:
 *         description: Email not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Email not found.
 *       500:
 *         description: Internal server error
 */
router.post('/forgot-password', validate(forgotPasswordSchema), authController.forgotPassword);

/**
 * @swagger
 * /api/auth/verify-reset-token:
 *   get:
 *     summary: Verify a password reset token
 *     tags: [Auth]
 *     parameters:
 *       - in: query
 *         name: token
 *         schema:
 *           type: string
 *         required: true
 *         description: The password reset token.
 *         example: abc123xyz789
 *     responses:
 *       200:
 *         description: Token is valid.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Token is valid.
 *       400:
 *         description: Invalid or expired password reset token.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Invalid or expired password reset token.
 *       500:
 *         description: Internal server error
 */
router.get('/verify-reset-token', authController.verifyResetToken);

/**
 * @swagger
 * /api/auth/reset-password:
 *   post:
 *     summary: Reset user password with a token
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - token
 *               - newPassword
 *             properties:
 *               token:
 *                 type: string
 *                 example: "THE_GENERATED_TOKEN_FROM_EMAIL"
 *                 description: The password reset token received by the user.
 *               newPassword:
 *                 type: string
 *                 format: password
 *                 minLength: 8
 *                 example: "NewSecurePassword123!"
 *                 description: The new password for the user account. Must meet complexity requirements.
 *     responses:
 *       200:
 *         description: Password has been reset successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Password has been reset successfully.
 *       400:
 *         description: Bad Request - Invalid/expired token, password complexity not met, or missing fields.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   examples:
 *                     invalidToken: "Invalid or expired password reset token."
 *                     passwordComplexity: "Password does not meet complexity requirements. Minimum 8 characters, including uppercase, lowercase, number, and special character."
 *                     missingFields: "Token and newPassword are required."
 *       500:
 *         description: Internal server error
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ErrorServer'
 */
router.post('/reset-password', validate(resetPasswordSchema), authController.resetPassword);


// Placeholder for UserResponse schema (to be defined in Swagger setup)
// components:
//   schemas:
//     UserResponse:
//       type: object
//       properties:
//         id:
//           type: integer
//         name:
//           type: string
//         email:
//           type: string
//         role:
//           type: string
//         status:
//           type: string
//         email_verified:
//           type: boolean
//         is_system_user:
//           type: boolean
//         created_at:
//           type: string
//           format: date-time
//         updated_at:
//           type: string
//           format: date-time
//     ErrorValidation:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Validation failed.
//         errors:
//           type: array
//           items:
//             type: string
//           example: ["Name is required."]
//     ErrorConflict:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Email already registered.
//     ErrorUnauthorized:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Invalid email or password.
//     ErrorForbidden:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Account pending approval.
//     ErrorServer:
//       type: object
//       properties:
//         message:
//           type: string
//           example: Internal server error

module.exports = router;

================
File: src/routes/config.routes.js
================
const express = require('express');
const configController = require('../controllers/config.controller');
const validate = require('../middlewares/validate.middleware');
const { updateConfigSchema } = require('../validators/config.validator');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware'); // Assuming auth middlewares
const isAdmin = authorizeRoles('admin');

const router = express.Router();

// GET /api/admin/config - Get all configurations
router.get(
  '/',
  verifyToken,
  isAdmin,
  configController.getAllConfigsController
);

// PUT /api/admin/config/:key - Upsert a configuration key-value
router.put(
  '/:key',
  verifyToken,
  isAdmin,
  validate(updateConfigSchema),
  configController.updateConfigController
);

module.exports = router;

================
File: src/routes/discussion.routes.js
================
const express = require('express');
const discussionController = require('../controllers/discussion.controller');
const validate = require('../middlewares/validate.middleware');
const { createThreadSchema, createReplySchema, listThreadsSchema } = require('../validators/discussion.validator');
const { verifyToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin');

const router = express.Router();

router.post(
  '/',
  verifyToken,
  validate(createThreadSchema),
  discussionController.createThreadController
);

router.post(
  '/:threadId/replies',
  verifyToken,
  validate(createReplySchema),
  discussionController.createReplyController
);

// GET /api/discussions - List all main discussion threads
router.get(
  '/',
  verifyToken,
  validate(listThreadsSchema, 'query'), // Validate query parameters
  discussionController.listThreadsController
);

// GET /api/discussions/:threadId - View a specific thread with its replies
router.get(
  '/:threadId',
  verifyToken,
  discussionController.viewThreadController
);

// DELETE a discussion thread (Admin only)
router.delete(
  '/:threadId',
  verifyToken,
  isAdmin,
  discussionController.deleteThreadController
);

// DELETE a specific reply (Admin only)
router.delete(
  '/replies/:replyId',
  verifyToken,
  isAdmin,
  discussionController.deleteReplyController
);

module.exports = router;

================
File: src/routes/document.routes.js
================
const express = require('express');
const documentController = require('../controllers/document.controller');
const { verifyToken, authorizeRoles, optionalAuth } = require('../middlewares/auth.middleware');
const upload = require('../middlewares/upload.middleware'); // Multer upload middleware
const multer = require('multer'); // Ensure multer is imported for error handling

const router = express.Router();

// --- Admin Document Routes ---

/**
 * @swagger
 * /api/admin/documents: // This path is for admin actions, distinct from public /api/documents
 *   post:
 *     summary: Upload a new document (Admin only)
 *     tags: [Documents Admin]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             required:
 *               - documentFile
 *               - title
 *               - is_public
 *             properties:
 *               documentFile:
 *                 type: string
 *                 format: binary
 *                 description: The document file to upload.
 *               title:
 *                 type: string
 *                 example: Meeting Minutes Q1
 *               description:
 *                 type: string
 *                 example: Detailed minutes from the first quarter HOA meeting.
 *               is_public:
 *                 type: boolean
 *                 example: true
 *     responses:
 *       201:
 *         description: Document uploaded successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 document:
 *                   $ref: '#/components/schemas/DocumentResponse' # To be defined
 *       400:
 *         description: Validation failed, no file uploaded, file type not allowed, or file too large.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.post(
  '/',
  verifyToken,
  authorizeRoles('admin'),
  upload.single('documentFile'), // 'documentFile' is the field name in the form-data
  documentController.uploadDocument
);

// Other admin document routes (approve, delete) will be added here later.

/**
 * @swagger
 * /api/documents/{id}/approve:
 *   put:
 *     summary: Approve a document (Admin only)
 *     tags: [Documents Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the document to approve
 *     responses:
 *       200:
 *         description: Document approved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/DocumentResponse'
 *       400:
 *         description: Invalid document ID format.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       404:
 *         description: Document not found.
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.put(
  '/:id/approve',
  verifyToken,
  authorizeRoles('admin'),
  documentController.adminApproveDocument
);

/**
 * @swagger
 * /api/documents/{id}:
 *   delete:
 *     summary: Delete a document (Admin only)
 *     tags: [Documents Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the document to delete
 *     responses:
 *       204:
 *         description: Document deleted successfully.
 *       400:
 *         description: Invalid document ID format.
 *       401:
 *         $ref: '#/components/responses/UnauthorizedError'
 *       403:
 *         $ref: '#/components/responses/ForbiddenError'
 *       404:
 *         description: Document not found.
 *       500:
 *         $ref: '#/components/responses/InternalServerError'
 */
router.delete(
  '/:id',
  verifyToken,
  authorizeRoles('admin'),
  documentController.adminDeleteDocument
);

router.use((err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_UNEXPECTED_FILE') {
      return res.status(400).json({ message: 'File type not allowed.' });
    }
    // You can handle other multer errors here as well, e.g., file size limit
    if (err.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({ message: 'File is too large.' });
    }
    // For any other multer error.
    return res.status(400).json({ message: err.message });
  }
  // If the error is not a Multer error, pass it to the next (global) error handler.
  next(err);
});

module.exports = router;

================
File: src/routes/event.routes.js
================
const express = require('express');
const router = express.Router();
const { verifyToken: authenticateToken, authorizeRoles } = require('../middlewares/auth.middleware');
const isAdmin = authorizeRoles('admin');
const { createEventSchema, listEventsSchema, adminUpdateEventSchema } = require('../validators/event.validator');
const validate = require('../middlewares/validate.middleware'); // Correct import for validate
const eventController = require('../controllers/event.controller');

// GET / (will be /api/events/ when mounted) - List events
router.get(
  '/',
  authenticateToken,
  validate(listEventsSchema), // Correctly wrap schema
  eventController.listEvents
);

// POST / (will be /api/events/ when mounted) - Create a new event (Admin only)
router.post(
  '/',
  authenticateToken,
  isAdmin,
  validate(createEventSchema), // Correctly wrap schema
  eventController.createEvent
);

// PUT /api/events/:id - Update an existing event (Admin only)
router.put(
  '/:id',
  authenticateToken,
  isAdmin,
  validate(adminUpdateEventSchema), // Correctly wrap schema
  eventController.adminUpdateEvent
);

// DELETE /api/events/:id - Delete an event (Admin only)
router.delete(
  '/:id',
  authenticateToken,
  isAdmin,
  eventController.adminDeleteEvent
);

module.exports = router;

================
File: src/routes/public.document.routes.js
================
const express = require('express');
const documentController = require('../controllers/document.controller');
const { optionalAuth } = require('../middlewares/auth.middleware');

const router = express.Router();

// Middleware to make authentication optional for these routes
router.use(optionalAuth);

// GET /api/documents
router.get('/', documentController.listDocuments);

// GET /api/documents/:documentId
router.get('/:documentId', documentController.getDocumentMetadata);

// GET /api/documents/:documentId/download
router.get('/:documentId/download', documentController.downloadDocument);

module.exports = router;

================
File: src/routes/user.routes.js
================
const express = require('express');
const router = express.Router();
const userController = require('../controllers/user.controller');
const authMiddleware = require('../middlewares/auth.middleware');
const validate = require('../middlewares/validate.middleware'); // Custom validation middleware
const { updateProfileSchema, changePasswordSchema } = require('../validators/user.validator');

// Route to get the authenticated user's own profile
// GET /api/users/me
router.get(
  '/me',
  authMiddleware.verifyToken, // Protects the route, ensures req.user is populated
  userController.getOwnProfile
);

// Route to update the authenticated user's own profile
// PUT /api/users/me
router.put(
  '/me',
  authMiddleware.verifyToken, // Protects the route
  validate(updateProfileSchema),        // Apply validation rules
  userController.updateOwnProfile
);

// Route to change the authenticated user's own password
// PUT /api/users/me/password
router.put(
  '/me/password',
  authMiddleware.verifyToken,    // Protects the route
  validate(changePasswordSchema),
  userController.changeOwnPassword
);

module.exports = router;

================
File: src/services/announcement.service.js
================
const { Announcement, User, Sequelize } = require('../../models'); // Adjust path if models are not in root/models
const Op = Sequelize.Op; // Get Op from the Sequelize class/constructor
const createDOMPurify = require('dompurify');
const { JSDOM } = require('jsdom');
const auditService = require('./audit.service');

const window = new JSDOM('').window;
const DOMPurify = createDOMPurify(window);

/**
 * Creates a new announcement record in the database.
 * @param {object} announcementData - Data for the new announcement.
 * @param {string} announcementData.title - Title of the announcement.
 * @param {string} announcementData.content - Content of the announcement.
 * @param {string} [announcementData.expiresAt] - Optional expiration date in ISO format.
 * @param {number|string} userId - The ID of the admin user creating the announcement.
 * @returns {Promise<object>} The created announcement object.
 * @throws {Error} If there's an error during database interaction.
 */
async function createAnnouncement(announcementData, userId) {
  try {
    const { title, content, expiresAt } = announcementData;

    const sanitizedContent = DOMPurify.sanitize(content);

    const dataToCreate = {
      title,
      content: sanitizedContent,
      created_by: userId,
    };

    if (expiresAt) {
      dataToCreate.expires_at = expiresAt; // Assuming model field is expires_at
    }
    // Note: The announcement.model.js provided does not have an 'expires_at' field.
    // If it's intended to be stored, the model and migration need to be updated.
    // For now, this code includes it conditionally based on the task description.
    // If 'expiresAt' is not a field in the DB, Sequelize will ignore it or error depending on strictness.

    const newAnnouncement = await Announcement.create(dataToCreate);

    try {
      await auditService.logAdminAction(userId, 'announcement_create', { announcementId: newAnnouncement.id, title: newAnnouncement.title });
    } catch (auditError) {
      console.error('Failed to log admin action for announcement_create:', auditError);
    }

    return newAnnouncement.toJSON(); // Return plain JSON object
  } catch (error) {
    // Log the error for server-side debugging if necessary
    // console.error('Error creating announcement:', error);
    throw error; // Re-throw the error to be handled by the controller
  }
}

/**
 * Lists announcements with pagination, filtering, and sorting.
 * @param {object} options - Options for listing announcements.
 * @param {number} [options.page=1] - The current page number.
 * @param {number} [options.limit=10] - The number of items per page.
 * @param {string} [options.status] - Filter by status (e.g., 'active').
 * @param {string} [options.sortBy='createdAt'] - Field to sort by.
 * @param {string} [options.sortOrder='DESC'] - Sort order ('ASC' or 'DESC').
 * @returns {Promise<object>} An object containing the list of announcements and pagination details.
 * @throws {Error} If there's an error during database interaction.
 */
async function listAnnouncements(options) {
  try {
    const {
      page = 1,
      limit = 10,
      status,
      sortBy = 'createdAt', // Default sort field
      sortOrder = 'DESC', // Default sort order
    } = options;

    // Ensure page and limit are positive integers
    const numPage = parseInt(page, 10);
    const numLimit = parseInt(limit, 10);

    if (isNaN(numPage) || numPage < 1) {
      // Consider throwing a specific error type or handling as per project conventions
      throw new Error('Page number must be a positive integer.');
    }
    if (isNaN(numLimit) || numLimit < 1) {
      throw new Error('Limit must be a positive integer.');
    }

    const offset = (numPage - 1) * numLimit;
    const whereClause = {};

    if (status === 'active') {
      whereClause[Op.or] = [
        { expires_at: { [Op.is]: null } },
        { expires_at: { [Op.gt]: new Date() } },
      ];
    }

    // Validate sortOrder
    const validSortOrder = ['ASC', 'DESC'].includes(sortOrder.toUpperCase()) ? sortOrder.toUpperCase() : 'DESC';
    const orderClause = [[sortBy, validSortOrder]];

    const { count, rows } = await Announcement.findAndCountAll({
      where: whereClause,
      limit: numLimit,
      offset,
      order: orderClause,
      include: [{
        model: User,
        as: 'creator', // This alias must match the association in Announcement model
        attributes: ['id', 'name'], // Specify desired user fields
      }],
      distinct: true, // Important for correct count with include and limit
    });

    return {
      data: rows.map(row => row.toJSON()), // Return plain JSON objects
      totalItems: count,
      totalPages: Math.ceil(count / numLimit),
      currentPage: numPage,
      limit: numLimit,
    };
  } catch (error) {
    // Optional: Log error for server-side debugging
    // console.error('Error listing announcements:', error);
    throw error; // Re-throw the error to be handled by the controller/error middleware
  }
}

/**
 * Updates an existing announcement.
 * @param {number|string} announcementId - The ID of the announcement to update.
 * @param {object} updateData - Data to update the announcement with.
 * @param {string} [updateData.title] - New title for the announcement.
 * @param {string} [updateData.content] - New content for the announcement.
 * @param {string|null} [updateData.expires_at] - New expiration date (ISO format) or null to clear.
 * @param {number|string} adminUserId - The ID of the admin user performing the update.
 * @returns {Promise<object>} The updated announcement object.
 * @throws {Error} If announcement not found (statusCode 404) or other database error.
 */
async function updateAnnouncement(announcementId, updateData, adminUserId) {
  try {
    const announcement = await Announcement.findByPk(announcementId);

    if (!announcement) {
      const error = new Error('Announcement not found');
      error.statusCode = 404;
      throw error;
    }

    const updatedFields = [];
    if (updateData.hasOwnProperty('title') && updateData.title !== announcement.title) {
      announcement.title = updateData.title;
      updatedFields.push('title');
    }
    if (updateData.hasOwnProperty('content')) {
      const sanitizedNewContent = DOMPurify.sanitize(updateData.content);
      if (sanitizedNewContent !== announcement.content) {
        announcement.content = sanitizedNewContent;
        updatedFields.push('content');
      }
    }
    // For expires_at, handle explicit null to clear the date
    if (updateData.hasOwnProperty('expires_at') && updateData.expires_at !== announcement.expires_at) {
      // Ensure null is correctly handled if the current value is a date string or vice-versa
      if (updateData.expires_at === null && announcement.expires_at !== null) {
        announcement.expires_at = null;
        updatedFields.push('expires_at');
      } else if (updateData.expires_at !== null && new Date(updateData.expires_at).toISOString() !== (announcement.expires_at ? new Date(announcement.expires_at).toISOString() : null)) {
        announcement.expires_at = updateData.expires_at; // This can be null or a date string
        updatedFields.push('expires_at');
      }
    }

    if (updatedFields.length > 0) {
      await announcement.save();
      // Audit Log
      try {
        await auditService.logAdminAction(adminUserId, 'announcement_update', { announcementId, updatedFields: updatedFields });
      } catch (auditError) {
        console.error('Failed to log admin action for announcement_update:', auditError);
      }
    }

    return announcement.toJSON();
  } catch (error) {
    // console.error('Error updating announcement:', error);
    throw error;
  }
}

/**
 * Deletes an announcement by its ID.
 * @param {number|string} announcementId - The ID of the announcement to delete.
 * @param {number|string} adminUserId - The ID of the admin user performing the deletion.
 * @returns {Promise<boolean>} True if deletion was successful.
 * @throws {Error} If announcement not found (statusCode 404) or other database error.
 */
async function deleteAnnouncement(announcementId, adminUserId) {
  try {
    const announcement = await Announcement.findByPk(announcementId);

    if (!announcement) {
      const error = new Error('Announcement not found');
      error.statusCode = 404;
      throw error;
    }

    await announcement.destroy();
    // Audit Log
    try {
      await auditService.logAdminAction(adminUserId, 'announcement_delete', { announcementId });
    } catch (auditError) {
      console.error('Failed to log admin action for announcement_delete:', auditError);
    }
    return true; // Or return nothing for a 204 No Content response handling in controller
  } catch (error) {
    // console.error('Error deleting announcement:', error);
    throw error;
  }
}

module.exports = {
  createAnnouncement,
  listAnnouncements,
  updateAnnouncement,
  deleteAnnouncement,
};

================
File: src/services/audit.service.js
================
'use strict';

const { AuditLog, User } = require('../../models'); // Adjust path as necessary if models/index.js is elsewhere
const { Op } = require('sequelize');

/**
 * Logs an administrative action to the audit_logs table.
 * @param {number} adminId - The ID of the admin user performing the action.
 * @param {string} action - A string describing the action (e.g., 'user_update', 'document_delete').
 * @param {object|string} [details] - Optional details about the action, can be an object or a pre-formatted string.
 */
async function logAdminAction(adminId, action, details) {
  try {
    let detailsToStore = details;
    if (details && typeof details === 'object') {
      // Assuming the 'details' column in the database is TEXT, we need to stringify.
      // If it's a JSON/JSONB type, stringification might not be needed or handled by Sequelize.
      detailsToStore = JSON.stringify(details);
    }

    await AuditLog.create({
      admin_id: adminId,
      action: action,
      details: detailsToStore,
      // created_at is handled by defaultValue in the model/database
    });
  } catch (error) {
    console.error('Failed to log admin action:', {
      adminId,
      action,
      details,
      error: error.message,
    });
    // Do not let audit logging failure block the main operation.
    // Depending on requirements, you might want to notify an admin or use a more robust logging system here.
  }
}

async function getAuditLogs(options) {
  const offset = (options.page - 1) * options.limit;

  const { count, rows } = await AuditLog.findAndCountAll({
    include: [{
      model: User,
      as: 'adminUser', // Ensure this alias matches the association in AuditLog model
      attributes: ['id', 'name'], // Select only needed user fields
    }],
    order: [['created_at', 'DESC']],
    limit: options.limit,
    offset: offset,
  });

  const formattedLogs = rows.map(log => {
    let parsedDetails = log.details;
    if (typeof log.details === 'string') {
      try {
        parsedDetails = JSON.parse(log.details);
      } catch (e) {
        // Keep as string if not valid JSON, or handle error
        // console.error('Failed to parse audit log details:', e);
      }
    }
    return {
      id: log.id,
      admin_name: log.adminUser ? log.adminUser.name : 'N/A',
      action: log.action,
      details: parsedDetails,
      created_at: log.created_at,
    };
  });

  const totalPages = Math.ceil(count / options.limit);

  return {
    data: formattedLogs,
    pagination: {
      totalItems: count,
      totalPages,
      currentPage: options.page,
      limit: options.limit,
    },
  };
}

module.exports = {
  logAdminAction,
  getAuditLogs,
};

================
File: src/services/auth.service.js
================
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { User, VerificationToken } = require('../../models'); // Adjust path as necessary if models are not in root/models
const { v4: uuidv4 } = require('uuid');
const crypto = require('crypto'); // For a more secure plain token, though UUIDv4 is generally good.

/**
 * Registers a new user.
 * @param {object} userData - User data including name, email, and password.
 * @returns {Promise<object>} The created user object or throws an error.
 */
async function registerUser(userData) {
  const { name, email, password } = userData;

  // Check if email already exists
  const existingUser = await User.findOne({ where: { email } });
  if (existingUser) {
    const error = new Error('Email already registered.');
    error.statusCode = 409; // Conflict
    throw error;
  }

  // Hash password
  const hashedPassword = await bcrypt.hash(password, 10); // Salt rounds: 10

  // Create user
  // role defaults to 'member' and status to 'pending' as per model definition
  const newUser = await User.create({
    name,
    email,
    password: hashedPassword,
    // email_verified and is_system_user will use their default values from the model
  });

  // Exclude password from the returned user object
  const userJson = newUser.toJSON();
  delete userJson.password;
  return userJson;
}

/**
 * Logs in an existing user.
 * @param {object} loginData - User login data including email and password.
 * @returns {Promise<object>} An object containing the JWT and user details (excluding password).
 * @throws {Error} If authentication fails or account is not approved.
 */
async function loginUser(loginData) {
  const { email, password } = loginData;

  const user = await User.findOne({ where: { email } });
  if (!user) {
    const error = new Error('Invalid email or password.');
    error.statusCode = 401; // Unauthorized
    throw error;
  }

  const isPasswordValid = await bcrypt.compare(password, user.password);
  if (!isPasswordValid) {
    const error = new Error('Invalid email or password.');
    error.statusCode = 401; // Unauthorized
    throw error;
  }

  if (user.status !== 'approved') {
    let message = 'Account access denied.';
    if (user.status === 'pending') {
      message = 'Account pending approval.';
    } else if (user.status === 'rejected') {
      message = 'Your account has been rejected.';
    }
    const error = new Error(message);
    error.statusCode = 403; // Forbidden
    throw error;
  }

  // Generate JWT
  const tokenPayload = {
    userId: user.id,
    role: user.role,
  };

  const token = jwt.sign(tokenPayload, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || '1h', // Default to 1 hour
  });

  // Exclude password from the returned user object
  const userJson = user.toJSON();
  delete userJson.password;

  return {
    token,
    user: userJson,
  };
}

/**
 * Requests a password reset token for a user.
 * @param {string} email - The user's email address.
 * @returns {Promise<void>}
 * @throws {Error} If email is not found, user is not active, or other issues occur.
 */
async function requestPasswordReset(email) {
  const user = await User.findOne({ where: { email } });

  if (!user) {
    const error = new Error('Email not found.');
    error.statusCode = 404;
    throw error;
  }

  if (user.status !== 'approved') {
    const error = new Error('User account is not active or eligible for password reset.');
    error.statusCode = 400;
    throw error;
  }

  // Generate a unique token
  const plainToken = uuidv4(); // Or crypto.randomBytes(32).toString('hex');
  const hashedToken = await bcrypt.hash(plainToken, 10);

  // Set token expiry (e.g., 1 hour from now)
  const expiresAt = new Date();
  expiresAt.setHours(expiresAt.getHours() + 1);

  // Store the verification token
  await VerificationToken.create({
    userId: user.id,
    token: hashedToken,
    type: 'password_reset',
    expiresAt,
  });

  // Prepare email content (log instead of sending)
  const resetLink = `https://your-frontend-domain.com/reset-password?token=${plainToken}`;
  const emailContent = {
    to: user.email,
    subject: 'Password Reset Request',
    body: `
      <p>Hello ${user.name},</p>
      <p>You requested a password reset. Please click the link below to reset your password:</p>
      <p><a href="${resetLink}">${resetLink}</a></p>
      <p>This link will expire in 1 hour.</p>
      <p>If you did not request a password reset, please ignore this email.</p>
    `,
  };

  console.log('--- Password Reset Email ---');
  console.log(`Recipient: ${emailContent.to}`);
  console.log(`Subject: ${emailContent.subject}`);
  console.log(`Body: ${emailContent.body}`);
  console.log('-----------------------------');
}

/**
 * Verifies a password reset token.
 * @param {string} token - The password reset token from the query parameter.
 * @returns {Promise<boolean>} True if the token is valid.
 * @throws {Error} If the token is invalid, expired, or not found.
 */
async function verifyPasswordResetToken(token) {
  if (!token) {
    const error = new Error('Invalid or expired password reset token.');
    error.statusCode = 400; // Bad Request
    throw error;
  }

  // Find all non-expired password_reset tokens
  const potentialTokens = await VerificationToken.findAll({
    where: {
      type: 'password_reset',
      expiresAt: {
        [require('sequelize').Op.gt]: new Date(), // Check if expiresAt is greater than current time
      },
    },
    include: [{ model: User, attributes: ['id', 'email'] }], // Optional: include user for context
  });

  let isValidToken = false;
  let matchedUser = null;

  for (const vt of potentialTokens) {
    const isMatch = await bcrypt.compare(token, vt.token);
    if (isMatch) {
      isValidToken = true;
      matchedUser = vt.User; // Store user if needed for further steps (e.g. actual reset)
      // Optionally, delete the token after successful verification to prevent reuse
      // await vt.destroy();
      break;
    }
  }

  if (!isValidToken) {
    const error = new Error('Invalid or expired password reset token.');
    // Determine if 404 (not found) or 400 (bad request, e.g. expired)
    // For simplicity, using 400 for all invalid/expired cases here.
    error.statusCode = 400;
    throw error;
  }

  // If you need to return user details or a specific message:
  // return { message: "Token is valid.", userId: matchedUser.id };
  return true; // Or simply return true/false
}

/**
 * Resets a user's password using a valid token.
 * @param {string} token - The password reset token.
 * @param {string} newPassword - The new password.
 * @returns {Promise<void>}
 * @throws {Error} If token is invalid, password complexity fails, or other issues.
 */
async function resetPassword(token, newPassword) {
  if (!token || !newPassword) {
    const error = new Error('Token and newPassword are required.');
    error.statusCode = 400;
    throw error;
  }

  // Password complexity is handled by Joi validator, but can be double-checked here if desired.
  // For this implementation, we assume Joi validation has passed if this function is reached.

  // Find all non-expired password_reset tokens
  const potentialTokens = await VerificationToken.findAll({
    where: {
      type: 'password_reset',
      expiresAt: {
        [require('sequelize').Op.gt]: new Date(),
      },
    },
  });

  let validVerificationToken = null;
  for (const vt of potentialTokens) {
    const isMatch = await bcrypt.compare(token, vt.token);
    if (isMatch) {
      validVerificationToken = vt;
      break;
    }
  }

  if (!validVerificationToken) {
    const error = new Error('Invalid or expired password reset token.');
    error.statusCode = 400;
    throw error;
  }

  const user = await User.findByPk(validVerificationToken.userId);
  if (!user) {
    // This case should ideally not happen if token integrity is maintained
    const error = new Error('User associated with token not found.');
    error.statusCode = 500; // Internal server error, as this indicates data inconsistency
    throw error;
  }

  // Hash the new password
  const hashedPassword = await bcrypt.hash(newPassword, 10);

  // Update user's password
  user.password = hashedPassword;
  await user.save();

  // Invalidate/delete the token
  await validVerificationToken.destroy();

  // Log the event (basic console log for now)
  console.log(`Password reset successfully for user ID: ${user.id}`);

  // Optional: Invalidate other active sessions (future enhancement)
}


module.exports = {
  registerUser,
  loginUser,
  requestPasswordReset,
  verifyPasswordResetToken,
  resetPassword,
};

================
File: src/services/config.service.js
================
const { Config } = require('../../models'); // Assuming index.js in models exports Config
const auditService = require('./audit.service');
// const ApiError = require('../utils/ApiError'); // Not strictly needed for this service based on current plan

const getAllConfigs = async () => {
  const configs = await Config.findAll();
  const configObject = {};
  configs.forEach(item => {
    configObject[item.key] = item.value;
  });
  return configObject;
};

const upsertConfig = async (key, value, adminUserId) => {
  const [configItem, created] = await Config.upsert({ key, value });
  // In Sequelize, 'upsert' might not return the instance directly in all dialects or versions.
  // It often returns [instance, created] or just a boolean indicating creation.
  // For simplicity and consistency, we'll return the input key/value.
  // If the actual instance data (like timestamps) is needed, a findOrCreate or separate find would be better.

  try {
    await auditService.logAdminAction(adminUserId, 'config_update', { configKey: key, newValue: value });
  } catch (auditError) {
    console.error('Failed to log admin action for config_update:', auditError);
  }
  
  // Return the data that was upserted, as the direct return from upsert can vary.
  return { key, value };
};

module.exports = {
  getAllConfigs,
  upsertConfig,
};

================
File: src/services/discussion.service.js
================
const { Discussion, User, sequelize } = require('../../models'); // Assuming User model is in the same directory
const { Op, fn, col } = require('sequelize');
const createDOMPurify = require('dompurify');
const { JSDOM } = require('jsdom');
const ApiError = require('../utils/ApiError'); // Assuming ApiError utility
const auditService = require('./audit.service');

const window = new JSDOM('').window;
const DOMPurify = createDOMPurify(window);

/**
 * Create a discussion thread
 * @param {Object} threadData
 * @param {ObjectId} userId
 * @returns {Promise<Discussion>}
 */
const createThread = async (threadData, userId) => {
  const sanitizedContent = DOMPurify.sanitize(threadData.content);
  const thread = await Discussion.create({
    title: threadData.title,
    content: sanitizedContent,
    user_id: userId,
    parent_id: null,
  });
  return thread;
};

/**
 * Create a reply to a discussion thread
 * @param {Object} replyData
 * @param {ObjectId} threadId
 * @param {ObjectId} userId
 * @returns {Promise<Discussion>}
 */
const createReply = async (replyData, threadId, userId) => {
  const sanitizedContent = DOMPurify.sanitize(replyData.content);

  const parentThread = await Discussion.findOne({ where: { id: threadId, parent_id: null } });
  if (!parentThread) {
    throw new ApiError(404, 'Parent thread not found or is not a main thread');
  }

  const reply = await Discussion.create({
    content: sanitizedContent,
    user_id: userId,
    parent_id: threadId,
    title: null, // Replies don't have titles
  });
  return reply;
};

/**
 * List all main discussion threads with author and reply count
 * @param {Object} options - Query options
 * @param {number} [options.page=1] - Current page
 * @param {number} [options.limit=10] - Maximum number of results per page
 * @returns {Promise<Object>} - Paginated list of thread objects
 */
const listThreads = async (options) => {
  const page = parseInt(options.page, 10) || 1;
  const limit = parseInt(options.limit, 10) || 10;
  const offset = (page - 1) * limit;

  const { count, rows } = await Discussion.findAndCountAll({
    where: { parent_id: null },
    order: [['created_at', 'DESC']],
    limit,
    offset,
    include: [
      {
        model: User,
        as: 'author',
        attributes: ['id', 'name'],
      },
    ],
    attributes: {
      include: [
        [
          sequelize.literal(`(
            SELECT COUNT(*)
            FROM discussions AS reply
            WHERE
              reply.parent_id = Discussion.id
          )`),
          'reply_count'
        ]
      ]
    },
    distinct: true, // Important for correct count with includes
  });

  const threads = rows.map(thread => ({
    id: thread.id,
    title: thread.title,
    content: thread.content, // Consider snippet vs full content based on requirements
    created_at: thread.created_at,
    author: thread.author ? { id: thread.author.id, name: thread.author.name } : null,
    reply_count: parseInt(thread.get('reply_count'), 10) || 0,
  }));

  return {
    totalItems: count,
    totalPages: Math.ceil(count / limit),
    currentPage: page,
    threads,
  };
};

/**
 * View a specific thread along with all its replies
 * @param {ObjectId} threadId
 * @returns {Promise<Object|null>} - Thread object with replies, or null if not found
 */
const viewThread = async (threadId) => {
  const mainThread = await Discussion.findOne({
    where: { id: threadId, parent_id: null },
    include: [
      {
        model: User,
        as: 'author',
        attributes: ['id', 'name'],
      },
    ],
  });

  if (!mainThread) {
    return null; // Or throw ApiError(httpStatus.NOT_FOUND, 'Thread not found or is not a main thread');
  }

  const replies = await Discussion.findAll({
    where: { parent_id: threadId },
    order: [['created_at', 'ASC']],
    include: [
      {
        model: User,
        as: 'author',
        attributes: ['id', 'name'],
      },
    ],
  });

  return {
    mainThread: {
      id: mainThread.id,
      title: mainThread.title,
      content: mainThread.content,
      created_at: mainThread.created_at,
      author: mainThread.author ? { id: mainThread.author.id, name: mainThread.author.name } : null,
    },
    replies: replies.map(reply => ({
      id: reply.id,
      content: reply.content,
      created_at: reply.created_at,
      author: reply.author ? { id: reply.author.id, name: reply.author.name } : null,
    })),
  };
};


/**
 * Delete a discussion thread
 * @param {ObjectId} threadId
 * @param {ObjectId} adminUserId
 * @returns {Promise<void>}
 */
const deleteThread = async (threadId, adminUserId) => {
  const thread = await Discussion.findOne({ where: { id: threadId, parent_id: null } });
  if (!thread) {
    throw new ApiError(404, 'Discussion thread not found or is not a main thread');
  }
  const threadTitle = thread.title; // Store title before destroying
  await thread.destroy();
  // eslint-disable-next-line no-console
  // console.log(`Audit: Admin User ID ${adminUserId} deleted discussion thread ID ${threadId} titled '${thread.title}'`);
  try {
    await auditService.logAdminAction(adminUserId, 'discussion_thread_delete', { threadId, title: threadTitle });
  } catch (auditError) {
    console.error('Failed to log admin action for discussion_thread_delete:', auditError);
  }
};

/**
 * Delete a discussion reply
 * @param {ObjectId} replyId
 * @param {ObjectId} adminUserId
 * @returns {Promise<void>}
 */
const deleteReply = async (replyId, adminUserId) => {
  const reply = await Discussion.findOne({ where: { id: replyId, parent_id: { [Op.ne]: null } } });
  if (!reply) {
    throw new ApiError(404, 'Discussion reply not found or is not a reply');
  }
  await reply.destroy();
  // eslint-disable-next-line no-console
  // console.log(`Audit: Admin User ID ${adminUserId} deleted discussion reply ID ${replyId}`);
  try {
    await auditService.logAdminAction(adminUserId, 'discussion_reply_delete', { replyId });
  } catch (auditError) {
    console.error('Failed to log admin action for discussion_reply_delete:', auditError);
  }
};

module.exports = {
  createThread,
  createReply,
  listThreads,
  viewThread,
  deleteThread,
  deleteReply,
};

================
File: src/services/document.service.js
================
const { Document, User, sequelize } = require('../../models'); // Adjust path if models are not in root/models
const { Op } = require('sequelize');
const fs = require('fs').promises;
const path = require('path');
const ApiError = require('../utils/ApiError');
const auditService = require('./audit.service');

/**
 * Creates a new document record in the database.
 * @param {object} documentData - Data for the new document.
 * @param {string} documentData.title - Title of the document.
 * @param {string} [documentData.description] - Optional description.
 * @param {string} documentData.originalFileName - The original name of the uploaded file (from Multer's `req.file.originalname`).
 * @param {string} documentData.storedFileName - The unique name of the file as stored on the server (from Multer's `req.file.filename`).
 * @param {string} documentData.filePath - The path to the file on the server.
 * @param {number} documentData.uploadedBy - The ID of the user who uploaded the document.
 * @param {boolean} documentData.isPublic - Whether the document is public.
 * @returns {Promise<object>} The created document object.
 */
async function createDocument(documentData) {
  const {
    title,
    description,
    originalFileName,
    storedFileName, // This is req.file.filename from Multer
    filePath,       // This is req.file.path from Multer
    uploadedBy,
    isPublic,
  } = documentData;

  // Determine 'approved' status based on 'is_public' as per plan
  const approved = !!isPublic; // Converts boolean isPublic to 0 or 1 if DB expects integer, or true/false

  const newDocument = await Document.create({
    title,
    description: description || null, // Ensure null if empty, or handle in model
    file_name: storedFileName, // This is the unique name for storage
    original_file_name: originalFileName, // Added to store the original filename
    file_path: filePath,       // Full path to the file on server
    uploaded_by: uploadedBy,
    is_public: isPublic,
    approved: approved,
    // uploaded_at will be set by Sequelize's `createdAt`
  });

  try {
    await auditService.logAdminAction(uploadedBy, 'document_upload', { documentId: newDocument.id, originalName: newDocument.original_file_name, uploaderUserId: uploadedBy });
  } catch (auditError) {
    console.error('Failed to log admin action for document_upload:', auditError);
  }

  return newDocument.toJSON(); // Return plain JSON object
}

/**
 * Lists documents based on user authentication and role.
 * @param {object} [user] - Optional user object (from req.user).
 * @param {object} options - Pagination options { limit, offset }.
 * @returns {Promise<object>} An object containing the list of documents and count.
 */
async function listDocuments(user, { limit = 10, offset = 0 }) {
  const whereClause = {};
  const includeClause = [{
    model: User,
    as: 'uploader',
    attributes: ['id', 'name'] // Only include uploader's ID and name
  }];

  if (!user) { // Guest user
    whereClause.is_public = true;
    whereClause.approved = true;
  } else if (user.role === 'admin') {
    // Admin sees all documents
  } else { // Authenticated member
    whereClause.approved = true;
    // Members see all approved documents (public and non-public)
  }

  const { count, rows } = await Document.findAndCountAll({
    where: whereClause,
    include: includeClause,
    limit: parseInt(limit, 10),
    offset: parseInt(offset, 10),
    order: [['uploaded_at', 'DESC']],
    attributes: { exclude: ['uploaded_by'] } // Exclude direct foreign key, use include for uploader info
  });

  return { count, documents: rows };
}

/**
 * Retrieves a specific document's metadata by ID, respecting access permissions.
 * @param {number} documentId - The ID of the document.
 * @param {object} [user] - Optional user object (from req.user).
 * @returns {Promise<object|null>} The document metadata or null if not found/not allowed.
 */
async function getDocumentMetadataById(documentId, user) {
  const document = await Document.findByPk(documentId, {
    include: [{
      model: User,
      as: 'uploader',
      attributes: ['id', 'name']
    }],
    attributes: { exclude: ['uploaded_by'] }
  });

  if (!document) {
    const error = new Error('Document not found.');
    error.statusCode = 404;
    throw error;
  }

  // Access Control
  if (!user) { // Guest
    if (!document.is_public || !document.approved) {
      const error = new Error('Access denied to this document.');
      error.statusCode = 403;
      throw error;
    }
  } else if (user.role !== 'admin') { // Member
    if (!document.approved) {
      const error = new Error('Access denied to this document.');
      error.statusCode = 403;
      throw error;
    }
    // Members can see all approved documents (public or not)
    // If a document is approved, a member can see it.
    // If it's also public, a guest can see it.
    // If it's not public but approved, only members and admins can see it.
    // This logic seems correct.
  }
  // Admin can see everything, no explicit check needed here if previous conditions handle others.

  return document.toJSON();
}

/**
 * Retrieves a document for download, checking permissions.
 * @param {number} documentId - The ID of the document.
 * @param {object} [user] - Optional user object (from req.user).
 * @returns {Promise<object|null>} The document object if download is permitted, otherwise null or throws error.
 * @throws {Error} If access is denied with a specific status code.
 */
async function getDocumentForDownload(documentId, user) {
  const document = await Document.findByPk(documentId);

  if (!document) {
    const error = new Error('Document not found.');
    error.statusCode = 404;
    throw error;
  }

  // Access Control based on download_document.php logic (User Story 9)
  // 1. If document approved != 1 AND user is not 'admin': Deny access (403).
  // 2. If document is_public != 1 AND user is not authenticated: Deny access (401/403).
  // 3. Otherwise, allow download.

  if (!document.approved && (!user || user.role !== 'admin')) {
    const error = new Error('Access Denied: Document not approved for download.');
    error.statusCode = 403;
    throw error;
  }

  if (!document.is_public && !user) {
    const error = new Error('Access Denied: Authentication required to download this document.');
    error.statusCode = 401; // Or 403, 401 is more specific for "auth required"
    throw error;
  }

  // If all checks pass, return the document object (contains file_path, file_name)
  return document.toJSON();
}


/**
 * Approves a document by its ID.
 * @param {number} documentId - The ID of the document to approve.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<object>} The updated document object.
 * @throws {ApiError} If the document is not found.
 */
async function approveDocumentById(documentId, adminUserId) {
  const document = await Document.findByPk(documentId);

  if (!document) {
    throw new ApiError(404, 'Document not found');
  }

  document.approved = true;
  await document.save();

  try {
    await auditService.logAdminAction(adminUserId, 'document_approve', { documentId });
  } catch (auditError) {
    console.error('Failed to log admin action for document_approve:', auditError);
  }

  return document.toJSON();
}

/**
 * Deletes a document by its ID.
 * This includes deleting the physical file if it exists.
 * @param {number} documentId - The ID of the document to delete.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<boolean>} True if deletion was successful.
 * @throws {ApiError} If the document is not found.
 */
async function deleteDocumentById(documentId, adminUserId) {
  const document = await Document.findByPk(documentId);

  if (!document) {
    throw new ApiError(404, 'Document not found');
  }

  if (document.file_path) {
    // document.file_path is expected to be an absolute path from Multer (req.file.path).
    try {
      await fs.unlink(document.file_path);
      console.log(`Successfully deleted physical file: ${document.file_path}`);
    } catch (err) {
      console.error(`Error deleting physical file ${document.file_path}: `, err);
      // Log error but proceed with DB deletion as per requirements.
    }
  }

  await document.destroy();
  try {
    await auditService.logAdminAction(adminUserId, 'document_delete', { documentId });
  } catch (auditError) {
    console.error('Failed to log admin action for document_delete:', auditError);
  }

  return true;
}


module.exports = {
  createDocument,
  listDocuments,
  getDocumentMetadataById,
  getDocumentForDownload,
  approveDocumentById,
  deleteDocumentById,
};

================
File: src/services/event.service.js
================
const { Event, User, sequelize } = require('../../models');
const { Op } = require('sequelize');
const auditService = require('./audit.service');

const getAllEvents = async (queryParams) => {
  const {
    status = 'upcoming', // Default status
    page = 1,
    limit = 10,
    sortBy = 'event_date', // Default sort by event_date (which is start_date in model)
    sortOrder: initialSortOrder, // Will be determined based on sortBy and status
  } = queryParams;

  // Determine default sortOrder based on sortBy and status
  let sortOrder = initialSortOrder;
  if (!sortOrder) {
    if (sortBy === 'event_date') {
      sortOrder = status === 'past' ? 'DESC' : 'ASC';
    } else if (sortBy === 'created_at') {
      sortOrder = 'DESC';
    } else { // title
      sortOrder = 'ASC';
    }
  }

  const offset = (page - 1) * limit;

  const whereClause = {};
  const now = new Date();

  if (status === 'upcoming') {
    whereClause.start_date = { [Op.gt]: now };
  } else if (status === 'past') {
    whereClause.start_date = { [Op.lte]: now };
  }
  
  // Adjust sortBy to match model field name if 'event_date' is used
  const actualSortBy = sortBy === 'event_date' ? 'start_date' : sortBy;

  try {
    const { count, rows } = await Event.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
      ],
      order: [[actualSortBy, sortOrder.toUpperCase()]],
      limit,
      offset,
      distinct: true, // Important for correct count with includes
    });

    const totalItems = count;
    const totalPages = Math.ceil(totalItems / limit);
    const hasNextPage = page < totalPages;
    const hasPrevPage = page > 1;

    // Map to desired response structure, especially event_date
    const formattedEvents = rows.map(event => ({
      id: event.id,
      title: event.title,
      description: event.description,
      event_date: event.start_date, // Map start_date to event_date
      end_date: event.end_date, // Add end_date to the response
      location: event.location,
      created_by: event.creator ? { id: event.creator.id, name: event.creator.name } : null,
      created_at: event.created_at,
      updated_at: event.updated_at,
    }));


    return {
      data: formattedEvents,
      pagination: {
        totalItems,
        totalPages,
        currentPage: parseInt(page, 10),
        limit: parseInt(limit, 10),
        hasNextPage,
        hasPrevPage,
      },
    };
  } catch (error) {
    console.error('Error fetching events:', error);
    throw new Error('Error fetching events from database.');
  }
};

const updateEvent = async (eventId, updateData, adminUserId) => {
  try {
    const event = await Event.findByPk(eventId);
    if (!event) {
      const error = new Error('Event not found');
      error.statusCode = 404;
      throw error;
    }

    // Validate start_date and end_date
    const { start_date, end_date } = updateData;

    if(start_date !== undefined && end_date !== undefined) {
      const validatedStartDate = start_date ? new Date(start_date) : event.start_date;
      const validatedEndDate = end_date ? new Date(end_date) : event.end_date;
      // If both dates are present (either from input or existing event data), validate them
      if (validatedStartDate && validatedEndDate && validatedEndDate <= validatedStartDate) {
        const error = new Error('End date must be after start date.');
        error.statusCode = 400; // Bad Request
        throw error;
      }
    }
    
    // Prepare fields for update, only including those provided in updateData
    const fieldsToUpdate = {};
    if (updateData.title !== undefined) fieldsToUpdate.title = updateData.title;
    if (updateData.description !== undefined) fieldsToUpdate.description = updateData.description;
    if (start_date !== undefined) fieldsToUpdate.start_date = validatedStartDate;
    if (end_date !== undefined) fieldsToUpdate.end_date = validatedEndDate;
    if (updateData.location !== undefined) fieldsToUpdate.location = updateData.location;


    // Only update if there are fields to update
    if (Object.keys(fieldsToUpdate).length > 0) {
        await event.update(fieldsToUpdate);
    }
    
    // Audit Logging
    try {
      await auditService.logAdminAction(adminUserId, 'event_update', { eventId, updatedFields: Object.keys(fieldsToUpdate) });
    } catch (auditError) {
      console.error('Failed to log admin action for event_update:', auditError);
    }

    // Fetch the updated event with creator info to match getAllEvents structure
    const updatedEventWithCreator = await Event.findByPk(eventId, {
      include: [
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
      ],
    });
    
    return {
        id: updatedEventWithCreator.id,
        title: updatedEventWithCreator.title,
        description: updatedEventWithCreator.description,
        event_date: updatedEventWithCreator.start_date, // Map start_date to event_date
        end_date: updatedEventWithCreator.end_date,
        location: updatedEventWithCreator.location,
        created_by: updatedEventWithCreator.creator ? { id: updatedEventWithCreator.creator.id, name: updatedEventWithCreator.creator.name } : null,
        created_at: updatedEventWithCreator.created_at,
        updated_at: updatedEventWithCreator.updated_at,
      };

  } catch (error) {
    console.error(`Error updating event ${eventId}:`, error);
    if (!error.statusCode) { // Default to 500 if no specific status code is set
        error.statusCode = 500;
        error.message = 'Error updating event in database.';
    }
    throw error;
  }
};

const deleteEvent = async (eventId, adminUserId) => {
  try {
    const event = await Event.findByPk(eventId);
    if (!event) {
      const error = new Error('Event not found');
      error.statusCode = 404;
      throw error;
    }

    await event.destroy();

    // Audit Logging
    try {
      await auditService.logAdminAction(adminUserId, 'event_delete', { eventId });
    } catch (auditError) {
      console.error('Failed to log admin action for event_delete:', auditError);
    }

  } catch (error) {
    console.error(`Error deleting event ${eventId}:`, error);
    if (!error.statusCode) { // Default to 500 if no specific status code is set
        error.statusCode = 500;
        error.message = 'Error deleting event from database.';
    }
    throw error;
  }
};


const createEvent = async (eventData, adminUserId) => {
  const { title, description, event_date, location } = eventData;

  try {
    // Assumption: event_date from request maps to start_date.
    // Assumption: end_date is set to start_date as it's NOT NULL in DB but not in US14 request.
    const newEventRecord = await Event.create({
      title,
      description,
      start_date: event_date,
      end_date: event_date, // Setting end_date same as start_date
      location,
      created_by: adminUserId,
    });

    // Audit Logging
    try {
      await auditService.logAdminAction(adminUserId, 'event_create', { eventId: newEventRecord.id, title: newEventRecord.title });
    } catch (auditError) {
      console.error('Failed to log admin action for event_create:', auditError);
    }

    // Fetch the event again to include creator details for a consistent response structure
    const populatedEvent = await Event.findByPk(newEventRecord.id, {
      include: [
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
      ],
    });

    // Format the response to match the User Story and other event service responses
    return {
      id: populatedEvent.id,
      title: populatedEvent.title,
      description: populatedEvent.description,
      event_date: populatedEvent.start_date, // Map start_date back to event_date for response
      end_date: populatedEvent.end_date, // Add end_date to the response
      location: populatedEvent.location,
      created_by: populatedEvent.creator ? { id: populatedEvent.creator.id, name: populatedEvent.creator.name } : null,
      createdAt: populatedEvent.created_at,
      updatedAt: populatedEvent.updated_at,
    };

  } catch (error) {
    console.error(`Error creating event:`, error);
    // Allowing Sequelize validation errors to propagate with their structure,
    // or re-throwing a generic error for other DB issues.
    if (error.name === 'SequelizeValidationError' || error.name === 'SequelizeUniqueConstraintError') {
        const simplifiedErrors = error.errors.map(e => ({ message: e.message, path: e.path }));
        const err = new Error('Validation failed or constraint violation.');
        err.statusCode = 400; // Bad Request
        err.errors = simplifiedErrors;
        throw err;
    }
    
    const serviceError = new Error('Error creating event in database.');
    serviceError.statusCode = error.statusCode || 500;
    throw serviceError;
  }
};

module.exports = {
  getAllEvents,
  updateEvent,
  deleteEvent,
  createEvent,
};

================
File: src/services/user.service.js
================
const fs = require('fs');
const path = require('path');
const { User, Document, sequelize } = require('../../models'); // Adjust path as necessary
const { Op } = require('sequelize');
const bcrypt = require('bcrypt');
const ApiError = require('../utils/ApiError'); // Added for custom error handling
const auditService = require('./audit.service');

/**
 * Selects and returns publicly safe user profile fields.
 * @param {Object} user - The Sequelize user object.
 * @returns {Object} - An object containing safe user profile fields.
 */
const selectUserProfileFields = (user) => {
  if (!user) {
    return null;
  }
  return {
    id: user.id,
    name: user.name,
    email: user.email,
    role: user.role,
    status: user.status,
    created_at: user.created_at,
    updated_at: user.updated_at,
  };
};

/**
 * Fetches the profile of the currently authenticated user.
 * @param {number} userId - The ID of the user.
 * @returns {Promise<Object|null>} - The user profile or null if not found.
 */
const fetchOwnProfile = async (userId) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      return null; // Or throw an error to be caught by the controller
    }
    return selectUserProfileFields(user);
  } catch (error) {
    console.error('Error fetching own profile:', error);
    throw error;
  }
};

/**
 * Modifies the profile of the currently authenticated user.
 * @param {number} userId - The ID of the user.
 * @param {Object} updateData - The data to update (e.g., { name: "New Name" }).
 * @returns {Promise<Object|null>} - The updated user profile or null if user not found.
 */
const modifyOwnProfile = async (userId, updateData) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      return null; // Or throw an error
    }

    // Only allow 'name' to be updated for now
    if (updateData.name !== undefined) {
      // Basic validation: ensure name is not empty if provided
      if (typeof updateData.name !== 'string' || updateData.name.trim() === '') {
        const error = new Error('Name cannot be empty.');
        error.isValidationError = true; // Custom flag for validation errors
        error.field = 'name';
        throw error;
      }
      user.name = updateData.name.trim();
    }

    // Potentially add more updatable fields here in the future,
    // ensuring proper validation for each.
    // For example:
    // if (updateData.bio !== undefined) {
    //   user.bio = updateData.bio;
    // }

    await user.save();
    return selectUserProfileFields(user);
  } catch (error) {
    console.error('Error modifying own profile:', error);
    throw error;
  }
};

/**
 * Updates the password for the currently authenticated user.
 * @param {number} userId - The ID of the user.
 * @param {string} currentPassword - The user's current password.
 * @param {string} newPassword - The new password to set.
 * @returns {Promise<void>}
 * @throws {Error} - Throws error if user not found, current password incorrect, or new password invalid.
 */
const updateOwnPassword = async (userId, currentPassword, newPassword) => {
  try {
    const user = await User.findByPk(userId);
    if (!user) {
      const error = new Error('User not found.');
      error.statusCode = 404; // Or handle as per your app's error strategy
      throw error;
    }

    const isMatch = await bcrypt.compare(currentPassword, user.password);
    if (!isMatch) {
      const error = new Error('Incorrect current password.');
      error.statusCode = 403; // Forbidden
      throw error;
    }

    // Password complexity validation is handled by express-validator,
    // but a service-level check could be added here if desired for extra safety
    // or if the service is used outside of a validated controller context.

    const salt = await bcrypt.genSalt(10);
    user.password = await bcrypt.hash(newPassword, salt);
    await user.save();

  } catch (error) {
    console.error('Error updating own password:', error);
    // Re-throw with a more generic message or specific status code if needed
    if (!error.statusCode) {
        // Default to a server error if not already set
        const serviceError = new Error('Could not update password.');
        serviceError.statusCode = error.isValidationError ? 400 : 500; // Keep 400 for validation
        throw serviceError;
    }
    throw error;
  }
};


/**
 * Lists non-system users with pagination.
 * @param {Object} options - Pagination options.
 * @param {number} [options.limit=10] - Number of users to fetch.
 * @param {number} [options.offset=0] - Number of users to skip.
 * @returns {Promise<Object>} - An object containing 'rows' (users) and 'count' (total non-system users).
 */
const listNonSystemUsers = async ({ limit = 10, offset = 0 }) => {
  try {
    const { count, rows } = await User.findAndCountAll({
      where: {
        is_system_user: false,
      },
      attributes: {
        exclude: ['password'],
        include: ['id', 'name', 'email', 'role', 'status', 'created_at', 'updated_at'],
      },
      limit: parseInt(limit, 10),
      offset: parseInt(offset, 10),
      order: [['created_at', 'DESC']],
    });
    return { rows: rows.map(selectUserProfileFields), count };
  } catch (error) {
    console.error('Error listing non-system users:', error);
    throw error;
  }
};

/**
 * Retrieves a single non-system user by their ID.
 * @param {number} userId - The ID of the user to retrieve.
 * @returns {Promise<Object|null>} - The user object or null if not found or is a system user.
 */
const getNonSystemUserById = async (userId) => {
  try {
    const user = await User.findOne({
      where: {
        id: userId,
        is_system_user: false,
      },
      attributes: {
        exclude: ['password'],
        include: ['id', 'name', 'email', 'role', 'status', 'created_at', 'updated_at'],
      },
    });

    if (!user) {
      return null; // User not found or is a system user
    }

    return selectUserProfileFields(user);
  } catch (error) {
    console.error('Error retrieving non-system user by ID:', error);
    throw error;
  }
};


/**
 * Updates the status of a target user. (Admin operation)
 * @param {number} targetUserId - The ID of the user whose status is to be updated.
 * @param {string} newStatus - The new status to set.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<Object>} - The updated user profile (excluding password).
 * @throws {ApiError} - Throws error if user not found or is a system user.
 */
const updateUserStatus = async (targetUserId, newStatus, adminUserId) => {
  const targetUser = await User.findByPk(targetUserId);
  if (!targetUser) {
    throw new ApiError(404, 'User not found');
  }
  if (targetUser.is_system_user === true) {
    throw new ApiError(403, 'System users cannot be modified.');
  }

  targetUser.status = newStatus;
  await targetUser.save();

  try {
    await auditService.logAdminAction(adminUserId, 'user_status_update', { targetUserId: targetUserId, newStatus: newStatus });
  } catch (auditError) {
    console.error('Failed to log admin action for user_status_update:', auditError);
  }

  return selectUserProfileFields(targetUser.toJSON());
};

/**
 * Updates the role of a target user. (Admin operation)
 * @param {number} targetUserId - The ID of the user whose role is to be updated.
 * @param {string} newRole - The new role to set.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<Object>} - The updated user profile (excluding password).
 * @throws {ApiError} - Throws error if user not found or is a system user.
 */
const updateUserRole = async (targetUserId, newRole, adminUserId) => {
  const targetUser = await User.findByPk(targetUserId);
  if (!targetUser) {
    throw new ApiError(404, 'User not found');
  }
  if (targetUser.is_system_user === true) {
    throw new ApiError(403, 'System users cannot be modified.');
  }

  targetUser.role = newRole;
  await targetUser.save();

  try {
    await auditService.logAdminAction(adminUserId, 'user_role_update', { targetUserId: targetUserId, newRole: newRole });
  } catch (auditError) {
    console.error('Failed to log admin action for user_role_update:', auditError);
  }

  return selectUserProfileFields(targetUser.toJSON());
};

/**
 * Deletes a user and their associated documents. (Admin operation)
 * @param {number} targetUserId - The ID of the user to delete.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise<Object>} - Success object.
 * @throws {ApiError} - Throws error if user not found, is a system user, or deletion fails.
 */
const deleteUser = async (targetUserId, adminUserId) => {
  const t = await sequelize.transaction();

  try {
    const targetUser = await User.findByPk(targetUserId, { transaction: t });

    if (!targetUser) {
      throw new ApiError(404, 'User not found');
    }

    if (targetUser.is_system_user === true) {
      throw new ApiError(403, 'System users cannot be deleted.');
    }

    // Handle Associated Documents
    const userDocuments = await Document.findAll({
      where: { uploaded_by: targetUserId },
      transaction: t,
    });

    for (const doc of userDocuments) {
      if (doc.file_path) {
        // Assuming 'uploads/' is at the project root.
        // backend/src/services -> backend/src -> backend -> project_root
        const filePath = path.join(__dirname, '../../../uploads', doc.file_path);
        try {
          await fs.promises.unlink(filePath);
          console.log(`Successfully deleted physical file: ${filePath}`);
        } catch (fileError) {
          console.error(`Failed to delete physical file ${filePath}:`, fileError.message);
          // IMPORTANT: Re-throw to trigger transaction rollback
          throw new ApiError(500, `Failed to delete associated file ${doc.file_path}. User deletion rolled back.`);
        }
      }
      await doc.destroy({ transaction: t });
    }

    // Delete the User
    await targetUser.destroy({ transaction: t });

    // Commit the transaction
    await t.commit();

    // Audit Log
    try {
      await auditService.logAdminAction(adminUserId, 'user_delete', { targetUserId: targetUserId });
    } catch (auditError) {
      console.error('Failed to log admin action for user_delete:', auditError);
    }

    return { success: true, message: 'User and associated documents deleted successfully.' };
  } catch (error) {
    // Rollback transaction
    await t.rollback();

    // Log the original error for debugging
    console.error(`Failed to delete user [${targetUserId}]:`, error);

    // Re-throw the original ApiError or a new one for other errors
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(500, `Failed to delete user. ${error.message}`);
  }
};

/**
 * Changes a user's password by an admin.
 * @param {number} targetUserId - The ID of the user whose password is to be changed.
 * @param {string} newPassword - The new password.
 * @param {number} adminUserId - The ID of the admin performing the action.
 * @returns {Promise&lt;Object&gt;} - Success object.
 * @throws {ApiError} - Throws error if user not found, is a system user, or update fails.
 */
const changeUserPasswordByAdmin = async (targetUserId, newPassword, adminUserId) => {
  const targetUser = await User.findByPk(targetUserId);
  if (!targetUser) {
    throw new ApiError(404, 'User not found');
  }

  if (targetUser.is_system_user === true) {
    throw new ApiError(403, 'System users cannot have their password changed by an admin.');
  }

  const hashedPassword = await bcrypt.hash(newPassword, 10);
  targetUser.password = hashedPassword;
  await targetUser.save();

  try {
    await auditService.logAdminAction(adminUserId, 'admin_change_user_password', { targetUserId: targetUserId });
  } catch (auditError) {
    console.error('Failed to log admin action for admin_change_user_password:', auditError);
  }

  return { success: true, message: 'Password changed successfully by admin.' };
};

module.exports = {
  fetchOwnProfile,
  modifyOwnProfile,
  updateOwnPassword,
  selectUserProfileFields, // Exporting for potential use in other services/controllers if needed
  listNonSystemUsers,
  getNonSystemUserById,
  updateUserStatus,
  updateUserRole,
  deleteUser,
  changeUserPasswordByAdmin,
};

================
File: src/utils/ApiError.js
================
class ApiError extends Error {
  constructor(statusCode, message, isOperational = true, stack = '') {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

module.exports = ApiError;

================
File: src/utils/catchAsync.js
================
const catchAsync = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch((err) => next(err));
};

module.exports = catchAsync;

================
File: src/validators/admin.user.validator.js
================
const Joi = require('joi');

const updateUserStatusSchema = Joi.object({
  status: Joi.string().trim().valid('approved', 'pending', 'rejected').required().messages({
    'string.base': 'Status must be a string.',
    'string.empty': 'Status is required.',
    'any.only': 'Status must be one of [approved, pending, rejected].',
    'any.required': 'Status is required.'
  })
});

const updateUserRoleSchema = Joi.object({
  role: Joi.string().trim().valid('admin', 'member').required().messages({
    'string.base': 'Role must be a string.',
    'string.empty': 'Role is required.',
    'any.only': 'Role must be one of [admin, member].',
    'any.required': 'Role is required.'
  })
});

const changePasswordSchema = Joi.object({
  newPassword: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?]).{8,}$'))
    .required()
    .messages({
      'string.base': 'New password must be a string.',
      'string.empty': 'New password is required.',
      'string.min': 'New password must be at least 8 characters long.',
      'string.pattern.base': 'New password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one number, and one special character.',
      'any.required': 'New password is required.'
    })
});

module.exports = {
  updateUserStatusSchema,
  updateUserRoleSchema,
  changePasswordSchema, // Added for User Story 7, will be used later
};

================
File: src/validators/announcement.validator.js
================
const Joi = require('joi');

const createAnnouncementSchema = Joi.object({
  title: Joi.string().trim().max(255).required().messages({
    'string.base': 'Title must be a string.',
    'string.empty': 'Title is required.',
    'string.max': 'Title cannot exceed 255 characters.',
    'any.required': 'Title is required.'
  }),
  content: Joi.string().trim().required().messages({
    'string.base': 'Content must be a string.',
    'string.empty': 'Content is required.',
    'any.required': 'Content is required.'
  }),
  expiresAt: Joi.date().iso().greater('now').optional().messages({
    'date.base': 'Expiration date must be a valid date.',
    'date.format': 'Expiration date must be in ISO 8601 format.',
    'date.greater': 'Expiration date must be in the future.'
  })
});

const updateAnnouncementSchema = Joi.object({
  title: Joi.string().trim().min(1).max(255).optional().messages({
    'string.base': 'Title must be a string.',
    'string.min': 'Title must not be empty if provided.',
    'string.max': 'Title cannot exceed 255 characters.'
  }),
  content: Joi.string().trim().min(1).optional().messages({
    'string.base': 'Content must be a string.',
    'string.min': 'Content must not be empty if provided.'
  }),
  expires_at: Joi.date().iso().allow(null).optional().messages({
    'date.base': 'expires_at must be a valid date or null.',
    'date.format': 'expires_at must be a valid ISO 8601 date or null.'
  })
}).or('title', 'content', 'expires_at').messages({
  'object.missing': 'At least one field (title, content, or expires_at) must be provided for update.'
});

const listAnnouncementsSchema = Joi.object({
  page: Joi.number().integer().min(1).optional().messages({
    'number.base': 'Page must be a number.',
    'number.integer': 'Page must be an integer.',
    'number.min': 'Page must be at least 1.'
  }),
  limit: Joi.number().integer().min(1).max(100).optional().messages({
    'number.base': 'Limit must be a number.',
    'number.integer': 'Limit must be an integer.',
    'number.min': 'Limit must be at least 1.',
    'number.max': 'Limit must be between 1 and 100.'
  }),
  sortOrder: Joi.string().valid('asc', 'desc').optional().messages({
    'string.base': 'Sort order must be a string.',
    'any.only': 'Sort order must be one of "asc" or "desc".'
  }),
  status: Joi.string().valid('active').optional().messages({
    'string.base': 'Status must be a string.',
    'any.only': 'Status must be "active" if provided.'
  }),
  sortBy: Joi.string().valid('created_at').optional().messages({
    'string.base': 'Sort by must be a string.',
    'any.only': 'Sort by must be "created_at" if provided.'
  })
});

module.exports = {
  createAnnouncementSchema,
  updateAnnouncementSchema,
  listAnnouncementsSchema,
};

================
File: src/validators/audit.validator.js
================
const Joi = require('joi');

const getAuditLogsSchema = Joi.object({
  page: Joi.number().integer().min(1).optional().default(1),
  limit: Joi.number().integer().min(1).max(100).optional().default(10),
});

module.exports = {
  getAuditLogsSchema,
};

================
File: src/validators/auth.validator.js
================
const Joi = require('joi');

const registerSchema = Joi.object({
  name: Joi.string().trim().min(1).required().messages({
    'string.base': 'Name must be a string.',
    'string.empty': 'Name is required.',
    'string.min': 'Name is required.',
    'any.required': 'Name is required.'
  }),
  email: Joi.string().trim().email().required().messages({
    'string.base': 'Email must be a string.',
    'string.empty': 'Email is required.',
    'string.email': 'Email must be a valid email address.',
    'any.required': 'Email is required.'
  }),
  password: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?]).*$'))
    .required()
    .messages({
      'string.base': 'Password must be a string.',
      'string.empty': 'Password is required.',
      'string.min': 'Password must be at least 8 characters long.',
      'string.pattern.base': 'Password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one number, and one special character.',
      'any.required': 'Password is required.'
    })
  // passwordConfirmation: Joi.string().valid(Joi.ref('password')).required().messages({
  //   'any.only': 'Password confirmation must match password.',
  //   'any.required': 'Password confirmation is required.'
  // })
});

const loginSchema = Joi.object({
  email: Joi.string().trim().email().required().messages({
    'string.base': 'Email must be a string.',
    'string.empty': 'Email is required.',
    'string.email': 'Email must be a valid email address.',
    'any.required': 'Email is required.'
  }),
  password: Joi.string().required().messages({
    'string.base': 'Password must be a string.',
    'string.empty': 'Password is required.',
    'any.required': 'Password is required.'
  })
});

const forgotPasswordSchema = Joi.object({
  email: Joi.string().trim().email().required().messages({
    'string.base': 'Email must be a string.',
    'string.empty': 'Email is required.',
    'string.email': 'Email must be a valid email address.',
    'any.required': 'Email is required.'
  })
});

const resetPasswordSchema = Joi.object({
  token: Joi.string().allow('').messages({
    'string.base': 'Token must be a string.'
  }),
  newPassword: Joi.string().allow('')
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?]).*$'))
    .messages({
      'string.base': 'New password must be a string.',
      'string.min': 'New password must be at least 8 characters long.',
      'string.pattern.base': 'Password must include uppercase, lowercase, number, and special character.'
    })
})
.custom((value, helpers) => {
  const { token, newPassword } = value;
  const tokenIsEffectivelyMissing = token === undefined || token === '';
  const newPasswordIsEffectivelyMissing = newPassword === undefined || newPassword === '';

  if (tokenIsEffectivelyMissing && newPasswordIsEffectivelyMissing) {
    return helpers.error('custom.bothMissing');
  }
  if (tokenIsEffectivelyMissing) {
    return helpers.error('custom.tokenMissing');
  }
  if (newPasswordIsEffectivelyMissing) {
    return helpers.error('custom.newPasswordMissing');
  }
  return value;
})
.messages({
  'custom.bothMissing': 'Token and newPassword are required.',
  'custom.tokenMissing': 'Token is required.',
  'custom.newPasswordMissing': 'New password is required.'
});

module.exports = {
  registerSchema,
  loginSchema,
  forgotPasswordSchema,
  resetPasswordSchema,
};

================
File: src/validators/config.validator.js
================
const Joi = require('joi');

const updateConfigSchema = Joi.object({
  // From req.body
  value: Joi.string().trim().min(1).required().messages({
    'string.base': 'Value must be a string.',
    'string.empty': 'Value cannot be empty.',
    'string.min': 'Value cannot be empty.',
    'any.required': 'Value is required.',
  }),
  // From req.params
  key: Joi.string().required(),
});

module.exports = {
  updateConfigSchema,
};

================
File: src/validators/discussion.validator.js
================
const Joi = require('joi');

const createThreadSchema = Joi.object({
  title: Joi.string().min(3).max(255).required(),
  content: Joi.string().min(1).required(),
});

const createReplySchema = Joi.object({
  content: Joi.string().min(1).required(),
});

const listThreadsSchema = Joi.object({
  page: Joi.number().integer().min(1).default(1),
  limit: Joi.number().integer().min(1).max(50).default(10),
});

module.exports = {
  createThreadSchema,
  createReplySchema,
  listThreadsSchema,
};

================
File: src/validators/document.validator.js
================
const Joi = require('joi');

const uploadDocumentSchema = Joi.object({
  title: Joi.string().trim().min(1).required().messages({
    'string.base': 'Title must be a string.',
    'string.empty': 'Title is required.',
    'string.min': 'Title is required.',
    'any.required': 'Title is required.'
  }),
  description: Joi.string().trim().allow('').optional().messages({ // Allow empty string for optional description
    'string.base': 'Description must be a string.'
  }),
  is_public: Joi.boolean().required().messages({
    'boolean.base': 'Is Public flag must be a boolean.',
    'any.required': 'Is Public flag is required.'
  })
});

// Schema for when a document is being updated (if needed later)
// const updateDocumentSchema = Joi.object({
//   title: Joi.string().trim().min(1).optional(),
//   description: Joi.string().trim().allow('').optional(),
//   is_public: Joi.boolean().optional(),
//   approved: Joi.boolean().optional() // Admins might also update approval status directly
// });

module.exports = {
  uploadDocumentSchema,
  // updateDocumentSchema,
};

================
File: src/validators/event.validator.js
================
// backend/src/validators/event.validator.js

const Joi = require('joi');

const listEventsSchema = Joi.object({
  status: Joi.string().valid('upcoming', 'past').optional(),
  page: Joi.number().integer().min(1).optional(),
  limit: Joi.number().integer().min(1).max(50).optional(),
  sortBy: Joi.string().valid('event_date', 'title', 'created_at').optional(),
  sortOrder: Joi.string().valid('asc', 'desc').optional(),
});

const createEventSchema = Joi.object({
  title: Joi.string().min(3).max(255).required(),
  description: Joi.string().min(10).required(),
  event_date: Joi.date().iso().greater('now').required().messages({
    'date.greater': 'Event date must be in the future.'
  }),
  location: Joi.string().max(255).required(),
});

const adminUpdateEventSchema = Joi.object({
  // From path
  id: Joi.number().integer().required(),
  // From body
  title: Joi.string().optional(),
  description: Joi.string().optional(),
  start_date: Joi.date().iso().optional(),
  end_date: Joi.date().iso().optional(),
  location: Joi.string().optional(),
}).with('start_date', 'end_date') // If one is present, the other should be too for validation
  .and('start_date', 'end_date') // if you want to enforce both if one is provided
  .custom((value, helpers) => {
    if (value.start_date && value.end_date && value.end_date <= value.start_date) {
      return helpers.message('End date must be after start date.');
    }
    return value;
  });

module.exports = {
  listEventsSchema,
  createEventSchema,
  adminUpdateEventSchema,
};

================
File: src/validators/user.validator.js
================
const Joi = require('joi');

const updateProfileSchema = Joi.object({
  name: Joi.string().trim().min(1).required().messages({
    'string.empty': 'Name cannot be empty.',
    'any.required': 'Name is required.',
  }),
});

const changePasswordSchema = Joi.object({
  currentPassword: Joi.string().required(),
  newPassword: Joi.string()
    .min(8)
    .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?]).*$'))
    .required()
    .messages({
      'string.min': 'New password must be at least 8 characters long.',
      'string.pattern.base': 'New password must include uppercase, lowercase, number, and special character.',
      'any.required': 'New password is required.',
    }),
});

module.exports = {
  updateProfileSchema,
  changePasswordSchema,
};

================
File: src/app.js
================
require('dotenv').config(); // Load environment variables from .env file
const express = require('express');
const path = require('path'); // Required for serving static files if needed later
const db = require('../models'); // Sequelize instance and models

// Import routes
const authRoutes = require('./routes/auth.routes');
const adminUserRoutes = require('./routes/admin.user.routes');
const adminDocumentRoutes = require('./routes/document.routes'); // For admin document operations
const announcementRoutes = require('./routes/announcement.routes.js');
const eventRoutes = require('./routes/event.routes.js');
const userRoutes = require('./routes/user.routes'); // Routes for user self-management
const discussionRoutes = require('./routes/discussion.routes');
const configRoutes = require('./routes/config.routes'); // Routes for admin config management
const auditRoutes = require('./routes/audit.routes'); // Routes for admin audit log management
const publicDocumentRoutes = require('./routes/public.document.routes'); // For public document access
// Public document routes will be separate, e.g., publicDocumentRoutes

const app = express();

// Middleware
app.use(express.json()); // for parsing application/json
app.use(express.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded

// Basic Route for testing
app.get('/', (req, res) => {
  res.json({ message: 'Welcome to the HOA Management API!' });
});

// API Routes
app.use('/api/auth', authRoutes);
app.use('/api/admin/users', adminUserRoutes);
app.use('/api/admin/documents', adminDocumentRoutes); // Admin-specific document routes
app.use('/api/announcements', announcementRoutes);
app.use('/api/events', eventRoutes);
app.use('/api/users', userRoutes); // Mount user self-management routes
app.use('/api/discussions', discussionRoutes);
app.use('/api/admin/config', configRoutes); // Mount admin config routes
app.use('/api/admin/audit-logs', auditRoutes); // Mount admin audit log routes
app.use('/api/documents', publicDocumentRoutes); // For public listing/downloading

// Global error handler (optional, can be more sophisticated)
app.use((err, req, res, next) => {
  console.error(err.stack);
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';
  res.status(statusCode).json({ message });
});

const PORT = process.env.PORT || 3001; // Default to 3001 if PORT not in .env

async function startServer() {
  try {
    await db.sequelize.authenticate();
    console.log('Database connection has been established successfully.');
    // await db.sequelize.sync(); // { alter: true } or { force: true } during dev if needed
    // console.log('All models were synchronized successfully.'); // Uncomment if using sync

    app.listen(PORT, () => {
      console.log(`Server is running on port ${PORT}.`);
      console.log(`Access it at http://localhost:${PORT}`);
    });
  } catch (error) {
    console.error('Unable to connect to the database or start server:', error);
    process.exit(1); // Exit if cannot connect to DB
  }
}

// Only start server if this file is run directly (not when imported as a module)
if (require.main === module) {
  startServer();
}

module.exports = app; // Export for testing or other purposes

================
File: test/good/announcements.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');

describe('Announcement API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let testAnnouncementId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;

    memberToken = await createAndApproveUser(
      { name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!' },
      adminToken
    );
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('GET /announcements', () => {
    beforeAll(async () => {
      // Create a test announcement
      const res = await request(app)
        .post('/api/announcements')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          title: 'Test Announcement',
          content: 'This is a test announcement',
          expiresAt: '2025-12-31T23:59:59Z'
        });
      testAnnouncementId = res.body.id;
    });

    it('should list announcements for member', async () => {
      const res = await request(app)
        .get('/api/announcements')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should list announcements for admin', async () => {
      const res = await request(app)
        .get('/api/announcements')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });
  });

  describe('Admin Announcement Management', () => {
    describe('POST /announcements', () => {
      it('should create announcement as admin', async () => {
        const res = await request(app)
          .post('/api/announcements')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'New Announcement',
            content: 'Important update',
            expiresAt: '2025-12-31T23:59:59Z'
          });
        
        expect(res.statusCode).toEqual(201);
        expect(res.body.title).toEqual('New Announcement');
      });

      it('should fail with missing required fields', async () => {
        const res = await request(app)
          .post('/api/announcements')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            content: 'Missing title'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .post('/api/announcements')
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized',
            content: 'Should fail'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('PUT /announcements/{id}', () => {
      it('should update announcement as admin', async () => {
        const res = await request(app)
          .put(`/api/announcements/${testAnnouncementId}`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'Updated Announcement',
            content: 'Updated content'
          });
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.title).toEqual('Updated Announcement');
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .put(`/api/announcements/${testAnnouncementId}`)
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized Update'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('DELETE /announcements/{id}', () => {
      it('should delete announcement as admin', async () => {
        const res = await request(app)
          .delete(`/api/announcements/${testAnnouncementId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        // First create a new announcement to delete
        const createRes = await request(app)
          .post('/api/announcements')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'To Delete',
            content: 'Will try to delete'
          });
        
        const res = await request(app)
          .delete(`/api/announcements/${createRes.body.id}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });
});

================
File: test/good/audit.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');

describe('Audit Log API Integration Tests', () => {
  let adminToken;
  let memberToken;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;

    // Register and login a member user
    memberToken = await createAndApproveUser(
      { name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!' },
      adminToken
    );
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('GET /admin/audit-logs', () => {
    it('should retrieve audit logs as admin', async () => {
      const res = await request(app)
        .get('/api/admin/audit-logs')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body).toHaveProperty('data');
      expect(res.body).toHaveProperty('pagination');
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should fail for non-admin user', async () => {
      const res = await request(app)
        .get('/api/admin/audit-logs')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(403);
    });

    it('should fail without token', async () => {
      const res = await request(app)
        .get('/api/admin/audit-logs');
      
      expect(res.statusCode).toEqual(401);
    });

    it('should support pagination', async () => {
      const res = await request(app)
        .get('/api/admin/audit-logs?page=1&limit=5')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body.pagination.limit).toEqual(5);
      expect(res.body.pagination.currentPage).toEqual(1);
    });

    it('should validate pagination params', async () => {
      const res = await request(app)
        .get('/api/admin/audit-logs?page=0&limit=101')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(400);
    });
  });

  describe('Audit Log Creation', () => {
    it('should create audit log for admin actions', async () => {
      // Perform an admin action that should trigger audit logging
      const createRes = await request(app)
        .post('/api/announcements')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          title: 'Test Audit Log',
          content: 'This should create an audit entry'
        });
      
      expect(createRes.statusCode).toEqual(201);

      // Verify audit log was created
      const auditRes = await request(app)
        .get('/api/admin/audit-logs')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(auditRes.statusCode).toEqual(200);
      const announcementAction = auditRes.body.data.find(
        log => log.action.includes('announcement_create')
      );
      expect(announcementAction).toBeDefined();
    });
  });
});

================
File: test/good/auth.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB } = require('../utils/dbHelpers');

describe('Auth API Integration Tests', () => {
  beforeAll(async () => {
    await setupTestDB();
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('POST /api/auth/login', () => {
    it('should login with valid admin credentials', async () => {
      const res = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'testadmin@example.com',
          password: 'testadmin123'
        });
      
      expect(res.statusCode).toEqual(200);
      expect(res.body).toHaveProperty('token');
    });

    it('should fail with invalid password', async () => {
      const res = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'testadmin@example.com',
          password: 'wrongpassword'
        });
      
      expect(res.statusCode).toEqual(401);
    });
  });
});

================
File: test/good/config.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB } = require('../utils/dbHelpers');

describe('Configuration API Integration Tests', () => {
  let adminToken;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin to get token
    const loginRes = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = loginRes.body.token;
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('GET /admin/config', () => {
    it('should retrieve all configurations (admin)', async () => {
      const res = await request(app)
        .get('/api/admin/config')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body).toHaveProperty('hoa_name');
      expect(res.body).toHaveProperty('hoa_description');
    });

    it('should fail without admin token', async () => {
      const res = await request(app)
        .get('/api/admin/config');
      
      expect(res.statusCode).toEqual(401);
    });
  });

  describe('PUT /admin/config/{key}', () => {
    it('should update configuration value (admin)', async () => {
      const res = await request(app)
        .put('/api/admin/config/hoa_name')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          value: 'New HOA Name'
        });
      
      expect(res.statusCode).toEqual(200);
      expect(res.body).toHaveProperty('key', 'hoa_name');
      expect(res.body).toHaveProperty('value', 'New HOA Name');
    });

    it('should fail with empty value', async () => {
      const res = await request(app)
        .put('/api/admin/config/hoa_name')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          value: ''
        });
      
      expect(res.statusCode).toEqual(400);
    });

    it('should fail without admin token', async () => {
      const res = await request(app)
        .put('/api/admin/config/hoa_name')
        .send({
          value: 'Should Fail'
        });
      
      expect(res.statusCode).toEqual(401);
    });
  });
});

================
File: test/good/discussions.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');

describe('Discussion API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let member2Token;
  let testThreadId;
  let testReplyId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;
    expect(adminToken).toBeDefined();

    console.log(adminToken);

       // 2. Create and get tokens for member users using the helper
    memberToken = await createAndApproveUser(
      { name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!' },
      adminToken
    );
    
    member2Token = await createAndApproveUser(
      { name: 'Test Member 2', email: 'testmember2@example.com', password: 'Testmember123!' },
      adminToken
    );

    // Assert that the tokens were actually created
    expect(memberToken).toBeDefined();
    expect(member2Token).toBeDefined();
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('POST api/discussions', () => {
    it('should create discussion thread as member', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          title: 'Test Discussion',
          content: 'This is a test discussion thread'
        });
      
      expect(res.statusCode).toEqual(201);
      expect(res.body).toHaveProperty('id');
      expect(res.body.title).toEqual('Test Discussion');
      testThreadId = res.body.id;
    });

    it('should fail with missing required fields', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: 'Missing title'
        });
      
      expect(res.statusCode).toEqual(400);
    });

    it('should fail without authentication', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .send({
          title: 'Unauthorized',
          content: 'Should fail'
        });
      
      expect(res.statusCode).toEqual(401);
    });
  });

  describe('POST /api/discussions/{threadId}/replies', () => {
    it('should post reply to thread', async () => {
      const res = await request(app)
        .post(`/api/discussions/${testThreadId}/replies`)
        .set('Authorization', `Bearer ${member2Token}`)
        .send({
          content: 'This is a test reply'
        });
      
      expect(res.statusCode).toEqual(201);
      expect(res.body).toHaveProperty('id');
      testReplyId = res.body.id;
    });

    it('should fail with empty content', async () => {
      const res = await request(app)
        .post(`/api/discussions/${testThreadId}/replies`)
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: ''
        });
      
      expect(res.statusCode).toEqual(400);
    });

    it('should fail for non-existent thread', async () => {
      const res = await request(app)
        .post('/api/discussions/9999/replies')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: 'Test reply'
        });
      
      expect(res.statusCode).toEqual(404);
    });
  });

  describe('GET /api/discussions', () => {
    it('should list discussion threads', async () => {
      const res = await request(app)
        .get('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.threads)).toBeTruthy();
      expect(res.body.threads.some(t => t.id === testThreadId)).toBeTruthy();
    });

    it('should include reply counts', async () => {
      const res = await request(app)
        .get('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`);
      
      const thread = res.body.threads.find(t => t.id === testThreadId);
      expect(thread.reply_count).toBeGreaterThanOrEqual(1);
    });
  });

  describe('GET /api/discussions/{threadId}', () => {
    it('should get thread with replies', async () => {
      const res = await request(app)
        .get(`/api/discussions/${testThreadId}`)
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body.mainThread.id).toEqual(testThreadId);
      expect(Array.isArray(res.body.replies)).toBeTruthy();
      expect(res.body.replies.some(r => r.id === testReplyId)).toBeTruthy();
    });

    it('should fail for non-existent thread', async () => {
      const res = await request(app)
        .get('/api/discussions/9999')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(404);
    });
  });

  describe('Admin Discussion Management', () => {
    describe('DELETE /api/discussions/{threadId}', () => {
      it('should delete thread as admin', async () => {
        // Create a new thread to delete
        const createRes = await request(app)
          .post('/api/discussions')
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Thread to delete',
            content: 'Content'
          });
        
        const res = await request(app)
          .delete(`/api/discussions/${createRes.body.id}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .delete(`/api/discussions/${testThreadId}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('DELETE /api/discussions/replies/{replyId}', () => {
      it('should delete reply as admin', async () => {
        const res = await request(app)
          .delete(`/api/discussions/replies/${testReplyId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        // Create a new reply to try deleting
        const createRes = await request(app)
          .post(`/api/discussions/${testThreadId}/replies`)
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            content: 'Test reply to delete'
          });
        
        const res = await request(app)
          .delete(`/api/discussions/replies/${createRes.body.id}`)
          .set('Authorization', `Bearer ${member2Token}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });
});

================
File: test/good/documents.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');
const path = require('path');

describe('Document API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let testDocumentId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;

    // Register and login a member user
    memberToken = await createAndApproveUser(
      { name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!' },
      adminToken
    );
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('Public/User Document Access', () => {
    beforeAll(async () => {
      // Upload a test document
      const res = await request(app)
        .post('/api/admin/documents')
        .set('Authorization', `Bearer ${adminToken}`)
        .field('title', 'Test Document')
        .field('is_public', true)
        .attach('documentFile', path.join(__dirname, '../fixtures/test.pdf'));
      testDocumentId = res.body.document.id;
    });

    describe('GET /documents', () => {
      it('should list public documents for guest', async () => {
        const res = await request(app)
          .get('/api/documents');
        
        expect(res.statusCode).toEqual(200);
        expect(Array.isArray(res.body.documents)).toBeTruthy();
      });

      it('should list all approved documents for member', async () => {
        const res = await request(app)
          .get('/api/documents')
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(200);
        expect(Array.isArray(res.body.documents)).toBeTruthy();
      });
    });

    describe('GET /documents/{documentId}', () => {
      it('should get document metadata for member', async () => {
        const res = await request(app)
          .get(`/api/documents/${testDocumentId}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.title).toEqual('Test Document');
      });

      it('should fail for non-existent document', async () => {
        const res = await request(app)
          .get('/api/documents/9999')
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(404);
      });
    });

    describe('GET /documents/{documentId}/download', () => {
      it('should download document file', async () => {
        const res = await request(app)
          .get(`/api/documents/${testDocumentId}/download`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(200);
        expect(res.headers['content-type']).toEqual('application/pdf');
      });
    });
  });

  describe('Admin Document Management', () => {
    describe('POST /admin/documents', () => {
      it('should upload a new document', async () => {
        const res = await request(app)
          .post('/api/admin/documents')
          .set('Authorization', `Bearer ${adminToken}`)
          .field('title', 'Admin Upload Test')
          .field('is_public', false)
          .attach('documentFile', path.join(__dirname, '../fixtures/test.pdf'));
        
        expect(res.statusCode).toEqual(201);
        expect(res.body.document.title).toEqual('Admin Upload Test');
      });

      it('should fail with invalid file type', async () => {
        const res = await request(app)
          .post('/api/admin/documents')
          .set('Authorization', `Bearer ${adminToken}`)
          .field('title', 'Invalid File')
          .field('is_public', true)
          .attach('documentFile', path.join(__dirname, '../fixtures/invalid.exe'));
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail without required fields', async () => {
        const res = await request(app)
          .post('/api/admin/documents')
          .set('Authorization', `Bearer ${adminToken}`)
          .attach('documentFile', path.join(__dirname, '../fixtures/test.pdf'));
        
        expect(res.statusCode).toEqual(400);
      });
    });

    describe('PUT /admin/documents/{id}/approve', () => {
      it('should approve a document', async () => {
        // First upload an unapproved document
        const uploadRes = await request(app)
          .post('/api/admin/documents')
          .set('Authorization', `Bearer ${adminToken}`)
          .field('title', 'Pending Approval')
          .field('is_public', false)
          .attach('documentFile', path.join(__dirname, '../fixtures/test.pdf'));
        
        const docId = uploadRes.body.document.id;
        
        const res = await request(app)
          .put(`/api/admin/documents/${docId}/approve`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.approved).toBeTruthy();
      });
    });

    describe('DELETE /admin/documents/{id}', () => {
      it('should delete a document', async () => {
        // First upload a test document
        const uploadRes = await request(app)
          .post('/api/admin/documents')
          .set('Authorization', `Bearer ${adminToken}`)
          .field('title', 'To Be Deleted')
          .field('is_public', true)
          .attach('documentFile', path.join(__dirname, '../fixtures/test.pdf'));
        
        const docId = uploadRes.body.document.id;
        
        const res = await request(app)
          .delete(`/api/admin/documents/${docId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });
    });
  });
});

================
File: test/good/events.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');
const { sequelize } = require('../../models');

describe('Event API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let testEventId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;

    memberToken = await createAndApproveUser( {name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!'}, adminToken);
    expect(memberToken).toBeDefined();
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('GET /events', () => {
    beforeAll(async () => {
      // Create a test event
      const res = await request(app)
        .post('/api/events')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          title: 'Test Event',
          description: 'This is a test event',
          event_date: '2025-12-31T18:00:00Z',
          location: 'Test Location'
        });
      testEventId = res.body.id;
    });

    it('should list upcoming events for member', async () => {
      const res = await request(app)
        .get('/api/events?status=upcoming')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should list events for admin', async () => {
      const res = await request(app)
        .get('/api/events')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should filter past events', async () => {
      const queryInterface = sequelize.getQueryInterface();
      await queryInterface.bulkInsert('events', [{
        title: 'Past Event',
        description: 'This is a past event',
        start_date: new Date('2020-01-01T18:00:00Z'), // Use start_date for the column name
        end_date: new Date('2020-01-01T19:00:00Z'),   // Use end_date
        location: 'Past Location',
        created_by: 1, // Assuming admin user ID is 1
        created_at: new Date(),
        updated_at: new Date(),
      }]);

      const res = await request(app)
        .get('/api/events?status=past')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body.data.some(e => e.title === 'Past Event')).toBeTruthy();
    });
  });

  describe('Admin Event Management', () => {
    describe('POST /events', () => {
      it('should create event as admin', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'New Event',
            description: 'Important event',
            event_date: '2025-12-31T18:00:00Z',
            location: 'Event Location'
          });
        
        expect(res.statusCode).toEqual(201);
        expect(res.body.title).toEqual('New Event');
      });

      it('should fail with missing required fields', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            description: 'Missing title'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail with past event date', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'Past Event',
            description: 'Should fail',
            event_date: '2020-01-01T00:00:00Z',
            location: 'Past'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized',
            description: 'Should fail'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('PUT /events/{id}', () => {
      it('should update event as admin', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'Updated Event',
            description: 'Updated content'
          });
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.title).toEqual('Updated Event');
      });

      it('should fail with end_date before start_date', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            start_date: '2025-12-31T18:00:00Z',
            end_date: '2025-12-30T18:00:00Z'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized Update'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('DELETE /events/{id}', () => {
      it('should delete event as admin', async () => {
        const res = await request(app)
          .delete(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        // First create a new event to delete
        const createRes = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'To Delete',
            description: 'Will try to delete',
            event_date: '2025-12-31T18:00:00Z',
            location: 'Test'
          });
        
        const res = await request(app)
          .delete(`/api/events/${createRes.body.id}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });
});

================
File: test/good/users.test.js
================
const request = require('supertest');
const app = require('../../src/app');
const { setupTestDB, teardownTestDB, createAndApproveUser, createAndApproveUserForUserManagement } = require('../utils/dbHelpers');

describe('User API Integration Tests', () => {
  let adminToken;
  let userToken;
  let testUserId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin to get token for admin tests
    const loginRes = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = loginRes.body.token;

    // Create, approve, and login a test user using our new helper
    const { token, user } = await createAndApproveUserForUserManagement(
      {
        name: 'Test User',
        email: 'testuser@example.com',
        // FIX: Use a password that meets complexity requirements
        password: 'Testuser123!' 
      },
      adminToken
    );
    userToken = token;
    testUserId = user.id;
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('User Self-Management', () => {
    // REMOVED: The inner beforeAll is no longer needed!

    describe('GET /api/users/me', () => {
      it('should get current user profile', async () => {
        const res = await request(app)
          .get('/api/users/me')
          .set('Authorization', `Bearer ${userToken}`);
        
        expect(res.statusCode).toEqual(200);
        expect(res.body).toHaveProperty('id', testUserId);
        expect(res.body.email).toEqual('testuser@example.com');
      });

      it('should fail without token', async () => {
        const res = await request(app)
          .get('/api/users/me');
        
        expect(res.statusCode).toEqual(401);
      });
    });

    describe('PUT /api/users/me', () => {
      it('should update user profile', async () => {
        const res = await request(app)
          .put('/api/users/me')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            name: 'Updated Test User'
          });
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.name).toEqual('Updated Test User');
      });

      it('should fail with empty name', async () => {
        const res = await request(app)
          .put('/api/users/me')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            name: ''
          });
        
        expect(res.statusCode).toEqual(400);
      });
    });

    describe('PUT /api/users/me/password', () => {
      it('should change password', async () => {
        const res = await request(app)
          .put('/api/users/me/password')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            currentPassword: 'Testuser123!',
            newPassword: 'Newpassword123!'
          });
        
        expect(res.statusCode).toEqual(200);
      });

      it('should fail with incorrect current password', async () => {
        const res = await request(app)
          .put('/api/users/me/password')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            currentPassword: 'wrongpassword',
            newPassword: 'Newpassword123!'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });

  describe('Admin User Management', () => {
    describe('GET /api/admin/users', () => {
      it('should list all users', async () => {
        const res = await request(app)
          .get('/api/admin/users')
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(200);
        // FIX: The response from the service uses `rows`, not `users`.
        expect(Array.isArray(res.body.rows)).toBeTruthy();
      });

      it('should fail without admin token', async () => {
        const res = await request(app)
          .get('/api/admin/users');
        
        expect(res.statusCode).toEqual(401);
      });
    });

    describe('PUT /api/admin/users/{userId}/status', () => {
      // Note: User is already approved in beforeAll, so we'll test another status change
      it('should update user status to rejected', async () => {
        const res = await request(app)
          .put(`/api/admin/users/${testUserId}/status`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            status: 'rejected'
          });
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.status).toEqual('rejected');
      });

      it('should fail with invalid status', async () => {
        const res = await request(app)
          .put(`/api/admin/users/${testUserId}/status`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            status: 'invalid'
          });
        
        expect(res.statusCode).toEqual(400);
      });
    });

    describe('DELETE /api/admin/users/{userId}', () => {
      it('should delete user', async () => {
        // We need a NEW user to delete, because if we delete testUser, other tests might fail
        // if they run after this one.
        const response = await createAndApproveUserForUserManagement(
            { name: 'Delete Me', email: 'deleteme@example.com', password: 'Password123!' },
            adminToken
        );

        const res = await request(app)
          .delete(`/api/admin/users/${response.user.id}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(200);
      });

      it('should fail with invalid user id', async () => {
        const res = await request(app)
          .delete('/api/admin/users/9999')
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(404);
      });
    });
  });
});

================
File: test/integration/discussions.test.js
================
const request = require('supertest');
const app = require('../../../backend/src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');

describe('Discussion API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let member2Token;
  let testThreadId;
  let testReplyId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;
    expect(adminToken).toBeDefined();

    console.log(adminToken);

       // 2. Create and get tokens for member users using the helper
    memberToken = await createAndApproveUser(
      { name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!' },
      adminToken
    );
    
    member2Token = await createAndApproveUser(
      { name: 'Test Member 2', email: 'testmember2@example.com', password: 'Testmember123!' },
      adminToken
    );

    // Assert that the tokens were actually created
    expect(memberToken).toBeDefined();
    expect(member2Token).toBeDefined();
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('POST api/discussions', () => {
    it('should create discussion thread as member', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          title: 'Test Discussion',
          content: 'This is a test discussion thread'
        });
      
      expect(res.statusCode).toEqual(201);
      expect(res.body).toHaveProperty('id');
      expect(res.body.title).toEqual('Test Discussion');
      testThreadId = res.body.id;
    });

    it('should fail with missing required fields', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: 'Missing title'
        });
      
      expect(res.statusCode).toEqual(400);
    });

    it('should fail without authentication', async () => {
      const res = await request(app)
        .post('/api/discussions')
        .send({
          title: 'Unauthorized',
          content: 'Should fail'
        });
      
      expect(res.statusCode).toEqual(401);
    });
  });

  describe('POST /api/discussions/{threadId}/replies', () => {
    it('should post reply to thread', async () => {
      const res = await request(app)
        .post(`/api/discussions/${testThreadId}/replies`)
        .set('Authorization', `Bearer ${member2Token}`)
        .send({
          content: 'This is a test reply'
        });
      
      expect(res.statusCode).toEqual(201);
      expect(res.body).toHaveProperty('id');
      testReplyId = res.body.id;
    });

    it('should fail with empty content', async () => {
      const res = await request(app)
        .post(`/api/discussions/${testThreadId}/replies`)
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: ''
        });
      
      expect(res.statusCode).toEqual(400);
    });

    it('should fail for non-existent thread', async () => {
      const res = await request(app)
        .post('/api/discussions/9999/replies')
        .set('Authorization', `Bearer ${memberToken}`)
        .send({
          content: 'Test reply'
        });
      
      expect(res.statusCode).toEqual(404);
    });
  });

  describe('GET /api/discussions', () => {
    it('should list discussion threads', async () => {
      const res = await request(app)
        .get('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.threads)).toBeTruthy();
      expect(res.body.threads.some(t => t.id === testThreadId)).toBeTruthy();
    });

    it('should include reply counts', async () => {
      const res = await request(app)
        .get('/api/discussions')
        .set('Authorization', `Bearer ${memberToken}`);
      
      const thread = res.body.threads.find(t => t.id === testThreadId);
      expect(thread.reply_count).toBeGreaterThanOrEqual(1);
    });
  });

  describe('GET /api/discussions/{threadId}', () => {
    it('should get thread with replies', async () => {
      const res = await request(app)
        .get(`/api/discussions/${testThreadId}`)
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body.mainThread.id).toEqual(testThreadId);
      expect(Array.isArray(res.body.replies)).toBeTruthy();
      expect(res.body.replies.some(r => r.id === testReplyId)).toBeTruthy();
    });

    it('should fail for non-existent thread', async () => {
      const res = await request(app)
        .get('/api/discussions/9999')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(404);
    });
  });

  describe('Admin Discussion Management', () => {
    describe('DELETE /api/discussions/{threadId}', () => {
      it('should delete thread as admin', async () => {
        // Create a new thread to delete
        const createRes = await request(app)
          .post('/api/discussions')
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Thread to delete',
            content: 'Content'
          });
        
        const res = await request(app)
          .delete(`/api/discussions/${createRes.body.id}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .delete(`/api/discussions/${testThreadId}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('DELETE /api/discussions/replies/{replyId}', () => {
      it('should delete reply as admin', async () => {
        const res = await request(app)
          .delete(`/api/discussions/replies/${testReplyId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        // Create a new reply to try deleting
        const createRes = await request(app)
          .post(`/api/discussions/${testThreadId}/replies`)
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            content: 'Test reply to delete'
          });
        
        const res = await request(app)
          .delete(`/api/discussions/replies/${createRes.body.id}`)
          .set('Authorization', `Bearer ${member2Token}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });
});

================
File: test/integration/events.test.js
================
const request = require('supertest');
const app = require('../../../backend/src/app');
const { seedTestDB, cleanTestDB, setupTestDB, teardownTestDB, createAndApproveUser } = require('../utils/dbHelpers');
const { sequelize } = require('../../../backend/models');

describe('Event API Integration Tests', () => {
  let adminToken;
  let memberToken;
  let testEventId;

  beforeAll(async () => {
    await setupTestDB();
    
    // Login as admin
    const adminLogin = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'testadmin@example.com',
        password: 'testadmin123'
      });
    adminToken = adminLogin.body.token;

    memberToken = await createAndApproveUser( {name: 'Test Member', email: 'testmember@example.com', password: 'Testmember123!'}, adminToken);
    expect(memberToken).toBeDefined();
  });

  afterAll(async () => {
    await teardownTestDB();
  });

  describe('GET /events', () => {
    beforeAll(async () => {
      // Create a test event
      const res = await request(app)
        .post('/api/events')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          title: 'Test Event',
          description: 'This is a test event',
          event_date: '2025-12-31T18:00:00Z',
          location: 'Test Location'
        });
      testEventId = res.body.id;
    });

    it('should list upcoming events for member', async () => {
      const res = await request(app)
        .get('/api/events?status=upcoming')
        .set('Authorization', `Bearer ${memberToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should list events for admin', async () => {
      const res = await request(app)
        .get('/api/events')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(Array.isArray(res.body.data)).toBeTruthy();
    });

    it('should filter past events', async () => {
      const queryInterface = sequelize.getQueryInterface();
      await queryInterface.bulkInsert('events', [{
        title: 'Past Event',
        description: 'This is a past event',
        start_date: new Date('2020-01-01T18:00:00Z'), // Use start_date for the column name
        end_date: new Date('2020-01-01T19:00:00Z'),   // Use end_date
        location: 'Past Location',
        created_by: 1, // Assuming admin user ID is 1
        created_at: new Date(),
        updated_at: new Date(),
      }]);

      const res = await request(app)
        .get('/api/events?status=past')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(res.statusCode).toEqual(200);
      expect(res.body.data.some(e => e.title === 'Past Event')).toBeTruthy();
    });
  });

  describe('Admin Event Management', () => {
    describe('POST /events', () => {
      it('should create event as admin', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'New Event',
            description: 'Important event',
            event_date: '2025-12-31T18:00:00Z',
            location: 'Event Location'
          });
        
        expect(res.statusCode).toEqual(201);
        expect(res.body.title).toEqual('New Event');
      });

      it('should fail with missing required fields', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            description: 'Missing title'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail with past event date', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'Past Event',
            description: 'Should fail',
            event_date: '2020-01-01T00:00:00Z',
            location: 'Past'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized',
            description: 'Should fail'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('PUT /events/{id}', () => {
      it('should update event as admin', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'Updated Event',
            description: 'Updated content'
          });
        
        expect(res.statusCode).toEqual(200);
        expect(res.body.title).toEqual('Updated Event');
      });

      it('should fail with end_date before start_date', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            start_date: '2025-12-31T18:00:00Z',
            end_date: '2025-12-30T18:00:00Z'
          });
        
        expect(res.statusCode).toEqual(400);
      });

      it('should fail for non-admin user', async () => {
        const res = await request(app)
          .put(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${memberToken}`)
          .send({
            title: 'Unauthorized Update'
          });
        
        expect(res.statusCode).toEqual(403);
      });
    });

    describe('DELETE /events/{id}', () => {
      it('should delete event as admin', async () => {
        const res = await request(app)
          .delete(`/api/events/${testEventId}`)
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(res.statusCode).toEqual(204);
      });

      it('should fail for non-admin user', async () => {
        // First create a new event to delete
        const createRes = await request(app)
          .post('/api/events')
          .set('Authorization', `Bearer ${adminToken}`)
          .send({
            title: 'To Delete',
            description: 'Will try to delete',
            event_date: '2025-12-31T18:00:00Z',
            location: 'Test'
          });
        
        const res = await request(app)
          .delete(`/api/events/${createRes.body.id}`)
          .set('Authorization', `Bearer ${memberToken}`);
        
        expect(res.statusCode).toEqual(403);
      });
    });
  });
});

================
File: test/seeders/test-seed.js
================
'use strict';
const bcrypt = require('bcrypt');

module.exports = {
  async up(queryInterface, Sequelize) {
    // Test admin user
    await queryInterface.bulkInsert('users', [{
      name: 'Test Admin',
      email: 'testadmin@example.com',
      password: await bcrypt.hash('testadmin123', 10),
      role: 'admin',
      status: 'approved',
      email_verified: true,
      created_at: new Date(),
      updated_at: new Date()
    }], {});

    // Test member users with different statuses
    await queryInterface.bulkInsert('users', [
      {
        name: 'Active Member',
        email: 'active@example.com',
        password: await bcrypt.hash('member123', 10),
        role: 'member',
        status: 'approved',
        email_verified: true,
        created_at: new Date(),
        updated_at: new Date()
      },
      {
        name: 'Pending Member',
        email: 'pending@example.com',
        password: await bcrypt.hash('member123', 10),
        role: 'member',
        status: 'pending',
        email_verified: false,
        created_at: new Date(),
        updated_at: new Date()
      },
      {
        name: 'Rejected Member',
        email: 'rejected@example.com',
        password: await bcrypt.hash('member123', 10),
        role: 'member',
        status: 'rejected',
        email_verified: false,
        created_at: new Date(),
        updated_at: new Date()
      }
    ], {});

    // Basic site configuration
    await queryInterface.bulkInsert('config', [
      {
        key: 'hoa_name',
        value: 'Test HOA'
      },
      {
        key: 'hoa_description',
        value: 'Test HOA Description'
      }
      // You could add hoa_logo here too if needed for other tests
    ], {});
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.bulkDelete('users', {
      email: [
        'testadmin@example.com',
        'active@example.com',
        'pending@example.com',
        'rejected@example.com'
      ]
    }, {});

    await queryInterface.bulkDelete('config', {
      key: ['hoa_name', 'hoa_description']
    }, {});
  }
};

================
File: test/utils/dbHelpers.js
================
const request = require('supertest');
const app = require('../../src/app');
const { execSync } = require('child_process');
const path = require('path');

const run = (command) => {
  try {
    execSync(command, {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit',
    });
  } catch (error) {
    console.error(`Failed to execute command: ${command}`, error);
    throw error;
  }
};

const setupTestDB = () => {
  console.log('--- Setting up test database ---');
  // Run migrations to create the tables
  run('NODE_ENV=test npx sequelize-cli db:migrate');
  // Run seeders to populate the tables
  run('NODE_ENV=test npx sequelize-cli db:seed:all --seeders-path test/seeders');
  console.log('--- Test database setup complete ---');
};

const teardownTestDB = () => {
  console.log('--- Tearing down test database ---');
  // Undo all migrations to leave a clean state
  run('NODE_ENV=test npx sequelize-cli db:migrate:undo:all');
  console.log('--- Test database teardown complete ---');
};

const seedTestDB = () => {
  try {
    execSync('NODE_ENV=test npm run db:seed:test', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
  } catch (error) {
    console.error('Failed to seed test database:', error);
    throw error;
  }
};

const cleanTestDB = () => {
  try {
    execSync('NODE_ENV=test npm run db:seed:undo:test:all', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
  } catch (error) {
    console.error('Failed to clean test database:', error);
    throw error;
  }
};

const resetTestDB = async () => {
  try {
    execSync('NODE_ENV=test npm run db:migrate:undo:all', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
    execSync('NODE_ENV=test npm run db:migrate', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
    execSync('NODE_ENV=test npm run db:seed:undotest:all', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
  } catch (error) {
    console.error('Failed to reset test database:', error);
    throw error;
  }
};

/**
 * Creates a new user, approves them with an admin token, and returns the new user's token.
 * @param {object} userDetails - The user's details { name, email, password }.
 * @param {string} adminToken - A valid admin JWT for approving the user.
 * @returns {Promise<string>} The JWT for the newly created and approved user.
 */
const createAndApproveUser = async (userDetails, adminToken) => {
  // 1. Register the user
  const registerRes = await request(app)
    .post('/api/auth/register')
    .send(userDetails);
  
  // A simple check to ensure registration worked before proceeding
  if (registerRes.statusCode !== 201) {
    console.error('Failed to register user in helper:', registerRes.body);
    throw new Error(`User registration failed for ${userDetails.email}`);
  }
  const newUserId = registerRes.body.user.id;

  // 2. Approve the user
  const approvalRes = await request(app)
    .put(`/api/admin/users/${newUserId}/status`)
    .set('Authorization', `Bearer ${adminToken}`)
    .send({ status: 'approved' });

  if (approvalRes.statusCode !== 200) {
    console.error('Failed to approve user in helper:', approvalRes.body);
    throw new Error(`User approval failed for ${userDetails.email}`);
  }

  // 3. Log the user in
  const loginRes = await request(app)
    .post('/api/auth/login')
    .send({
      email: userDetails.email,
      password: userDetails.password,
    });
  
  if (loginRes.statusCode !== 200) {
    console.error('Failed to log in new user in helper:', loginRes.body);
    throw new Error(`User login failed for ${userDetails.email}`);
  }

  // 4. Return the token
  return loginRes.body.token;
};

const createAndApproveUserForUserManagement = async (userDetails, adminToken) => {
  // 1. Register the user
  const registerRes = await request(app)
    .post('/api/auth/register')
    .send(userDetails);
  
  if (registerRes.statusCode !== 201) {
    console.error('Failed to register user in helper:', registerRes.body);
    throw new Error(`User registration failed for ${userDetails.email}`);
  }
  const newUserId = registerRes.body.user.id;

  // 2. Approve the user
  const approvalRes = await request(app)
    .put(`/api/admin/users/${newUserId}/status`)
    .set('Authorization', `Bearer ${adminToken}`)
    .send({ status: 'approved' });

  if (approvalRes.statusCode !== 200) {
    console.error('Failed to approve user in helper:', approvalRes.body);
    throw new Error(`User approval failed for ${userDetails.email}`);
  }

  // 3. Log the user in
  const loginRes = await request(app)
    .post('/api/auth/login')
    .send({
      email: userDetails.email,
      password: userDetails.password,
    });
  
  if (loginRes.statusCode !== 200) {
    console.error('Failed to log in new user in helper:', loginRes.body);
    throw new Error(`User login failed for ${userDetails.email}`);
  }

  // 4. Return both the token and the user object
  return { token: loginRes.body.token, user: loginRes.body.user };
};

module.exports = {
  seedTestDB,
  cleanTestDB, 
  resetTestDB,
  setupTestDB,
  teardownTestDB,
  createAndApproveUser,
  createAndApproveUserForUserManagement,
};

================
File: test/utils/testSetup.js
================
const { execSync } = require('child_process');
const path = require('path');

module.exports = async () => {
  // Setup test database
  try {
    execSync('npm run db:migrate:undo:all', { 
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
    execSync('npm run db:migrate', {
      cwd: path.join(__dirname, '../../'), 
      stdio: 'inherit'
    });
    execSync('npm run db:seed:undo:test:all', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'  
    });
    execSync('npm run db:seed:test', {
      cwd: path.join(__dirname, '../../'),
      stdio: 'inherit'
    });
  } catch (error) {
    console.error('Test setup failed:', error);
    process.exit(1);
  }
};

================
File: package.json
================
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "test:integration": "jest --runInBand --bail --testPathPattern=integration/",
    "test:debugging": "jest --runInBand --bail --testPathPattern=good/",
    "test:watch": "jest --watch",
    "start": "node src/app.js",
    "db:migrate": "npx sequelize-cli db:migrate",
    "db:migrate:undo:all": "npx sequelize-cli db:migrate:undo:all",
    "db:seed": "npx sequelize-cli db:seed:all",
    "db:seed:undo:all": "npx sequelize-cli db:seed:undo:all",
    "db:seed:test": "npx sequelize-cli db:seed:all --seeders-path test/seeders",
    "db:seed:undo:test:all": "npx sequelize-cli db:seed:undo:all --seeders-path test/seeders"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^6.0.0",
    "dompurify": "^3.2.6",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "express-validator": "^7.0.1",
    "http-status": "^1.5.0",
    "joi": "^17.13.3",
    "jsdom": "^26.1.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.0",
    "sequelize": "^6.37.7",
    "sqlite3": "^5.1.7"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "nodemon": "^3.1.10",
    "sequelize-cli": "^6.6.3",
    "supertest": "^7.1.1"
  }
}
